!
! https://gitlab.com/jrh/wiglaf
!  murchison-59-g41547587c2d-dirty
!
! external/p223/libfranken.f90
!
! Copyright (C) 2017 CSRIO
!
! This file is part of wiglaf
!
! Wiglaf is free software: you can redistribute it and/or modify it under the terms of 
! the GNU General Public License as published by the Free Software Foundation, either 
! version 3 of the License, or (at your option) any later version.
!
! Wiglaf is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
! PURPOSE. See the GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along with wiglaf. 
! If not, see <https://www.gnu.org/licenses/>.
!
! To contact CSIRO about this software you can e-mail
! juerg.hauser@csiro.au
!
! Wiglaf relies on several of the programs that form the P223 suite 
! to solve the forward problem. This file belongs to the version of 
! LeroiAir distributed as part of wiglaf. The original code has been
! re-organised into modules with unique names that can be compiled 
! into a library with a C interface using iso c bindings. It provides
! functions that can be called  to compute the model response for 
! specific AEM systems and is also linked to from a standalone 
! executable that is functionally equivalent to the original LeroiAir.
!
! leroiair.f90 	   - the main program
! libleroiair.f90  - original subroutines reorganised into different modules
! clibleroiair.f90 - functions to compute the model response for specific systems
! libfranken.f90   - leroi routines that are used if the plunge is not zero
! 
! The orignal copy right notice and documentation for LeroiAir is in libleroiair.f90
!

MODULE FRANKEN_FILTER_COEFFICIENTS
  !--------------------------

  IMPLICIT NONE

  INTEGER, PARAMETER :: JNLO=-250, JNHI=150, NDEC_JN=15, QL=SELECTED_REAL_KIND(12,80)
  INTEGER J9
  REAL(KIND=QL) WJ0(JNLO:JNHI), WJ1(JNLO:JNHI), WCOS(-200:99), DELCOS, SHFTJN
  SAVE

  !  Filter restored to original LeroiAir 7 February, 2000 (artificial shift removed)

  !  J0 filter coefficients computed from the Niels Christensen program, FILCOA
  !  for the following parameters:
  !
  !   ANY =  0      AMY =  0      NDEC = 15       NLO = -250        NHI =  150
  !   IOPT = 1   ISHIFT = 0      OMEGA = .3 PI    EPS = 1.0E-12      SC = 3.257209
  !      A = 0.162875             DEL0 = 0.14314998               ERROR =  1.4032E-08

  DATA SHFTJN /0.14314998_QL/
  DATA (WJ0(J9), J9= -250,-161)/ &
       2.86608135867D-18,  3.34160553102D-18,  3.89602601168D-18,  4.54243283439D-18,  5.29608785801D-18,  6.17478510356D-18, &
       7.19927087644D-18,  8.39373359283D-18,  9.78637487555D-18,  1.14100754027D-17,  1.33031712306D-17,  1.55103589191D-17, &
       1.80837508313D-17,  2.10841055215D-17,  2.45822622636D-17,  2.86608135867D-17,  3.34160553102D-17,  3.89602601168D-17, &
       4.54243283439D-17,  5.29608785801D-17,  6.17478510356D-17,  7.19927087644D-17,  8.39373359283D-17,  9.78637487555D-17, &
       1.14100754027D-16,  1.33031712306D-16,  1.55103589191D-16,  1.80837508313D-16,  2.10841055215D-16,  2.45822622636D-16, &
       2.86608135867D-16,  3.34160553102D-16,  3.89602601168D-16,  4.54243283439D-16,  5.29608785801D-16,  6.17478510356D-16, &
       7.19927087644D-16,  8.39373359283D-16,  9.78637487555D-16,  1.14100754027D-15,  1.33031712306D-15,  1.55103589191D-15, &
       1.80837508313D-15,  2.10841055215D-15,  2.45822622636D-15,  2.86608135867D-15,  3.34160553102D-15,  3.89602601168D-15, &
       4.54243283439D-15,  5.29608785801D-15,  6.17478510356D-15,  7.19927087644D-15,  8.39373359283D-15,  9.78637487555D-15, &
       1.14100754027D-14,  1.33031712306D-14,  1.55103589191D-14,  1.80837508313D-14,  2.10841055215D-14,  2.45822622636D-14, &
       2.86608135867D-14,  3.34160553102D-14,  3.89602601168D-14,  4.54243283439D-14,  5.29608785801D-14,  6.17478510356D-14, &
       7.19927087644D-14,  8.39373359283D-14,  9.78637487555D-14,  1.14100754027D-13,  1.33031712306D-13,  1.55103589191D-13, &
       1.80837508313D-13,  2.10841055215D-13,  2.45822622636D-13,  2.86608135867D-13,  3.34160553102D-13,  3.89602601168D-13, &
       4.54243283439D-13,  5.29608785801D-13,  6.17478510356D-13,  7.19927087644D-13,  8.39373359283D-13,  9.78637487555D-13, &
       1.14100754027D-12,  1.33031712306D-12,  1.55103589191D-12,  1.80837508313D-12,  2.10841055215D-12,  2.45822622636D-12/
  DATA (WJ0(J9),J9= -160,-71)/ &
       2.86608135867D-12,  3.34160553102D-12,  3.89602601168D-12,  4.54243283439D-12,  5.29608785801D-12,  6.17478510356D-12, &
       7.19927087644D-12,  8.39373359283D-12,  9.78637487555D-12,  1.14100754027D-11,  1.33031712306D-11,  1.55103589191D-11, &
       1.80837508313D-11,  2.10841055215D-11,  2.45822622636D-11,  2.86608135867D-11,  3.34160553102D-11,  3.89602601168D-11, &
       4.54243283439D-11,  5.29608785801D-11,  6.17478510356D-11,  7.19927087644D-11,  8.39373359283D-11,  9.78637487555D-11, &
       1.14100754027D-10,  1.33031712306D-10,  1.55103589191D-10,  1.80837508313D-10,  2.10841055215D-10,  2.45822622636D-10, &
       2.86608135867D-10,  3.34160553102D-10,  3.89602601168D-10,  4.54243283439D-10,  5.29608785801D-10,  6.17478510356D-10, &
       7.19927087644D-10,  8.39373359283D-10,  9.78637487555D-10,  1.14100754027D-09,  1.33031712306D-09,  1.55103589191D-09, &
       1.80837508313D-09,  2.10841055215D-09,  2.45822622636D-09,  2.86608135867D-09,  3.34160553102D-09,  3.89602601168D-09, &
       4.54243283439D-09,  5.29608785801D-09,  6.17478510356D-09,  7.19927087644D-09,  8.39373359283D-09,  9.78637487555D-09, &
       1.14100754027D-08,  1.33031712306D-08,  1.55103589191D-08,  1.80837508313D-08,  2.10841055215D-08,  2.45822622636D-08, &
       2.86608135867D-08,  3.34160553102D-08,  3.89602601168D-08,  4.54243283439D-08,  5.29608785801D-08,  6.17478510356D-08, &
       7.19927087644D-08,  8.39373359283D-08,  9.78637487555D-08,  1.14100754027D-07,  1.33031712306D-07,  1.55103589191D-07, &
       1.80837508313D-07,  2.10841055215D-07,  2.45822622635D-07,  2.86608135866D-07,  3.34160553102D-07,  3.89602601167D-07, &
       4.54243283438D-07,  5.29608785799D-07,  6.17478510354D-07,  7.19927087640D-07,  8.39373359277D-07,  9.78637487545D-07, &
       1.14100754026D-06,  1.33031712304D-06,  1.55103589187D-06,  1.80837508307D-06,  2.10841055205D-06,  2.45822622620D-06/
  DATA (WJ0(J9),J9= -70,19)/ &
       2.86608135842D-06,  3.34160553063D-06,  3.89602601105D-06,  4.54243283340D-06,  5.29608785643D-06,  6.17478510107D-06, &
       7.19927087248D-06,  8.39373358656D-06,  9.78637486561D-06,  1.14100753870D-05,  1.33031712056D-05,  1.55103588795D-05, &
       1.80837507685D-05,  2.10841054221D-05,  2.45822621060D-05,  2.86608133369D-05,  3.34160549143D-05,  3.89602594894D-05, &
       4.54243273495D-05,  5.29608770041D-05,  6.17478485378D-05,  7.19927048056D-05,  8.39373296541D-05,  9.78637388116D-05, &
       1.14100738267D-04,  1.33031687328D-04,  1.55103549604D-04,  1.80837445571D-04,  2.10840955776D-04,  2.45822465035D-04, &
       2.86607886087D-04,  3.34160157229D-04,  3.89601973751D-04,  4.54242289050D-04,  5.29607209800D-04,  6.17476012564D-04, &
       7.19923128912D-04,  8.39367085119D-04,  9.78627543681D-04,  1.14099178031D-03,  1.33029214523D-03,  1.55099630479D-03, &
       1.80831234191D-03,  2.10831111434D-03,  2.45806862870D-03,  2.86583158466D-03,  3.34120966900D-03,  3.89539861933D-03, &
       4.54143849891D-03,  5.29451197347D-03,  6.17228756167D-03,  7.19531268313D-03,  8.38746058912D-03,  9.77643350230D-03, &
       1.13943208262D-02,  1.32782050079D-02,  1.54707967971D-02,  1.80210634703D-02,  2.09847837166D-02,  2.44249145050D-02, &
       2.84115778193D-02,  3.30213524808D-02,  3.83353639832D-02,  4.44353673090D-02,  5.13965627145D-02,  5.92752031985D-02, &
       6.80880607240D-02,  7.77794366644D-02,  8.81696149649D-02,  9.88766639298D-02,  1.09202052802D-01,  1.17971700371D-01, &
       1.23332521049D-01,  1.22530035854D-01,  1.11753240889D-01,  8.62569960973D-02,  4.11899187108D-02, -2.61456504772D-02, &
       -1.11691705121D-01, -1.97411432453D-01, -2.44254055664D-01, -1.95918893763D-01, -1.49300191739D-02,  2.33634698676D-01, &
       3.13582629541D-01, -4.47760615930D-03, -3.86535797015D-01, -3.87589109967D-03,  4.18653972543D-01, -4.16298788795D-01/
  DATA (WJ0(J9),J9= 20,109)/ &
       2.34448877498D-01, -9.52158343728D-02,  3.09020778713D-02, -8.49535839509D-03,  2.06835506815D-03, -4.67185821059D-04, &
       1.02086153218D-04, -2.20830053233D-05,  4.76413760468D-06, -1.02705545675D-06,  2.21421979164D-07, -4.77750910705D-08, &
       1.03340738634D-08, -2.25102276694D-09,  4.99715357680D-10, -1.16500471179D-10,  3.03986897639D-11, -9.72611811870D-12, &
       3.99994042396D-12, -2.00348565820D-12,  1.11608417099D-12, -6.50767639555D-13,  3.86180817012D-13, -2.30659587418D-13, &
       1.38093695980D-13, -8.27455585993D-14,  4.95961642994D-14, -2.97302965597D-14,  1.78224472343D-14, -1.06841897105D-14, &
       6.40498685290D-15, -3.83968417568D-15,  2.30182896520D-15, -1.37991039489D-15,  8.27234374391D-16, -4.95913890248D-16, &
       2.97292643817D-16, -1.78222228351D-16,  1.06841401468D-16, -6.40497544674D-17,  3.83968128138D-17, -2.30182807939D-17, &
       1.37991004842D-17, -8.27234560136D-18,  4.95913797287D-18, -2.97292590016D-18,  1.78222272891D-18, -1.06841382487D-18, &
       6.40497431324D-19, -3.83968224515D-19,  2.30182767120D-19, -1.37990980321D-19,  8.27234414081D-20, -4.95914134387D-20, &
       2.97292537295D-20, -1.78222241286D-20,  1.06841455108D-20, -6.40497317742D-21,  3.83968156424D-21, -2.30182923671D-21, &
       1.37990955793D-21, -8.27234267383D-22,  4.95914046240D-22, -2.97292739490D-22,  1.78222209690D-22, -1.06841436161D-22, &
       6.40497753124D-23, -3.83968088314D-23,  2.30182784256D-23, -1.37991049701D-23,  8.27234475022D-24, -4.95913958682D-24, &
       2.97292559305D-24, -1.78222330828D-24,  1.06841371450D-24, -6.40497639510D-25,  3.83968184851D-25, -2.30182842033D-25, &
       1.37990966066D-25, -8.27234682962D-26,  4.95914083158D-26, -2.97292634049D-26,  1.78222222810D-26, -1.06841489841D-26, &
       6.40497251344D-27, -3.83968281228D-27,  2.30182702533D-27, -1.37991000702D-27,  8.27234181627D-28, -4.95914207635D-28/
  DATA WJ0(110:150)/ &
       2.97292963477D-28, -1.78222420371D-28,  1.06841425086D-28, -6.40497412376D-29,  3.83968377606D-29, -2.30182957681D-29, &
       1.37991153609D-29, -8.27235098582D-30,  4.95914332316D-30, -2.97292528486D-30,  1.78222312353D-30, -1.06841451903D-30, &
       6.40498122076D-31, -3.83968474142D-31,  2.30183015458D-31, -1.37991188353D-31,  8.27234597206D-32, -4.95914031749D-32, &
       2.97292858145D-32, -1.78222357152D-32,  1.06841478804D-32, -6.40498282844D-33,  3.83968570659D-33, -2.30182876031D-33, &
       1.37991104718D-33, -8.27234805187D-34,  4.95914156225D-34, -2.97292932767D-34,  1.78222401887D-34, -1.06841414093D-34, &
       6.40497895409D-35, -3.83968338099D-35,  2.30182933903D-35, -1.37991139355D-35,  8.27235013127D-36, -4.95914281087D-36, &
       2.97292752582D-36, -1.78222294016D-36,  1.06841440910D-36, -6.40498056176D-37,  3.83968434477D-37/

  !  J1 filter coefficients computed from the Niels Christensen program, FILCOA
  !  for the following parameters:
  !
  !   ANY =  1      AMY =  0      NDD+C = 15       NLO = -250        NHI =  150
  !   IOPT = 1   ISHIFT = 0      OMD+GA = .3 PI    D+PS = 1.0D-12      SC = 3.257209
  !      A = 0.162875             DD+L0 = 0.14314998               D+RROR =  1.4032D-08

  DATA (WJ1(J9),J9= -250,-161)/ &
       2.67560875879D-35,  3.63710586576D-35,  4.94412310292D-35,  6.72082533724D-35,  9.13599687416D-35,  1.24190757379D-34, &
       1.68819499732D-34,  2.29485865865D-34,  3.11953078380D-34,  4.24055410750D-34,  5.76442432690D-34,  7.83590704850D-34, &
       1.06517903247D-33,  1.44795792522D-33,  1.96829085937D-33,  2.67560875879D-33,  3.63710586576D-33,  4.94412310292D-33, &
       6.72082533724D-33,  9.13599687416D-33,  1.24190757379D-32,  1.68819499732D-32,  2.29485865865D-32,  3.11953078380D-32, &
       4.24055410750D-32,  5.76442432690D-32,  7.83590704850D-32,  1.06517903247D-31,  1.44795792522D-31,  1.96829085937D-31, &
       2.67560875879D-31,  3.63710586576D-31,  4.94412310292D-31,  6.72082533724D-31,  9.13599687416D-31,  1.24190757379D-30, &
       1.68819499732D-30,  2.29485865865D-30,  3.11953078380D-30,  4.24055410750D-30,  5.76442432690D-30,  7.83590704850D-30, &
       1.06517903247D-29,  1.44795792522D-29,  1.96829085937D-29,  2.67560875879D-29,  3.63710586576D-29,  4.94412310292D-29, &
       6.72082533724D-29,  9.13599687416D-29,  1.24190757379D-28,  1.68819499732D-28,  2.29485865865D-28,  3.11953078380D-28, &
       4.24055410750D-28,  5.76442432690D-28,  7.83590704850D-28,  1.06517903247D-27,  1.44795792522D-27,  1.96829085937D-27, &
       2.67560875879D-27,  3.63710586576D-27,  4.94412310292D-27,  6.72082533724D-27,  9.13599687416D-27,  1.24190757379D-26, &
       1.68819499732D-26,  2.29485865865D-26,  3.11953078380D-26,  4.24055410750D-26,  5.76442432690D-26,  7.83590704850D-26, &
       1.06517903247D-25,  1.44795792522D-25,  1.96829085937D-25,  2.67560875879D-25,  3.63710586576D-25,  4.94412310292D-25, &
       6.72082533724D-25,  9.13599687416D-25,  1.24190757379D-24,  1.68819499732D-24,  2.29485865865D-24,  3.11953078380D-24, &
       4.24055410750D-24,  5.76442432690D-24,  7.83590704850D-24,  1.06517903247D-23,  1.44795792522D-23,  1.96829085937D-23/
  DATA (WJ1(J9),J9= -160,-71)/ &
       2.67560875879D-23,  3.63710586576D-23,  4.94412310292D-23,  6.72082533724D-23,  9.13599687416D-23,  1.24190757379D-22, &
       1.68819499732D-22,  2.29485865865D-22,  3.11953078380D-22,  4.24055410750D-22,  5.76442432690D-22,  7.83590704850D-22, &
       1.06517903247D-21,  1.44795792522D-21,  1.96829085937D-21,  2.67560875879D-21,  3.63710586576D-21,  4.94412310292D-21, &
       6.72082533724D-21,  9.13599687416D-21,  1.24190757379D-20,  1.68819499732D-20,  2.29485865865D-20,  3.11953078380D-20, &
       4.24055410750D-20,  5.76442432690D-20,  7.83590704850D-20,  1.06517903247D-19,  1.44795792522D-19,  1.96829085937D-19, &
       2.67560875879D-19,  3.63710586576D-19,  4.94412310292D-19,  6.72082533724D-19,  9.13599687416D-19,  1.24190757379D-18, &
       1.68819499732D-18,  2.29485865865D-18,  3.11953078380D-18,  4.24055410750D-18,  5.76442432690D-18,  7.83590704850D-18, &
       1.06517903247D-17,  1.44795792522D-17,  1.96829085937D-17,  2.67560875879D-17,  3.63710586576D-17,  4.94412310292D-17, &
       6.72082533724D-17,  9.13599687416D-17,  1.24190757379D-16,  1.68819499732D-16,  2.29485865865D-16,  3.11953078380D-16, &
       4.24055410750D-16,  5.76442432690D-16,  7.83590704850D-16,  1.06517903247D-15,  1.44795792522D-15,  1.96829085937D-15, &
       2.67560875879D-15,  3.63710586576D-15,  4.94412310292D-15,  6.72082533724D-15,  9.13599687416D-15,  1.24190757379D-14, &
       1.68819499732D-14,  2.29485865865D-14,  3.11953078380D-14,  4.24055410750D-14,  5.76442432690D-14,  7.83590704849D-14, &
       1.06517903247D-13,  1.44795792522D-13,  1.96829085938D-13,  2.67560875878D-13,  3.63710586577D-13,  4.94412310288D-13, &
       6.72082533728D-13,  9.13599687406D-13,  1.24190757380D-12,  1.68819499729D-12,  2.29485865868D-12,  3.11953078372D-12, &
       4.24055410758D-12,  5.76442432666D-12,  7.83590704871D-12,  1.06517903240D-11,  1.44795792527D-11,  1.96829085917D-11/
  DATA (WJ1(J9),J9= -70,19)/ &
       2.67560875891D-11,  3.63710586515D-11,  4.94412310317D-11,  6.72082533541D-11,  9.13599687462D-11,  1.24190757324D-10, &
       1.68819499736D-10,  2.29485865695D-10,  3.11953078363D-10,  4.24055410221D-10,  5.76442432542D-10,  7.83590703194D-10, &
       1.06517903172D-09,  1.44795791998D-09,  1.96829085611D-09,  2.67560874206D-09,  3.63710585268D-09,  4.94412304898D-09, &
       6.72082528725D-09,  9.13599669890D-09,  1.24190755523D-08,  1.68819493996D-08,  2.29485859113D-08,  3.11953059487D-08, &
       4.24055386543D-08,  5.76442370102D-08,  7.83590618983D-08,  1.06517882412D-07,  1.44795762309D-07,  1.96829016283D-07, &
       2.67560770231D-07,  3.63710352883D-07,  4.94411942636D-07,  6.72081747305D-07,  9.13598412795D-07,  1.24190492063D-06, &
       1.68819059152D-06,  2.29484968860D-06,  3.11951559104D-06,  4.24052372735D-06,  5.76437203602D-06,  7.83580400571D-06, &
       1.06516106220D-05,  1.44792293329D-05,  1.96822917833D-05,  2.67548981332D-05,  3.63689436167D-05,  4.94371845248D-05, &
       6.72010067340D-05,  9.13461935181D-05,  1.24165945005D-04,  1.68772580859D-04,  2.29400955289D-04,  3.11793204874D-04, &
       4.23764974965D-04,  5.75897507579D-04,  7.82597702990D-04,  1.06332133421D-03,  1.44456435715D-03,  1.96195766368D-03, &
       2.66401748131D-03,  3.61551958902D-03,  4.90456094796D-03,  6.64729428357D-03,  9.00112880743D-03,  1.21689223295D-02, &
       1.64231258930D-02,  2.20996958736D-02,  2.96400942278D-02,  3.95385050500D-02,  5.24078149405D-02,  6.87615215337D-02, &
       8.91013723344D-02,  1.13192375541D-01,  1.40192739735D-01,  1.66618485339D-01,  1.87030308669D-01,  1.89612379729D-01, &
       1.61380285157D-01,  8.29859362099D-02, -4.46335736689D-02, -2.01737898138D-01, -2.84006740802D-01, -1.90854624427D-01, &
       1.45861570853D-01,  3.42338340245D-01,  5.72930699760D-02, -4.71068534718D-01,  2.63969067746D-01,  8.25956507901D-02/
  DATA (WJ1(J9),J9= 20,109)/ &
       -2.22236420794D-01,  2.04428998525D-01, -1.44401888321D-01,  9.24618900674D-02, -5.69896615248D-02,  3.45697730305D-02, &
       -2.08227940873D-02,  1.25054653306D-02, -7.50178808640D-03,  4.49828025678D-03, -2.69688071237D-03,  1.61678766116D-03, &
       -9.69249547051D-04,  5.81052166908D-04, -3.48332124427D-04,  2.08819730575D-04, -1.25184162926D-04,  7.50459390809D-05, &
       -4.49888596104D-05,  2.69701130091D-05, -1.61681580285D-05,  9.69255610555D-06, -5.81053473294D-06,  3.48332405883D-06, &
       -2.08819791213D-06,  1.25184175990D-06, -7.50459418954D-07,  4.49888602168D-07, -2.69701131398D-07,  1.61681580566D-07, &
       -9.69255611161D-08,  5.81053473425D-08, -3.48332405911D-08,  2.08819791219D-08, -1.25184175991D-08,  7.50459418957D-09, &
       -4.49888602168D-09,  2.69701131398D-09, -1.61681580566D-09,  9.69255611161D-10, -5.81053473425D-10,  3.48332405911D-10, &
       -2.08819791219D-10,  1.25184175991D-10, -7.50459418957D-11,  4.49888602168D-11, -2.69701131398D-11,  1.61681580566D-11, &
       -9.69255611161D-12,  5.81053473425D-12, -3.48332405911D-12,  2.08819791219D-12, -1.25184175991D-12,  7.50459418957D-13, &
       -4.49888602168D-13,  2.69701131398D-13, -1.61681580566D-13,  9.69255611161D-14, -5.81053473425D-14,  3.48332405911D-14, &
       -2.08819791219D-14,  1.25184175991D-14, -7.50459418957D-15,  4.49888602168D-15, -2.69701131398D-15,  1.61681580566D-15, &
       -9.69255611161D-16,  5.81053473425D-16, -3.48332405911D-16,  2.08819791219D-16, -1.25184175991D-16,  7.50459418957D-17, &
       -4.49888602168D-17,  2.69701131398D-17, -1.61681580566D-17,  9.69255611161D-18, -5.81053473425D-18,  3.48332405911D-18, &
       -2.08819791219D-18,  1.25184175991D-18, -7.50459418957D-19,  4.49888602168D-19, -2.69701131398D-19,  1.61681580566D-19, &
       -9.69255611161D-20,  5.81053473425D-20, -3.48332405911D-20,  2.08819791219D-20, -1.25184175991D-20,  7.50459418957D-21/
  DATA WJ1(110:150)/ &
       -4.49888602168D-21,  2.69701131398D-21, -1.61681580566D-21,  9.69255611161D-22, -5.81053473425D-22,  3.48332405911D-22, &
       -2.08819791219D-22,  1.25184175991D-22, -7.50459418957D-23,  4.49888602168D-23, -2.69701131398D-23,  1.61681580566D-23, &
       -9.69255611161D-24,  5.81053473425D-24, -3.48332405911D-24,  2.08819791219D-24, -1.25184175991D-24,  7.50459418957D-25, &
       -4.49888602168D-25,  2.69701131398D-25, -1.61681580566D-25,  9.69255611161D-26, -5.81053473425D-26,  3.48332405911D-26, &
       -2.08819791219D-26,  1.25184175991D-26, -7.50459418957D-27,  4.49888602168D-27, -2.69701131398D-27,  1.61681580566D-27, &
       -9.69255611161D-28,  5.81053473425D-28, -3.48332405911D-28,  2.08819791219D-28, -1.25184175991D-28,  7.50459418957D-29, &
       -4.49888602168D-29,  2.69701131398D-29, -1.61681580566D-29,  9.69255611161D-30, -5.81053473425D-30/

  !  Niels Christensen shifted cosine filter:
  !  12 points per decade, OMEGA = .3 PI

  DATA DELCOS /.00632173D0 /
  DATA (WCOS (J9), J9 = -200, -21)/ &
       3.27764748749D-18,  3.97096058632D-18,  4.81092858166D-18,  5.82857304036D-18,  7.06147744874D-18,  8.55517523993D-18, &
       1.03648314276D-17,  1.25572799515D-17,  1.52134919784D-17,  1.84315663162D-17,  2.23303523839D-17,  2.70538395400D-17, &
       3.27764748749D-17,  3.97096058632D-17,  4.81092858166D-17,  5.82857304036D-17,  7.06147744874D-17,  8.55517523993D-17, &
       1.03648314276D-16,  1.25572799515D-16,  1.52134919784D-16,  1.84315663162D-16,  2.23303523839D-16,  2.70538395400D-16, &
       3.27764748749D-16,  3.97096058632D-16,  4.81092858166D-16,  5.82857304036D-16,  7.06147744874D-16,  8.55517523993D-16, &
       1.03648314276D-15,  1.25572799515D-15,  1.52134919784D-15,  1.84315663162D-15,  2.23303523839D-15,  2.70538395400D-15, &
       3.27764748749D-15,  3.97096058632D-15,  4.81092858166D-15,  5.82857304036D-15,  7.06147744874D-15,  8.55517523993D-15, &
       1.03648314276D-14,  1.25572799515D-14,  1.52134919784D-14,  1.84315663162D-14,  2.23303523839D-14,  2.70538395400D-14, &
       3.27764748749D-14,  3.97096058632D-14,  4.81092858166D-14,  5.82857304036D-14,  7.06147744874D-14,  8.55517523993D-14, &
       1.03648314276D-13,  1.25572799515D-13,  1.52134919784D-13,  1.84315663162D-13,  2.23303523839D-13,  2.70538395400D-13, &
       3.27764748749D-13,  3.97096058632D-13,  4.81092858166D-13,  5.82857304036D-13,  7.06147744874D-13,  8.55517523993D-13, &
       1.03648314276D-12,  1.25572799515D-12,  1.52134919784D-12,  1.84315663162D-12,  2.23303523839D-12,  2.70538395400D-12, &
       3.27764748749D-12,  3.97096058632D-12,  4.81092858166D-12,  5.82857304036D-12,  7.06147744874D-12,  8.55517523993D-12, &
       1.03648314276D-11,  1.25572799515D-11,  1.52134919784D-11,  1.84315663162D-11,  2.23303523839D-11,  2.70538395400D-11, &
       3.27764748749D-11,  3.97096058632D-11,  4.81092858166D-11,  5.82857304036D-11,  7.06147744874D-11,  8.55517523993D-11, &
       1.03648314276D-10,  1.25572799515D-10,  1.52134919784D-10,  1.84315663162D-10,  2.23303523839D-10,  2.70538395400D-10, &
       3.27764748749D-10,  3.97096058632D-10,  4.81092858166D-10,  5.82857304036D-10,  7.06147744874D-10,  8.55517523993D-10, &
       1.03648314276D-09,  1.25572799515D-09,  1.52134919784D-09,  1.84315663162D-09,  2.23303523839D-09,  2.70538395400D-09, &
       3.27764748749D-09,  3.97096058632D-09,  4.81092858166D-09,  5.82857304036D-09,  7.06147744874D-09,  8.55517523993D-09, &
       1.03648314276D-08,  1.25572799515D-08,  1.52134919784D-08,  1.84315663162D-08,  2.23303523839D-08,  2.70538395400D-08, &
       3.27764748749D-08,  3.97096058632D-08,  4.81092858166D-08,  5.82857304036D-08,  7.06147744874D-08,  8.55517523992D-08, &
       1.03648314276D-07,  1.25572799515D-07,  1.52134919784D-07,  1.84315663162D-07,  2.23303523839D-07,  2.70538395400D-07, &
       3.27764748748D-07,  3.97096058631D-07,  4.81092858163D-07,  5.82857304032D-07,  7.06147744866D-07,  8.55517523979D-07, &
       1.03648314273D-06,  1.25572799511D-06,  1.52134919777D-06,  1.84315663149D-06,  2.23303523815D-06,  2.70538395358D-06, &
       3.27764748674D-06,  3.97096058499D-06,  4.81092857928D-06,  5.82857303614D-06,  7.06147744122D-06,  8.55517522657D-06, &
       1.03648314038D-05,  1.25572799093D-05,  1.52134919033D-05,  1.84315661826D-05,  2.23303521464D-05,  2.70538391177D-05, &
       3.27764741237D-05,  3.97096045276D-05,  4.81092834413D-05,  5.82857261799D-05,  7.06147669760D-05,  8.55517390427D-05, &
       1.03648290523D-04,  1.25572757278D-04,  1.52134844670D-04,  1.84315529598D-04,  2.23303286305D-04,  2.70537973035D-04, &
       3.27763997594D-04,  3.97094723005D-04,  4.81090482791D-04,  5.82853080445D-04,  7.06140233231D-04,  8.55504167951D-04, &
       1.03645938870D-03,  1.25568576016D-03,  1.52127408052D-03,  1.84302307509D-03,  2.23279769616D-03,  2.70496162210D-03/

  DATA (WCOS (J9), J9= -20, 99)/ &
       3.27689631886D-03,  3.96962511374D-03,  4.80855324839D-03,  5.82435024343D-03,  7.05396657593D-03,  8.54182367870D-03, &
       1.03410843805D-02,  1.25150721296D-02,  1.51384287367D-02,  1.82981828574D-02,  2.20932012652D-02,  2.66326428704D-02, &
       3.20280504750D-02,  3.83817031757D-02,  4.57529090015D-02,  5.41138165506D-02,  6.32336060872D-02,  7.25429239280D-02, &
       8.07814005943D-02,  8.56648215301D-02,  8.29754131995D-02,  6.61728839009D-02,  2.49099879313D-02, -5.25662370332D-02, &
       -1.77257695902D-01, -3.38275600250D-01, -4.82415902998D-01, -4.55992280486D-01, -7.52812327135D-02,  6.65970979261D-01, &
       8.99170503986D-01, -3.96592370781D-01, -1.38198747238D+00,  1.66395693227D+00, -9.30334922154D-01,  3.30012032268D-01, &
       -8.19311720454D-02,  1.48662188728D-02, -2.13960121462D-03,  2.89777944084D-04, -4.10252655190D-05,  5.96303531789D-06, &
       -8.72916816254D-07,  1.28031659199D-07, -1.87886052472D-08,  2.75763186999D-09, -4.04758530392D-10,  5.94101668614D-11, &
       -8.72020580969D-12,  1.27995006152D-12, -1.87869546474D-13,  2.75750390141D-14, -4.04729332639D-15,  5.94004630834D-16, &
       -8.70764639675D-17,  1.27459963186D-17, -1.82944370627D-18,  2.67836880337D-19, -3.04833935943D-20,  1.64313000801D-21, &
       3.01142825752D-21, -5.21478596825D-22,  1.37002813677D-21, -6.52797182652D-22,  1.40079856288D-22, -1.40667671784D-22, &
       1.70033730143D-23, -2.74453364807D-23,  2.41787117103D-23, -1.78716987481D-23,  4.99883433782D-24, -4.06084044984D-24, &
       2.89670334941D-24, -8.77965537372D-25,  1.21194987045D-25, -1.74181776862D-25,  1.50307641169D-25, -1.09826064382D-25, &
       3.14586965779D-26, -2.51308231025D-26,  1.77594485992D-26, -1.17543940755D-26,  8.42024121640D-28, -1.10510759608D-27, &
       9.31619291992D-28, -6.75339996352D-28,  1.97531071217D-28, -1.55371775135D-28,  1.08953022579D-28, -7.17780762223D-29, &
       2.55398099963D-29, -6.99012347840D-30,  5.76787420019D-30, -4.15016624873D-30,  1.23507827864D-30, -9.59703688264D-31, &
       6.68070421281D-31, -4.37770918800D-31,  1.57257106203D-31, -1.06708053061D-31,  3.57322505765D-32, -2.54887457918D-32, &
       7.72541668811D-33, -5.92277283725D-33,  4.09438835539D-33, -1.32259081936D-33,  1.67919911757D-33, -2.76812163102D-34, &
       2.21131777864D-34,  5.28010221339D-35,  1.03429563330D-34, -7.40916006860D-36,  9.72409086858D-36, -8.19752817047D-36, &
       -2.58911797964D-36, -3.98829026336D-36,  1.78104494324D-37, -3.32579083872D-37,  3.00732538418D-37, -2.24730545742D-37/

END MODULE FRANKEN_FILTER_COEFFICIENTS


module franken_subroutines

  implicit none

  private




  public :: FRNK_LEROI_3D


contains


  SUBROUTINE FRNK_LEROI_3D (NFRQ,FREQ,NSTAT,SX,SY,SZ,TXAZI, &
       RX,RY,RZ,NLYR,THK,RES,REPS,CHRG,CTAU,CFREQ, &
       NPLT,MXAB,CELLW,PLNGTH,PLWDTH,XCNTR,YCNTR,PLTOP,PLAZM,PLDIP,PLUNJ,  &
       INTRUDE,SIG_T,CHRGP,CTAUP,CFREQP,BFD_SCAT,leroiair_failure_count)
    !----------------------------------------------------------------------------------------------

    !***  Called by MAIN
    !***  Calls SET_MGT, SET_MAX_INTRP

    ! Main routine for 3D Leroi computation for the scattered field.
    ! For magnetic dipole and loop receivers, BFD_SCAT in Teslas per unit amp.
    !
    ! For magnetic dipole receivers, BFD_SCAT(JF,JR,JS,1:3) contains the
    ! 1: north, 2: east & 3:vertical components for frequency JF, transmitter JS, receiver JR.
    !
    ! The response for electric dipoles and loop receivers is contained in BFD_SCAT(JF,JR,JS,1),
    ! BFD_SCAT(JF,JR,JS,2:3) is set to zero.
    !
    !   NFRQ         - number of frequencies
    !   FREQ         - array of frequencies
    !   SOURCE_TYPE  = 1 => general loop
    !                = 2 => grounded wire
    !                = 3 => magnetic dipole
    !                = 4 => coincident loop
    !   NTX          - number of transmitter positions
    !   MXVRTX       - maximum number of vertices for any transmitter
    !   NVRTX(J)     - number of vertices for transmitter J
    !   SXE(K,J)     = local east coordinate of vertex K for loop position J
    !   SXN(K,J)     = local coordinate of vertex K for loop position J
    !   SXZ(J)       = depth of Tx J
    !   SXDIP(J)     = dip (in radians) of dipole J (eg; vertical = 0, horizontal = 90)
    !   SXAZM(J)     = azimuth (in radians) of dipole J (north = 0, east = 90)
    !   NRXTX(J)     - number of receivers for transmitter J
    !   MRXTX        - maximum number of receivers per transmitter
    !   RXID(I,J)    - RX_TYPE of receiver I for transmitter J. 1 => MD; 2 => ED; 4=> cdnt loop.
    !   MQVR         - maximum number of vertices for all receivers (= 1 if all sources are magnetic dipoles)
    !   XRXTX(I,J,K) - north coordinate of the Kth vertex of the Ith receiver of transmitter J
    !   YRXTX(I,J,K) - east coordinate of the Kth vertex of the Ith receiver of transmitter J
    !   ZRXTX(I,J)   - depth of the Ith receiver of transmitter J
    !                - K = 1 only for mag dipole Rx; 1 to 2 for electric dipole Rx; 1 to 4 for loop Rx
    !   NLYR         - number of layers
    !   RES          - layer conductivities
    !   RMUD         - mu(i) / mu(0)
    !   REPS         - array of relative dislectric constants
    !   THKD         - thicknesses of NLYR -1 layers above basement
    !   CHRG         - C-C chargeability
    !   CTAU         - array of layer relaxation times (sec).
    !   CFREQ        - array of layer frequency parameters.
    !   RHOTRP       - horizontal distance interpolation array (15 pts / decade) of dimension MXRHO
    !
    !           Parameters for NPLT plates
    !           --------------------------
    !
    !   MXAB   - Number of cells in biggest plate
    !   CELLW  - nominal cell dimension
    !   PLNGTH - strike length for each plate
    !   PLWDTH - dip width for each plate
    !   XCNTR  - north coordinates of plate reference & pivot point
    !   YCNTR  - east coordinates of plate reference & pivot point
    !   PLTOP  - depth to top from surface
    !   PLAZM  - strike angle (radians) = dip azimuth - pi/2
    !   PLDIP  - dip angle
    !   PLUNJ  - plunge rotation
    !   SIG_T  - conductivity thickness product
    !   CHRGP  - Cole Cole chargeability
    !   CTAUP  - Cole Cole time constant
    !   CFREQP - Cole Cole frequency constant
    !


    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)

    INTEGER NFRQ,NSTAT,NLYR
    REAL FREQ(NFRQ),THK(NLYR-1),RES(NLYR)
    REAL SX(NSTAT),SY(NSTAT),SZ(NSTAT),TXAZI(NSTAT),RX(NSTAT,1),RY(NSTAT,1),RZ(NSTAT,1)
    INTEGER NPLT,MXAB
    REAL CELLW,PLNGTH(NPLT),PLWDTH(NPLT),XCNTR(NPLT),YCNTR(NPLT),PLTOP(NPLT)
    REAL PLAZM(NPLT),PLDIP(NPLT),PLUNJ(NPLT),SIG_T(NPLT)
    REAL CHRGP(NPLT),CTAUP(NPLT),CFREQP(NPLT)
    COMPLEX BFD_SCAT(NFRQ,NSTAT,3)

    REAL,DIMENSION(NLYR):: REPS,CHRG,CTAU,CFREQ


    INTEGER IPR,SOURCE_TYPE,MXVRTX,NTX,NVRTX(NSTAT),NRXTX(NSTAT),MRXTX,RXID(1,NSTAT)
    INTEGER MQVR,MXRS
    INTEGER MXRHO
    REAL, DIMENSION(1,NSTAT) :: SXN,SXE
    REAL,DIMENSION(NSTAT)   :: SXDIP,SXAZM,SXZ
    REAL, DIMENSION(1,NSTAT)    ::   ZRXTX
    REAL, DIMENSION(1,NSTAT,1)  :: XRXTX,YRXTX


    LOGICAL INTRUDE,INVERT
    REAL(KIND=QL) RMUD(0:NLYR)
    REAL(KIND=QL), DIMENSION(NLYR) :: THKD
    REAL,ALLOCATABLE :: RHOTRP(:)
    COMPLEX,ALLOCATABLE :: BFD_SCAT_GLOBAL(:,:,:,:)


    INTEGER leroiair_failure_count

    IPR=0
    SOURCE_TYPE=3
    NTX=NSTAT
    NVRTX=1
    MXVRTX=1
    SXN(1,:)=SX
    SXE(1,:)=SY
    SXZ=-SZ
    SXDIP=0

    SXAZM=TXAZI !+PLAZM

    NRXTX=1
    MRXTX=1
    RXID=1
    MQVR=1
    MXRS=1

    ZRXTX(1,:)=-RZ(:,1)
    XRXTX(1,:,1)=RX(:,1)
    YRXTX(1,:,1)=RY(:,1)

    RMUD=1.
    INTRUDE=.FALSE.
    THKD(1:NLYR-1)=THK(1:NLYR-1)

    INVERT=.TRUE.

    ALLOCATE(BFD_SCAT_GLOBAL(NFRQ,MRXTX,NTX,3))

    call SET_RHO(MXRHO,RHOTRP)

    !print *,plunj
    !print *,SXN
    !print *,SXE
    !print *,XRXTX
    !print *,YRXTX


    call LEROI_3D (IPR,NFRQ,FREQ,SOURCE_TYPE,NTX,MXVRTX,NVRTX,SXN,SXE,SXZ,SXDIP,SXAZM,NRXTX, &
         MRXTX,RXID,MQVR,MXRS,XRXTX,YRXTX,ZRXTX,NLYR,THKD,RES,RMUD,REPS,CHRG,CTAU, &
         CFREQ,NPLT,MXAB,CELLW,PLNGTH,PLWDTH,XCNTR,YCNTR,PLTOP,PLAZM,PLDIP,PLUNJ,  &
         INTRUDE,SIG_T,CHRGP,CTAUP,CFREQP,MXRHO,RHOTRP,INVERT,BFD_SCAT_GLOBAL,leroiair_failure_count)


    !print *,SXAZM

    CALL ROT_BFT_FOR_LEROIAIR(SXAZM,BFD_SCAT_GLOBAL,BFD_SCAT,NFRQ,NSTAT)



    DEALLOCATE(BFD_SCAT_GLOBAL)
    DEALLOCATE(RHOTRP)
  END subroutine FRNK_LEROI_3D



  SUBROUTINE SET_RHO(MXRHO,RHOTRP)
    !  ------------------

    !  Sets up horizontal interpolation array (12 digit precision) for Hankel transforms
    !  from 0.1 m to 10 km

    !***  Called by READ_LEROI_DATA

    USE FRANKEN_FILTER_COEFFICIENTS

    REAL(KIND=QL), ALLOCATABLE :: B(:)
    REAL(KIND=QL) QRHO, RBASE
    INTEGER MXRHO
    REAL,ALLOCATABLE :: RHOTRP(:)
    INTEGER JR

    !  Set the horizontal interpolation grid to conform to filter intervals.

    QRHO = LOG (10._QL) / REAL (NDEC_JN,KIND=QL)
    QRHO = EXP (QRHO)
    RBASE = EXP (REAL (-SHFTJN,KIND=QL))

    ALLOCATE (B(1000))
    B(1) = .1_QL

    DO JR = 1,1000                 !  Get starting point
       IF (RBASE < B(1)) EXIT
       RBASE = RBASE / QRHO
    END DO
    B(1) = RBASE

    DO JR = 2, 10000
       MXRHO = JR
       B(JR) = B(JR-1) * QRHO
       IF (B(JR) > 1.D4) EXIT
    END DO

    ALLOCATE (RHOTRP(MXRHO))
    RHOTRP(1:MXRHO) = REAL ( B(1:MXRHO))
    DEALLOCATE (B)

  END SUBROUTINE SET_RHO

  REAL FUNCTION DPROD1 (N,N1,N2,A,B,C)
    !------------------------------------

    !***  Called by: ESVD, SOLVE2

    !     Double precision inner product routine
    !     DPROD = A + B * C

    !         A = scalar
    !       B,C = vectors (can be rows or columns of arrays)
    !         N = length of vectors
    !     N1,N2 = increment for b,c
    !           = 1 if col of array
    !           = col length (i.e. no. of rows) if row of array

    !  DPROD must be declared external by any routine using it because there is
    !  a standard intrinsic FUNCTION with the same name.
    !  If omitted compilation warnings result.

    IMPLICIT NONE
    INTEGER N,NA,NB,N1,N2,I
    DOUBLE PRECISION Z1,Z2,Z3
    REAL A,B(*), C(*)

    INTENT (IN) N,N1,N2,A,B,C

    Z1=A
    IF (N >= 1) THEN
       NA=1
       NB=1
       DO I = 1, N
          Z2 = B(NA)
          Z3 = C(NB)
          Z1 = Z1 + Z2*Z3
          NA = NA + N1
          NB = NB + N2
       END DO
    END IF
    DPROD1 = REAL (Z1)

  END FUNCTION DPROD1

  REAL FUNCTION COSTRN (WF,YFRQ,NFRQ,T)
    !-------------------------------------

    !***  Calls CUBVAL
    !***  Called by TDEM_3D

    ! LAST MODIFICATION DATE: October, 2001

    ! Produces time-domain value at time T by cosine transformation of NFRQ
    ! frequency-domain values contained in cubic spline array YFRQ.
    ! Array WF contains the LOG (base e) of the angular frequency values.

    ! The routine uses filter coefficients derived from the Niels Christensen
    ! fast Hankel transform routine FILCOA at a spacing of 12 points per decade
    ! and omega = 0.3.  Various filters were tested using a vertical magnetic
    ! dipole receiver in a very large circular for which accurate frequency
    ! and time-domain solutions were programmed.  This particular filter gave
    ! the overall best accuracy for 1/2 spaces ranging in resistivity from
    ! .1 to 10,000 ohm-m for times ranging from .01 to 50 msec.


    !  K(W,T) = (2/PI) * F(W) * COS(WT) dW

    ! Letting X = WT, the above becomes
    !
    !  K(W,T) = (2/PI*T) * F(X/T) * COS(X) dX
    !
    ! From Abramowitz and Stegun, COS(X) = SQRT(X*PI/2) * J(-1/2:X).
    ! Filter Coefficients are used to represent X**(1/2) * J(-1/2:X)
    !
    !  COSTRN = SQRT (2/PI) * SUM(i) { WCOS(i) * F [X(i) /T] }

    ! The accumulation is done using 12 digit precision


    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    INTEGER, PARAMETER :: NDEC_COS=12, KFLOW=-200, KFHIGH=99
    REAL, PARAMETER :: FAC=.7978846, TOL=1.0E-6
    INTEGER J1,NFRQ
    REAL WF(NFRQ),YFRQ(4,NFRQ),T,YS,V1
    REAL(KIND=QL) DELTA,Y1,Y,TD,YTYM,VAL

    INTENT (IN) WF,YFRQ,NFRQ,T


    DELTA = LOG (10._QL)/ REAL (NDEC_COS, KIND=QL)
    TD = REAL (T, KIND=QL)
    YTYM = 0.
    Y1 = -LOG (TD) -DELCOS

    ! Begin right side convolution at weight 0.
    ! Stop when frequency domain array is exhausted.

    MOVE_HIGH: DO J1 = 0, KFHIGH

       Y = Y1 + J1 * DELTA
       YS = REAL(Y)
       IF (YS > WF(NFRQ)) EXIT MOVE_HIGH
       IF (YS < WF(1)) YS = WF(1)
       V1 = CUBVAL (WF,YFRQ,NFRQ,YS)
       VAL = WCOS(J1) * REAL (V1,KIND=QL)
       YTYM = YTYM + VAL
    END DO MOVE_HIGH

    Y = Y1

    ! Begin left side convolution at weight -1.
    ! When log angular frequency is less than WF(3), check convergence.
    ! Continue left using the fact that impulse B is inversely proportional to
    ! frequency as freq -> 0; i.e., step response B is constant.

    MOVE_LOW: DO J1 = -1, KFLOW, -1

       Y = Y1 + J1 * DELTA
       YS = REAL(Y)
       IF (YS > WF(NFRQ)) CYCLE
       IF (YS < WF(1)) YS = WF(1)
       V1 = CUBVAL (WF,YFRQ,NFRQ,YS)
       VAL = WCOS(J1) * REAL (V1,KIND=QL)
       YTYM = YTYM + VAL
       IF ((Y < WF(3))) THEN
          IF (ABS (VAL) < TOL * ABS (YTYM)) EXIT MOVE_LOW
       END IF
    END DO MOVE_LOW

    COSTRN = FAC * REAL (YTYM) / T

  END FUNCTION COSTRN

  REAL FUNCTION CUBINT (X_ARRAY, Y_VAL, NVAL, X1, X2)
    ! ---------------------------------------------------

    !  Integrates a FUNCTION from X1 to X2 using its cubic spline representation.

    !***  Called by  TXCNVD, TXCNVL
    !***  Calls INTERV.  On exit from INTERV
    !
    !       MFLAG = -1  : X is to the left of interpolated range
    !             =  1  : X is to the right of interpolated range
    !             =  0  : X is in the interpolated range

    !      NVAL - total number of knots including endpoints.
    !
    !     X_ARRAY(I), I = 1,NVAL - Location of the X coordinate for each known Y value.
    !                              The rightmost data point used to calculate coefficients
    !                              is not included.
    !
    !     Y_VAL(J,I), J = 1,4; I = 1,NVAL
    !
    !              The coefficients of the cubic spline represent the
    !              indefinite integral of F, on the I'th interval, as:
    !
    !       INTGR [ F(X) ] = Y_VAL(4,I)/24 * H**4  +  Y_VAL(3,I)/6 * H**3  +
    !                        Y_VAL(2,I)/2 * H**2  +  Y_VAL(1,I) * H
    !
    !                          WITH  H = X - X_ARRAY(K)
    !
    !  This is a modification of the FUNCTION PPVALU in the book
    !  "A PRACTICAL GUIDE TO SPLINES"  by C. DE BOOR

    !*********************************************************************

    IMPLICIT NONE
    INTEGER I,I1,I2,MFLAG,NVAL
    REAL H,H1,H2,X1,X2,X_ARRAY(NVAL), Y_VAL(4,NVAL)

    !  Find the indices I1 and I2 of largest breakpoints to the left of X1
    !  and X2 respectively.
    !
    CALL INTERV ( X_ARRAY, NVAL-1, X1, I1, MFLAG )
    CALL INTERV ( X_ARRAY, NVAL-1, X2, I2, MFLAG )
    H1 = X1 - X_ARRAY(I1)
    IF (MFLAG == -1) H1 = 0.

    H2 = X2 - X_ARRAY(I2)
    CUBINT = (((Y_VAL(4,I2)*H2/4.0 + Y_VAL(3,I2) )*H2/3.0 + &
         Y_VAL(2,I2) )*H2/2.0 + Y_VAL(1,I2) )*H2 &
         - (((Y_VAL(4,I1)*H1/4.0 + Y_VAL(3,I1) )*H1/3.0 + &
         Y_VAL(2,I1) )*H1/2.0 + Y_VAL(1,I1) )*H1

    !  Include integrals over intervening intervals.

    IF (I2 > I1) THEN
       DO I = I1, I2-1
          H = X_ARRAY(I+1) - X_ARRAY(I)
          CUBINT = CUBINT + (((Y_VAL(4,I)*H/4.0 + Y_VAL(3,I) )*H/3.0 + &
               Y_VAL(2,I) )*H/2.0 + Y_VAL(1,I) )*H
       END DO
    END IF

  END FUNCTION CUBINT

  SUBROUTINE CUBSPL (XVAL, F, N)
    ! ------------------------------

    !***  Called by FOLD_AND_CONVOLVE, READ_SYSTEM_AND_LAYER_DATA, TXCNVD

    !  Calculates coefficients for cubic spline interpolation.
    !  CALL FUNCTION CUBVAL to evaluate FUNCTION values after interpolation.
    !  Adapted from "A Practical Guide to Splines"  by Carl de Boor.

    !             INPUT
    !             -----
    !
    !     N = number of data points. assumed to be at least 4
    !
    !  (XVAL(I), F(1,I), I=1,...,N) = abscissae and ordinates of the data points.
    !                                 XVAL is assumed to be strictly increasing.
    !
    !          OUTPUT
    !          ------
    !
    !     F(J,I), J=1,...,4; I=1,. N-1 = the polynomial coefficients
    !         of the cubic interpolating spline with interior knots (or joints)
    !         XVAL(2), ..., XVAL(N-1).
    !
    !        In the interval: (XVAL(I) - XVAL(I+1)), the spline F is given by:
    !
    !        F(X) = F(1,I) + H* (F(2,I) + H* (F(3,I) + H* F(4,I)/3.) /2.)
    !
    !     where H = X - XVAL(I).  FUNCTION CUBVAL of it s variations may be
    !     used to evaluate F or its derivatives from XVAL,C, L = N-1, & K=4.
    !------------------------------------------------------------------------

    IMPLICIT NONE
    INTEGER N,I,J,M
    REAL F(4,N),XVAL(N),DIVDF1,DIVDF3,DXVAL,G

    !  A tridiagonal linear system for the unknown slopes S(I) of F at
    !  XVAL(I), I=1,...,N, is generated and then solved by Gauss elimination,
    !  with S(I) ending up in F(2,I), ALL I.
    !  F(3,.) AND F(4,.) are used initially for temporary storage.

    !  Compute first differences of XVAL sequence and store in F(3,.).
    !  Also, compute first divided difference of data and store in F(4,.).

    DO M = 2,N
       F(3,M) = XVAL(M) - XVAL(M-1)
       F(4,M) = (F(1,M) - F(1,M-1)) /F(3,M)
    END DO

    !  Not-a-knot condition at left

    F(4,1) = F(3,3)
    F(3,1) = F(3,2) + F(3,3)
    F(2,1) = ((F(3,2) + 2.* F(3,1)) * F(4,2)*F(3,3) + F(3,2)**2 * F(4,3)) /F(3,1)

    !  Generate the corresponding equations and
    !  perform the forward pass of Gauss elimination, after which the M-TH
    !  equation reads    F(4,M)*S(M) + F(3,M)*S(M+1) = F(2,M).

    DO M = 2, N-1
       G = -F(3,M+1) / F(4,M-1)
       F(2,M) = G*F(2,M-1) + 3.* (F(3,M)*F(4,M+1) + F(3,M+1)*F(4,M))
       F(4,M) = G* F(3,M-1) + 2.* (F(3,M) + F(3,M+1))
    END DO

    G = F(3,N-1) + F(3,N)
    F(2,N) = ((F(3,N) + 2.*G) *F(4,N)*F(3,N-1) + F(3,N)**2 *(F(1,N-1) - F(1,N-2)) /F(3,N-1))/G
    G = -G / F(4,N-1)
    F(4,N) = F(3,N-1)


    F(4,N) = G*F(3,N-1) + F(4,N)
    F(2,N) = (G*F(2,N-1) + F(2,N)) /F(4,N)

    !  Perform back substitution.

    DO J = N-1, 1, -1
       F(2,J) = (F(2,J) - F(3,J) *F(2,J+1)) /F(4,J)
    END DO

    !  Generate cubic coefficients in each interval, i.e., the derivatives at its
    !  left endpoint, from value and slope at its endpoints.

    DO I = 2,N
       DXVAL = F(3,I)
       DIVDF1 = (F(1,I) - F(1,I-1)) /DXVAL
       DIVDF3 = F(2,I - 1) + F(2,I) - 2.*DIVDF1
       F(3,I-1) = 2.* (DIVDF1 - F(2,I-1) - DIVDF3) /DXVAL
       F(4,I-1) = (DIVDF3/DXVAL) * (6./DXVAL)
    END DO
  END SUBROUTINE CUBSPL

  REAL FUNCTION CUBVAL (X_ARRAY, Y_VAL, NXVAL, X1)
    !------------------------------------------------

    !  Evaluates a FUNCTION at X1 from from its cubic spline representation.

    !***  Called by COSTRN, FOLD_AND_CONVOLVE, TXCNVD, TXCNVL
    !***  Calls INTERV.  On exit from INTERV
    !
    !       MFLAG = -1  : X is to the left of interpolated range
    !             =  1  : X is to the right of interpolated range
    !             =  0  : X is in the interpolated range

    !      NXVAL - total number of knots including endpoints.
    !
    !     X_ARRAY(I), I = 1,NXVAL - location of the knots.  The rightmost data
    !                            point used to calculate coefficients is not
    !                            included.
    !
    !     Y_VAL(J,I), J = 1,4; I = 1,NXVAL
    !
    ! The coefficients of the cubic spline on the I'th interval represent F as:
    !
    !                F(X) = Y_VAL(4,I)/6 * H**3  +  Y_VAL(3,I)/2 * H**2  +
    !                       Y_VAL(2,I) * H  +  Y_VAL(1,I)
    !
    !                          with  H = X - X_ARRAY(I)
    !
    !  This is a modification of the FUNCTION PPVALU in the book
    !  "A PRACTICAL GUIDE TO SPLINES"  by C. DE Boor
    !
    !             METHOD
    !             ------
    !
    !  The interval index I, appropriate for X, is found through a CALL to INTERV.
    !  The formula for F is evaluated using nested multiplication.
    !******************************************************************************

    IMPLICIT NONE
    INTEGER I,MFLAG,NXVAL
    REAL X_ARRAY(NXVAL),Y_VAL(4,NXVAL),X1,H

    INTENT (IN) X_ARRAY, Y_VAL, NXVAL, X1

    !  Find index I of largest breakpoint to the left of X1.

    CALL INTERV ( X_ARRAY, NXVAL-1, X1, I, MFLAG )
    H = X1 - X_ARRAY(I)
    IF (MFLAG == -1) H = 0.
    CUBVAL = ((Y_VAL(4,I)*H/3.0 + Y_VAL(3,I) )*0.5*H + Y_VAL(2,I) )*H + Y_VAL(1,I)

  END FUNCTION CUBVAL

  COMPLEX FUNCTION C2DINTRP (XV,NX,ZV,NZ,FR,FI,X1,Z1)
    !---------------------------------------------------

    !  2 dimensional interpolation of a complex FUNCTION (FR,FI) on point (X1,Z1)
    !  For each value of Z in ZV, a cubic spline repesents the FUNCTION s in the X direction.
    !  The cubic splines are evaluated at X1 for 4 different Z values, above and below Z1
    !  A four point non-uniform Lagrange interpolation is used inhe Z direction.
    !
    !***  Called by
    !***  Calls INTERV, INTERV_Z
    !
    !  XV(NX) - increasing array of X values
    !  ZV(NZ) - increasing array of Z values
    !  FR(1:4,KX,KZ) - real FUNCTION values at XV(KX), ZV(KZ)
    !  FI(1:4,KX,KZ) - imaginary FUNCTION values at XV(KX), ZV(KZ)

    IMPLICIT NONE
    INTEGER KX,KZ,MFL,NFL,NX,NZ,J1,JZ
    REAL X1,Z1,XV(NX),ZV(NZ),FR(4,NX,NZ),FI(4,NX,NZ),H,HZ,D1,D4,P,P2,VR,VI
    REAL,DIMENSION(4) :: CR,CI,A

    !  Find index KX of largest breakpoint to the left of X1.

    CALL INTERV (XV, NX-1, X1, KX, MFL)
    IF (MFL == -1) H = 0.
    H = X1 - XV(KX)

    !  Find index KZ of largest ZV above Z1.

    CALL INTERV_Z (ZV, NZ-1, Z1, KZ, NFL)
    HZ = ZV(KZ+1) - ZV(KZ)
    D1 = (ZV(KZ) - ZV(KZ-1)) / HZ
    D4 = (ZV(KZ+2) - ZV(KZ)) / HZ
    P = (Z1 - ZV(KZ)) / HZ
    P2 = P*P

    A(1) = (P2-P) * (D4-P) / (D1 * (1.+D1) * (D1+D4))
    A(2) = (D1+P) * (1.-P) * (D4-P) / (D1 *D4)
    A(3) = (D1*P+P2) * (D4-P) / ((1.+D1) * (D4-1.))
    A(4) = (D1+P) * (P2-P) / (D4 * (D1+D4) * (D4-1.))

    DO J1 = 1,4
       JZ = KZ - 2 + J1
       CR(J1) = ((FR(4,KX,JZ)*H/3.0 + FR(3,KX,JZ) )*0.5*H + FR(2,KX,JZ) )*H + FR(1,KX,JZ)
       CI(J1) = ((FI(4,KX,JZ)*H/3.0 + FI(3,KX,JZ) )*0.5*H + FI(2,KX,JZ) )*H + FI(1,KX,JZ)
    END DO
    VR = DOT_PRODUCT (A,CR)
    VI = DOT_PRODUCT (A,CI)

    C2DINTRP = CMPLX (VR,VI)

  END FUNCTION C2DINTRP

  SUBROUTINE CUBVALRZ (X_ARRAY, NRVAL, NZVAL, FUN_R, FUN_I, X1, JZ, C2)
    !-------------------------------------------------------------------

    !  Uses method of CUBSPL to create complex C2 at X1 from two
    !  real splined FUNCTION s of depth index JZ.

    !***  Called by
    !***  Calls INTERV.  On exit from INTERV
    !
    !******************************************************************************

    IMPLICIT NONE
    INTEGER I,MFLAG,NRVAL,NZVAL,JZ
    REAL X_ARRAY(NRVAL),FUN_R(4,NRVAL,NZVAL),FUN_I(4,NRVAL,NZVAL),X1R
    REAL X1,H,CR,CI,A(4),B(4)
    COMPLEX C2

    !  Find index I of largest breakpoint to the left of X1.

    X1R = REAL (X1)
    CALL INTERV ( X_ARRAY, NRVAL-1, X1R, I, MFLAG )
    H = X1 - X_ARRAY(I)
    IF (MFLAG == -1) H = 0.
    A(1:4) = FUN_R(1:4,I,JZ)
    B(1:4) = FUN_I(1:4,I,JZ)
    CR = ((A(4)*H/3. + A(3))*0.5*H + A(2))*H + A(1)
    CI = ((B(4)*H/3. + B(3))*0.5*H + B(2))*H + B(1)
    C2 = CMPLX (CR,CI)

  END SUBROUTINE CUBVALRZ

  SUBROUTINE CCUBVAL(X_ARRAY, NVAL, FUN_R, FUN_I, X1, C2)
    !-----------------------------------------------------------

    !  Uses method of CUBSPL to create complex CD2 at X1 from two
    !  real splined FUNCTION s

    !***  Called by
    !***  Calls INTERV.  On exit from INTERV
    !
    !******************************************************************************

    IMPLICIT NONE
    INTEGER I,MFLAG,NVAL
    REAL X_ARRAY(NVAL),FUN_R(4,NVAL),FUN_I(4,NVAL),X1R
    REAL X1,H,CR,CI,A(4),B(4)
    COMPLEX C2

    !  Find index I of largest breakpoint to the left of X1.

    X1R = REAL (X1)
    CALL INTERV ( X_ARRAY, NVAL-1, X1R, I, MFLAG )
    H = X1 - X_ARRAY(I)
    IF (MFLAG == -1) H = 0.
    A(1:4) = FUN_R(1:4,I)
    B(1:4) = FUN_I(1:4,I)
    CR = ((A(4)*H/3. + A(3))*0.5*H + A(2))*H + A(1)
    CI = ((B(4)*H/3. + B(3))*0.5*H + B(2))*H + B(1)
    C2 = CMPLX (CR,CI)

  END SUBROUTINE CCUBVAL


  REAL FUNCTION DIST2D (X1,Y1,X2,Y2)
    !----------------------------------

    ! Computes distance RHO between points (X1, Y1) & (X2, Y2)

    REAL X1,Y1,X2,Y2

    DIST2D = SQRT ((X1-X2)**2 + (Y1-Y2)**2)

  END FUNCTION DIST2D


  SUBROUTINE INTERV (XT, LXT, X, LEFT, MFLAG)
    !-------------------------------------------

    !***   Called by CUBVAL, CUBINT
    !       INPUT: XT, LXT, X
    !      OUTPUT: LEFT, MFLAG
    !
    !  XT is an ascending sequence of length LXT.
    !  INTERV finds the interval in XT containing the input variable X.
    !
    !  If XT(1)  <=  X  <=  XT(LXT) then MFLAG = 0 and
    !
    !  XT (LEFT)  <=  X  <=  XT (LEFT+1)
    !
    !  --------------------------------------------
    !  If  X <  XT(1) then MFLAG = - 1 & LEFT = 1
    !  If  X >  XT(lxt) then MFLAG = 1 & LEFT = LXT
    !  --------------------------------------------
    !
    !  from  * A PRACTICAL GUIDE TO SPLINES *  by C. DE BOOR
    !
    !             METHOD
    !             ------
    !
    !  The program is designed to be efficient in the common situation that
    !  it is called repeatedly, with  X  taken from an increasing or decreasing
    !  sequence. This will happen, e.g., when a pp FUNCTION is to be grapged.
    !  The first guess for  LEFT  is therefore taken to be the value returned at
    !  the previous CALL and stored in the  L O C A L  variable ILO. A first
    !  check ascertains that  ILO < LXT (This is necessary since the present
    !  CALL may have nothing to do with the previous call).
    !  Then, if XT(ILO) <= XT(ILO+1),
    !  we set  LEFT = ILO  and are done after just three comparisons.
    !  Otherwise, we repeatedly double the difference  ISTEP = IHI - ILO
    !  while also moving  ILO  AND  IHI  in the direction of  X , until
    !                      XT(ILO) <= X < XT(IHI) ,
    !  after which we use bisection to get, in addition, ILO+1 = IHI .
    !  LEFT = ILO  is then returned.
    !******************************************************************************
    !******************************************************************************

    IMPLICIT NONE
    INTEGER LEFT,LXT,MFLAG,IHI,ILO,ISTEP,MIDDLE,J1
    REAL X,XT(LXT)
    SAVE ILO

    DATA ILO /1/

    !***********************************************************
    !  Trivial returns when X is not in the range.

    IF ( (X <= XT(1)) .OR. (LXT <= 1) ) THEN
       MFLAG = -1
       LEFT = 1
       RETURN
    END IF

    IF (X >= XT(LXT)) THEN
       MFLAG = 1
       LEFT = LXT
       RETURN
    END IF

    MFLAG = 0
    IF (ILO >= LXT) ILO = LXT-1
    IHI = ILO + 1

    !  Trivial return when X is already in the interval.

    IF ( (X <= XT(IHI)) .AND. (X >= XT(ILO)) ) THEN
       LEFT = ILO
       RETURN
    END IF
    !***********************************************************

    IF (X <= XT(ILO)) THEN  ! decrease ILO  to capture X.
       ISTEP = 1
       DO J1 = 1,LXT
          IHI = ILO
          ILO = IHI - ISTEP
          ILO = MAX(1, ILO)
          IF ( (X >= XT(ILO)) .OR. (ILO == 1) ) EXIT
          ISTEP = ISTEP*2
       END DO

    ELSE IF ( X >= XT(IHI)) THEN  ! increase IHI to capture X

       ISTEP = 1
       DO J1 = 1,LXT
          ILO = IHI
          IHI = ILO + ISTEP
          IHI = MIN (IHI,LXT)
          IF ( (X <= XT(IHI)) .OR. (IHI == LXT) ) EXIT
          ISTEP = ISTEP*2
       END DO

    END IF

    !  Now XT(ILO) <= X < XT(IHI) . Narrow the interval.

    DO J1 = 1,LXT
       MIDDLE = (ILO + IHI)/2
       IF (MIDDLE == ILO) EXIT
       IF (X < XT(MIDDLE)) THEN
          IHI = MIDDLE
       ELSE
          ILO = MIDDLE
       END IF
    END DO

    ! Task complete

    LEFT = ILO
    RETURN

  END SUBROUTINE INTERV

  SUBROUTINE INTERV_Z (XT, LXT, X, LEFT, MFLAG)
    !---------------------------------------------

    !  Copy of INTERV to allow efficient searches in two directions.

    !***   Called by
    !       INPUT: XT, LXT, X
    !      OUTPUT: LEFT, MFLAG
    !
    !  XT is an ascending sequence of length LXT.
    !  INTERV finds the interval in XT containing the input variable X.
    !
    !  If XT(1)  <=  X  <=  XT(LXT) then MFLAG = 0 and
    !
    !  XT (LEFT)  <=  X  <=  XT (LEFT+1)
    !
    !  --------------------------------------------
    !  If  X <  XT(1) then MFLAG = - 1 & LEFT = 1
    !  If  X >  XT(lxt) then MFLAG = 1 & LEFT = LXT
    !  --------------------------------------------
    !
    !  from  * A PRACTICAL GUIDE TO SPLINES *  by C. DE BOOR
    !
    !             METHOD
    !             ------
    !
    !  The program is designed to be efficient in the common situation that
    !  it is called repeatedly, with  X  taken from an increasing or decreasing
    !  sequence. This will happen, e.g., when a pp FUNCTION is to be grapged.
    !  The first guess for  LEFT  is therefore taken to be the value returned at
    !  the previous CALL and stored in the  L O C A L  variable ILO. A first
    !  check ascertains that  ILO < LXT (This is necessary since the present
    !  CALL may have nothing to do with the previous call).
    !  Then, if XT(ILO) <= XT(ILO+1),
    !  we set  LEFT = ILO  and are done after just three comparisons.
    !  Otherwise, we repeatedly double the difference  ISTEP = IHI - ILO
    !  while also moving  ILO  AND  IHI  in the direction of  X , until
    !                      XT(ILO) <= X < XT(IHI) ,
    !  after which we use bisection to get, in addition, ILO+1 = IHI .
    !  LEFT = ILO  is then returned.
    !******************************************************************************
    !******************************************************************************

    IMPLICIT NONE
    INTEGER LEFT,LXT,MFLAG,IHI,ILO,ISTEP,MIDDLE,J1
    REAL X,XT(LXT)
    SAVE ILO

    DATA ILO /1/

    !***********************************************************
    !  Trivial returns when X is not in the range.

    IF ( (X <= XT(1)) .OR. (LXT <= 1) ) THEN
       MFLAG = -1
       LEFT = 1
       RETURN
    END IF

    IF (X >= XT(LXT)) THEN
       MFLAG = 1
       LEFT = LXT
       RETURN
    END IF

    MFLAG = 0
    IF (ILO >= LXT) ILO = LXT-1
    IHI = ILO + 1

    !  Trivial return when X is already in the interval.

    IF ( (X <= XT(IHI)) .AND. (X >= XT(ILO)) ) THEN
       LEFT = ILO
       RETURN
    END IF
    !***********************************************************

    IF (X <= XT(ILO)) THEN  ! decrease ILO  to capture X.
       ISTEP = 1
       DO J1 = 1,LXT
          IHI = ILO
          ILO = IHI - ISTEP
          ILO = MAX(1, ILO)
          IF ( (X >= XT(ILO)) .OR. (ILO == 1) ) EXIT
          ISTEP = ISTEP*2
       END DO

    ELSE IF ( X >= XT(IHI)) THEN  ! increase IHI to capture X

       ISTEP = 1
       DO J1 = 1,LXT
          ILO = IHI
          IHI = ILO + ISTEP
          IHI = MIN (IHI,LXT)
          IF ( (X <= XT(IHI)) .OR. (IHI == LXT) ) EXIT
          ISTEP = ISTEP*2
       END DO

    END IF

    !  Now XT(ILO) <= X < XT(IHI) . Narrow the interval.

    DO J1 = 1,LXT
       MIDDLE = (ILO + IHI)/2
       IF (MIDDLE == ILO) EXIT
       IF (X < XT(MIDDLE)) THEN
          IHI = MIDDLE
       ELSE
          ILO = MIDDLE
       END IF
    END DO

    ! Task complete

    LEFT = ILO
    RETURN

  END SUBROUTINE INTERV_Z


  SUBROUTINE SET_Z (IACC,NPPD,ZMIN,ZMAX,SPAN,DEL0,NQS,QSTORE,NZ1)
    !---------------------------------------------------------------

    !  Sets up 4 point vertical interpolation array QSTORE(NZ1) between ZMIN and
    !  ZMAX such that two points precede ZMIN and that 2 points follow ZMAX.
    !  Intially it covers the interval SPAN with NPPD logarithmically points
    !  until the interval between points, DEL1, exceeds DELO.
    !  From then on a uniform interval of DEL1 is used.
    !  Numerical 4 point cubic interpolation experiments with Green's FUNCTION integrals
    !  suggested that SPAN = MIN (skin depth, 10.) and DEL0 = skin depth / 5
    !  If IACC > 1, then halve the intervals logarithmically.

    IMPLICIT NONE
    INTEGER NQS,NPPD,NZ1,JZ,NZ,IACC
    REAL QZ,ZMIN,ZMAX,SPAN,DEL0,DEL1,QSTORE(NQS)
    LOGICAL ADDPOINTS

    ADDPOINTS = .TRUE.
    QZ = LOG (SPAN) / REAL (NPPD)
    QZ = EXP (QZ)
    QSTORE(3) = ZMIN
    QSTORE(2) = ZMIN / QZ
    QSTORE(1) = QSTORE(2) / QZ

    DO JZ = 4,NQS
       NZ1=JZ
       QSTORE(JZ) = QSTORE(JZ-1) * QZ
       !---------------------------
       IF (QSTORE(JZ-1) > ZMAX) THEN
          ADDPOINTS = .FALSE.
          EXIT
       END IF
       !---------------------------

       DEL1 = QSTORE(JZ) - QSTORE(JZ-1)
       IF (DEL1 > DEL0) EXIT
    END DO

    IF (ADDPOINTS) THEN
       NZ = NZ1+1
       DO JZ = NZ, NQS
          NZ1 = JZ
          QSTORE(JZ) = QSTORE(JZ-1) + DEL1
          IF (QSTORE(JZ-1) > ZMAX) EXIT
       END DO
    END IF

    IF (IACC == 2) THEN   ! Halve intervals for improved interpolation accuracy
       NZ = NZ1
       NZ1 = 2*NZ1 - 1
       DO JZ = NZ,2,-1
          QSTORE (2*JZ-1) = QSTORE(JZ)
       END DO
       DO JZ = 2,NZ1-1,2
          QSTORE (JZ) = SQRT (QSTORE(JZ-1) * QSTORE(JZ+1))
       END DO
    END IF
  END SUBROUTINE SET_Z

  SUBROUTINE SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)
    !--------------------------------------------

    !  Determines the value of KFG needed for layer coefficient computation
    !  I1 = 1 for magnetic source or 2 for electric source.

    IMPLICIT NONE
    INTEGER I1,I2,I3,SXLYR,RXLYR,NLYR,KFG

    I2 = 1; I3 = 1
    IF (SXLYR == 0) I2 = 0
    IF (RXLYR == 0) I3 = 0
    IF (I2 == 1 .AND. I3 == 1) THEN
       IF (RXLYR > SXLYR) I3 = 2
       IF (RXLYR < SXLYR) I2 = 2
    END IF
    IF (SXLYR == NLYR) I2 = 3
    IF (RXLYR == NLYR) I3 = 3
    KFG = 100*I1 + 10*I2 + I3

  END SUBROUTINE SET_KFG

  REAL FUNCTION TXCNVD (MXCNV,T,NTYPLS,TRP,YPLS,NSX,SWX,SWY,K1)
    !-------------------------------------------------------------
    !
    !***  Called by FOLD_AND_CONVOLVE
    !***  Calls CUBINT, CUBSPL, CUBVAL, LINVAL, TXCMRG

    !  Convolves earth response FUNCTION (ERF) with the source waveform
    !  contained in SWY(*,K1) at NSX points to produce the system response
    !  of the earth.  In Leroi, it is used for electric field computations.
    !  The source current FUNCTION is contained in component K1 = 3
    !
    !       MXCNV = NTYPLS + NSX
    !           T - convolution time in sec measured from the beginning
    !               of the source waveform.
    !   TRP, YPLS - abscissa & ordinate values of earth response FUNCTION to
    !               be convolved.
    !      NTYPLS - number of values in TRP and YPLS
    !         SWX - abscissa of time values of source waveform in sec.
    !    SWY(*,K1) - source current values
    !         NSX - number of points in SWX & in each waveform stored in SWY
    !
    !  Defining  T1 = MIN {T, signal length,}, the convolution is formally
    !  computed as
    !
    !   TXCNVD (T) = INT (T0 -> T) { YPLS (tau) * SWY (T-tau)  d tau }

    !  where T0 = MAX { TRP(1), T - SWX (NSX)}
    !
    !       ONTIME RESPONSE
    !       ---------------
    !  For response in the on-time period, ( T < signal length) a correction to
    !  account for the response from 0 -> T0 is needed.  Analysis and subsequent
    !  numerical experiments confirm that as T -> 0, step dB/dt -> A * T**(-1/2).
    !  Thus ERFINT, the integral of YPLS from 0 to TRP(1), is simply
    !  2 * TRP(1) * YPLS (TRP(1)) if TRP(1) is chosen sufficiently early.
    !  The convolution correction factor is SWY(T) * ERFINT.

    !  Alternatively, we can difference the step B field from 0 to TRP(1) which
    !  is a lot easier since the step B field at T = 0 is simply the DC field due
    !  to a transmitter image buried at z = ALT; i.e., the z+z' term.  In this case,
    !  the bigger TRP(1) is, the more accurate the difference in B but this must be
    !  sufficiently small so that the change in dI/dt is negligable.  Thus, TRP(1)
    !  is chosen to be .1 microsecond.

    IMPLICIT NONE
    INTEGER K1,MXCNV,NTYPLS,NSX,N1,J1,N2,J2,NCNV
    REAL T,TC,T0,TRP(NTYPLS),YPLS(4,NTYPLS),SWX(NSX),SWY(NSX,3),YCNV(4,MXCNV), &
         XCNV(MXCNV),X1(MXCNV),Y1(MXCNV),X2(MXCNV),Y2(MXCNV)

    INTENT (IN) MXCNV,T,NTYPLS,TRP,YPLS,NSX,SWX,SWY

    !  Set up X1,Y1, the N1 values of SWX, SWY * YPLS for signal ontime < T.
    !  where X1, the conjugate signal time, contains T-SWX values.
    !  Set up X2,Y2, the N2 values of TRP, YPLS * SWY for ERF points  <= T.

    TXCNVD = 0.0
    N1 = 0
    DO J1 = NSX, 1, -1
       TC = T - SWX(J1)
       IF (TC < 0.) CYCLE
       N1 = N1 + 1
       X1(N1) = TC
       Y1(N1) = SWY(J1,K1) * CUBVAL (TRP,YPLS,NTYPLS,TC)
    END DO

    T0 = T - SWX(NSX)
    T0 = MAX (T0, TRP(1))/ 1.0001
    N2 = 0
    DO J2 = 1,NTYPLS
       IF ((TRP(J2) > T0) .AND. (TRP(J2) < T)) THEN
          N2 = N2 + 1
          X2(N2) = TRP(J2)
          TC = T - TRP(J2)
          Y2(N2) = YPLS(1,J2) * LINVAL(NSX,SWX,SWY,K1,TC)
       END IF
    END DO

    !  Merge the two lists into XCNV, YCNV of length NCNV.
    !  Then spline and integrate

    !+++++++++++++++++++++++++++++++++
    IF (N1 + N2 < 4) RETURN
    !+++++++++++++++++++++++++++++++++

    CALL TXCMRG (MXCNV,X1,Y1,N1,X2,Y2,N2,XCNV,YCNV,NCNV)

    !+++++++++++++++++++++++++++++++++
    IF (NCNV < 4) RETURN
    !+++++++++++++++++++++++++++++++++

    CALL CUBSPL (XCNV,YCNV,NCNV)
    TXCNVD = CUBINT (XCNV,YCNV,NCNV,T0,T)

  END FUNCTION TXCNVD

  REAL FUNCTION TXCNVL (T,NTYPLS,TRP,YPLS,NSX,SWX,SWY)
    !----------------------------------------------------

    !***  Called by FOLD_AND_CONVOLVE
    !***  Calls CUBINT, CUBVAL

    !  Computes the system dB/dt response by convolving the computed dI/dt with
    !  the impulse B response of the earth.  For step current drops, system dB/dt
    !  is computed asthe product of instantaneous current drop times the
    !  earth step dB/dt.

    !  This routine assumes that the source waveform is composed of NSX linear
    !  segments.  Thus NSX-1 constant dI/dt values are contained in SWY(*,1).

    !  The input earth response FUNCTION (step dB/dt or equivalently, impulse B)
    !  must be contained in a splined array of NTYPLS values of time (abscissa) TRP
    !  and ordinate YPLS.  System dB/dt is computed by integrating YPLS between
    !  the SWX points of constant dI/dt segments.

    !              T - convolution time in sec measured from the beginning
    !                  of the source waveform.
    !      TRP, YPLS - abscissa & ordinate values of earth response FUNCTION to
    !                  be convolved.
    !         NTYPLS - number of values in TRP and YPLS
    !            SWX - abscissa of time values of source waveform in sec.
    !       SWY(*,1) - dI/dt if it exists (0 otherwise)
    !       SWY(*,2) - first difference values of source waveform
    !                  (-delta I) in amps.
    !            NSX - number of points in SWX & 1

    IMPLICIT NONE
    REAL, PARAMETER :: T0_MIN=1.E-7
    INTEGER NTYPLS,NSX,JT
    REAL T,TF,CNV,TB,DELT,SEG,TRP(NTYPLS),YPLS(4,NTYPLS),SWX(NSX),SWY(NSX,3),TEND
    LOGICAL DER

    TF = T - TRP(1)
    CNV = 0.
    DO JT = 2, NSX
       IF (SWX(JT) < T0_MIN) CYCLE
       IF (SWX(JT-1) > TF) EXIT
       TB = T - MIN (TF, SWX(JT))
       DELT = SWX(JT) - SWX(JT-1)
       DER = .FALSE.
       IF (DELT > T0_MIN) THEN
          TEND = T - SWX(JT-1)
          DER = .TRUE.
       END IF

       !  For an instantaneous step drop in current, SEG is YPLS times SWY(*,2),
       !  since YPLS is already the dB/dt step response.  Otherwise SEG is the
       !  integral of YPLS * constant dI/dt SWY(*,1) since YPLS is also impulse B.

       IF (DER) THEN
          SEG = SWY(JT,1) * CUBINT (TRP,YPLS,NTYPLS,TB,TEND)
       ELSE
          SEG = SWY(JT,2) * CUBVAL (TRP,YPLS,NTYPLS,TB)
       END IF
       CNV = CNV + SEG
    END DO
    TXCNVL = CNV

  END FUNCTION TXCNVL

  REAL FUNCTION LINVAL (NX,XVAL,YVAL,K1,X1)
    !-----------------------------------------

    !  Evaluates a FUNCTION at X1 from from its linear representation.

    !***  Called by TXCNVD
    !
    !***  Calls INTERV.  On exit from INTERV
    !
    !       MFLAG = -1  => X is to the left of interpolated range
    !             =  1  => X is to the right of interpolated range
    !             =  0  => X is in the interpolated range

    !
    !     XVAL(1:NX) - location of the abscissa knots.  The rightmost data point
    !                  used to calculate coefficients is not included.
    !
    !  YVAL(1:NX,K1) = FUNCTION values.
    !
    !
    !     The value is a linear interpolation between the knots.
    !
    !             METHOD
    !             ------
    !
    !  The interval index I, appropriate for X, is found through a CALL to INTERV.
    !  The formula for F is evaluated using nested multiplication.
    !******************************************************************************

    IMPLICIT NONE
    INTEGER K1,I,MFLAG,NX
    REAL XVAL(NX),YVAL(NX,3),X1,H

    INTENT (IN) NX,XVAL,YVAL,X1
    !
    !  Find index I of largest breakpoint to the left of X1.
    !
    CALL INTERV ( XVAL, NX-1, X1, I, MFLAG )

    H = X1 - XVAL(I)
    IF (MFLAG == -1) H = 0.
    LINVAL = YVAL(I,K1) + H * (YVAL(I+1,K1) - YVAL(I,K1)) / (XVAL(I+1) - XVAL(I))

  END FUNCTION LINVAL


  SUBROUTINE TXCMRG (MXCNV,X1,Y1,N1,X2,Y2,N2,XCNV,YCNV,NCNV)
    !----------------------------------------------------------

    !  Merges two previously sorted list pairs X1, Y1 of length N1 and X2, Y2 of
    !  length N2 into list pair XCNV, YCNV of length NCNV into ascending values of
    !  XCNV.

    !***  Called by TXCNVD

    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-3
    INTEGER MXCNV,N1,N2,NCNV,K1,K2,N,J1
    REAL DELT,TL1,XCNV(MXCNV),X1(MXCNV),Y1(MXCNV),X2(MXCNV),Y2(MXCNV),YCNV(4,MXCNV)
    LOGICAL LIST1, LIST2

    INTENT (IN) MXCNV,X1,Y1,N1,X2,Y2,N2
    INTENT (OUT) XCNV,YCNV,NCNV

    LIST1 = .TRUE.
    LIST2 = .TRUE.
    K1 = 1
    K2 = 1
    N = N1 + N2

    DO J1 = 1, N
       IF (LIST1 .AND. LIST2) THEN
          IF (X1(K1) < X2(K2)) THEN
             XCNV(J1) = X1(K1)
             YCNV(1,J1) = Y1(K1)
             K1 = K1 + 1
             IF (K1 > N1) LIST1 = .FALSE.
          ELSE
             XCNV(J1) = X2(K2)
             YCNV(1,J1) = Y2(K2)
             K2 = K2 + 1
             IF (K2 > N2) LIST2 = .FALSE.
          END IF
       ELSE IF (LIST1) THEN
          XCNV(J1) = X1(K1)
          YCNV(1,J1) = Y1(K1)
          K1 = K1 + 1
          IF (K1 > N1) LIST1 = .FALSE.
       ELSE IF (LIST2) THEN
          XCNV(J1) = X2(K2)
          YCNV(1,J1) = Y2(K2)
          K2 = K2 + 1
          IF (K2 > N2) LIST2 = .FALSE.
       END IF
    END DO

    NCNV = 1      !  Clean up list
    DO J1 = 2, N
       DELT = XCNV(J1) - XCNV(NCNV)
       TL1 = TOL * XCNV(J1)
       IF (DELT > TL1) THEN
          NCNV = NCNV + 1
          XCNV(NCNV) = XCNV(J1)
          YCNV(1,NCNV) = YCNV(1,J1)
       END IF
    END DO

  END SUBROUTINE TXCMRG

  !==========================================================================================
  !*****************************************
  !
  !       LAYERED HALFSPACE ROUTINES
  !       --------------------------
  !*****************************************




  SUBROUTINE EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
       ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)
    !---------------------------------------------------------------------------

    !***  Called by
    !***  Calls PROPAGATE

    !  For an arbitrarily oriented electric dipole source at ZS in layer SXLYR of a
    !  halfspace with NLYR-1 layers above basement, EDSX_COEF computes the coefficients
    !  for the vertical and horizontal F (electric) and G (magnetic) potentials
    !  These coefficients can be used to compute magnetic and electric fields.
    !
    !          Input
    !          -----
    !  KFG indicates source type and layer locations of source and receiver: air, basement or intermediate
    !
    !  KFG = IJK : I = type; J = Tx layer; K = Rx layer
    !
    !        I = 2 => electric dipole source
    !
    !        J = 0 => Transmitter in air
    !        J = 3 => Transmitter in basement
    !
    !        K = 0 => Receiver in air
    !        K = 3 => Receiver in basement
    !
    !        When BOTH tranamitter nor receiver are in an intermediate layer:
    !
    !        JK = 11 => Transmitter and recever are in the same layer
    !        JK = 12 => Transmitter layer is above receiver layer
    !        JK = 21 => Transmitter layer is below receiver layer
    !
    !   RXLYR - layer containing receiver
    !   SXLYR - layer containing transmitter
    !   LMBDA - Hankel transform variable
    !    NLYR - number of layers
    !    THKD - thickness of layer J
    !   DPTHL - depth to TOP of layer J
    !    RMUD - mu(i) / mu(0)
    !    SIGL - complex conductivity including Cole-Cole + dimagnetic terms
    !    KSQL - iwu * SIGL
    !      ZS - depth of dipole transmitter (negative above earth)
    !
    !          Output
    !          ------
    !             S - Layer property variable in Hankel space
    !   XI_V, ETA_V - coefficients for the vertical magnetic Schelkunoff potentials.
    !
    !   F_V,  G_V   - coefficients for the vertical electric Schelkunoff potentials.
    !   F_H,  G_H   - coefficients for the horizontal electric Schelkunoff potential
    !
    !  P (F_V, F_H, XI_V)  are all used in the generic form:  P * EXP (S(RXLYR) * (ZR - DPTHL(RXLYR+1)))
    !  Q (G_V, G_H, ETA_V) are all used in the generic form:  Q * EXP (S(RXLYR) * (DPTHL(RXLYR) - ZR))
    !                               where ZR = receiver depth relative to surface

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX(KIND=QL), PARAMETER :: ONE=(1._QL,0._QL),ZERO=(0._QL,0._QL)
    INTEGER NLYR,KFG,RXLYR,SXLYR,J
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,ZS
    REAL(KIND=QL), DIMENSION (NLYR) ::  THKD,DPTHL,RMUSQ
    COMPLEX(KIND=QL) SM,SL,VLG,VMG,AMG,VLF,VMF,AMF,XPA,XP1,XP2,XQ1,XQ2,DENOMF,DENOMG, &
         PRJG,PRJF,XI_V,F_V,F_H,ETA_V,G_V,G_H,XI_VBAR, &
         F_VBAR,F_HBAR,ETA_VBAR,G_VBAR,G_HBAR,LMBSQ,VACHI
    COMPLEX(KIND=QL), DIMENSION (0:NLYR) :: S,T,R,AF,AG,VF,VG,CHI
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL

    S = ZERO; T = ZERO; R = ZERO; AF = ZERO; AG = ZERO; VF = ZERO; VG = ZERO; CHI = ONE
    F_V = ZERO;  F_H = ZERO;  XI_V  = ZERO;
    G_V = ZERO;  G_H = ZERO;  ETA_V = ZERO;


    ! VF & VG are the downward propagators for the F & G potentials respectively.
    ! AF & AG are the upward propagators.
    ! T & R are the magnetic and magnetic reflection coefficients


    LMBSQ = CMPLX (LMBDA * LMBDA, 0._QL, KIND=QL)

    S(0) = CMPLX (LMBDA, 0._QL,KIND=QL)
    DO J = 1,NLYR
       S(J) = SQRT (KSQL(J) + LMBSQ)
       RMUSQ(J) = RMUD(J) * RMUD(J)
    END DO
    T(0) = ( (RMUSQ(1) - 1._QL) * LMBSQ - KSQL(1) ) / ( RMUD(1)*S(0) + S(1) )**2
    R(0) = ONE
    DO J = 1,NLYR-1
       T(J) = (RMUSQ(J+1) - RMUSQ(J)) * LMBSQ + (RMUSQ(J+1) * KSQL(J) - RMUSQ(J) * KSQL(J+1)) &
            / (RMUD(J+1) * S(J) + RMUD(J) * S(J+1))**2
       R(J) = (SIGL(J+1) * S(J) - SIGL(J) * S(J+1)) / (SIGL(J+1) * S(J) + SIGL(J) * S(J+1))
       CHI(J) = EXP (-2._QL * S(J) * THKD(J))
    END DO

    SM = S(SXLYR)
    SL = S(RXLYR)

    SELECT CASE (KFG)

    CASE (200)                                  ! ED Tx in Air - Rx in Air
       CALL PROPAGATE (0)
       XI_V = VMG * EXP (SM * ZS)

    CASE (201)                                  ! ED Tx in Air - Rx in Layer
       XPA = SM * ZS
       DO J = 1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG
       CALL PROPAGATE (0)
       DO J = 0, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
          PRJF = PRJF * (ONE + VF(J)) / (ONE + VF(J+1) * CHI(J+1))
       END DO
       ETA_V = PRJG
       G_V = PRJF
       G_H = -G_V
       XP1 = EXP (-SL * THKD(RXLYR))
       XI_V  = VLG * XP1 * ETA_V
       F_V  = VLF * XP1 * G_V
       F_H = -F_V

    CASE (203)                                  ! ED Tx in Air - Rx in Basement
       XPA = SM * ZS
       DO J = 1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG
       CALL PROPAGATE (0)
       DO J = 0, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
          PRJF = PRJF * (ONE + VF(J)) / (ONE + VF(J+1) * CHI(J+1))
       END DO
       ETA_V = PRJG
       G_V = PRJF
       G_H = -G_V

    CASE (210)                                   ! ED Tx in Layer - Rx in Air
       XP1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       XP2 = EXP (SM * (ZS - DPTHL(SXLYR+1) - THKD(SXLYR)))
       CALL PROPAGATE (1)
       XI_VBAR = (XP1 + VMG * XP2) / DENOMG

       XPA = ZERO
       DO J = RXLYR+1, SXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)

       DO J = RXLYR, SXLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
       END DO
       XI_V = PRJG * XI_VBAR

    CASE (230)                              ! ED Tx in basement - Rx in Air
       XPA = ZERO
       DO J = RXLYR+1, NLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)

       CALL PROPAGATE (2)
       DO J = RXLYR, SXLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
       END DO
       XI_V = PRJG * EXP (SM * (DPTHL(SXLYR) - ZS))

    CASE (211)                                  ! ED Tx in Rx Layer
       XP1 = EXP (SM * (DPTHL(SXLYR) - THKD(SXLYR) - ZS))
       XP2 = EXP (SM * (ZS - DPTHL(SXLYR+1)))
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       XQ2 = EXP (SM * (ZS - DPTHL(SXLYR+1) - THKD(SXLYR)))

       CALL PROPAGATE (1)
       F_V  = VMF * (AMF * XP1 + XP2) / DENOMF
       F_H  = VMF * (AMF * XP1 - XP2) / DENOMF
       XI_V = VMG * (AMG * XP1 + XP2) / DENOMG

       G_V   = AMF * (XQ1 + VMF * XQ2) / DENOMF
       G_H   = AMF * (XQ1 - VMF * XQ2) / DENOMF
       ETA_V = AMG * (XQ1 + VMG * XQ2) / DENOMG

    CASE (212)                                  ! ED Tx Layer above Rx Layer
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS - THKD(SXLYR)))
       XQ2 = EXP (SM * (ZS - DPTHL(SXLYR+1)))
       CALL PROPAGATE (1)
       G_VBAR   = (AMF * XQ1 + XQ2) / DENOMF
       G_HBAR   = (AMF * XQ1 - XQ2) / DENOMF
       ETA_VBAR = (AMG * XQ1 + XQ2) / DENOMG

       XPA = ZERO
       DO J = SXLYR+1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG
       DO J = SXLYR, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
          PRJF = PRJF * (ONE + VF(J)) / (ONE + VF(J+1) * CHI(J+1))
       END DO
       G_V   = PRJF * G_VBAR
       G_H   = PRJF * G_HBAR
       ETA_V = PRJG * ETA_VBAR
       XP1   = EXP (-SL * THKD(RXLYR))
       F_V   = VLF * XP1 * G_V
       F_H   = VLF * XP1 * G_H
       XI_V  = VLG * XP1 * ETA_V

    CASE (213)                                  ! ED Tx in Layer - Rx in Basement
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS - THKD(SXLYR)))
       XQ2 = EXP (SM * (ZS - DPTHL(SXLYR+1)))
       CALL PROPAGATE (1)
       ETA_VBAR = (AMG * XQ1 + XQ2) / DENOMG
       G_VBAR   = (AMF * XQ1 + XQ2) / DENOMF
       G_HBAR   = (AMF * XQ1 - XQ2) / DENOMF

       XPA = ZERO
       DO J = SXLYR+1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG
       DO J = SXLYR, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
          PRJF = PRJF * (ONE + VF(J)) / (ONE + VF(J+1) * CHI(J+1))
       END DO
       G_V   = PRJF * G_VBAR
       G_H   = PRJF * G_HBAR
       ETA_V = PRJG * ETA_VBAR

    CASE (221)                                  ! ED Tx Layer below Rx Layer
       XP1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       XP2 = EXP (SM * (ZS - DPTHL(SXLYR+1) - THKD(SXLYR)))
       CALL PROPAGATE (1)
       F_VBAR  = (XP1 + VMF * XP2) / DENOMF
       F_HBAR  = (XP1 - VMF * XP2) / DENOMF
       XI_VBAR = (XP1 + VMG * XP2) / DENOMG

       XPA = ZERO
       DO J = RXLYR+1, SXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG

       DO J = RXLYR, SXLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
          PRJF = PRJF * (ONE + AF(J+1)) / (ONE + AF(J) * CHI(J))
       END DO
       F_V  = PRJF * F_VBAR
       F_H  = PRJF * F_HBAR
       XI_V = PRJG * XI_VBAR

       XQ1 = EXP (-SL * THKD(RXLYR))
       G_V   = AF(RXLYR) * XQ1 * F_V
       G_H   = AF(RXLYR) * XQ1 * F_H
       ETA_V = AG(RXLYR) * XQ1 * XI_V

    CASE (231)                                  ! ED Tx in basement - Rx in Layer
       XPA = ZERO
       DO J = RXLYR+1, NLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG

       CALL PROPAGATE (2)
       DO J = RXLYR, NLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
          PRJF = PRJF * (ONE + AF(J+1)) / (ONE + AF(J) * CHI(J))
       END DO

       XP1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       F_V  = PRJF * XP1
       F_H  = F_V
       XI_V = PRJG * XP1

       XQ1 = EXP (-SL * THKD(RXLYR))
       G_V   = AF(RXLYR) * XQ1 * F_V
       G_H   = G_V
       ETA_V = AG(RXLYR) * XQ1 * XI_V

    CASE (233)                                 ! ED Tx in basement - Rx in Basement
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       CALL PROPAGATE (2)
       ETA_V = AMG * XQ1
       G_V   = AMF * XQ1
       G_H   = G_V
    END SELECT

  CONTAINS

    SUBROUTINE PROPAGATE (LSX)
      !  --------------------------

      INTEGER LSX

      SELECT CASE (LSX)
      CASE (0)                  !  SXLYR = 0 - Build downward source propagator only
         VG(NLYR-1) = T(NLYR-1)
         VF(NLYR-1) = R(NLYR-1)
         DO J = NLYR-2, 0, -1
            VACHI = VG(J+1) * CHI(J+1)
            VG(J) = (VACHI + T(J)) / (ONE + VACHI* T(J))
            VACHI = VF(J+1) * CHI(J+1)
            VF(J) = (VACHI + R(J)) / (ONE + VACHI* R(J))
         END DO
         VLG = VG(RXLYR)
         VMG = VG(0)
         VLF = VF(RXLYR)
         VMF = VF(0)

      CASE (2)                 ! SXLYR = NLYR - Build upward source propagator only
         AG(1) = -T(0)
         AF(1) = -ONE
         DO J = 2, NLYR
            VACHI = AG(J-1) * CHI(J-1)
            AG(J) = (VACHI - T(J-1)) / (ONE - VACHI* T(J-1))
            VACHI = AF(J-1) * CHI(J-1)
            AF(J) = (VACHI - R(J-1)) / (ONE - VACHI* R(J-1))
         END DO
         AMG = AG(NLYR)
         AMF = AF(NLYR)

      CASE (1)                     ! Build downward and upward source propagators
         VG(NLYR-1) = T(NLYR-1)
         VF(NLYR-1) = R(NLYR-1)
         DO J = NLYR-2, 0, -1
            VACHI = VG(J+1) * CHI(J+1)
            VG(J) = (VACHI + T(J)) / (ONE + VACHI* T(J))
            VACHI = VF(J+1) * CHI(J+1)
            VF(J) = (VACHI + R(J)) / (ONE + VACHI* R(J))
         END DO

         AG(1) = -T(0)
         AF(1) = -ONE
         DO J = 2, NLYR
            VACHI = AG(J-1) * CHI(J-1)
            AG(J) = (VACHI - T(J-1)) / (ONE - VACHI* T(J-1))
            VACHI = AF(J-1) * CHI(J-1)
            AF(J) = (VACHI - R(J-1)) / (ONE - VACHI* R(J-1))
         END DO
         VLG = VG(RXLYR)
         VLF = VF(RXLYR)
         VMG = VG(SXLYR)
         VMF = VF(SXLYR)
         AMG = AG(SXLYR)
         AMF = AF(SXLYR)
         DENOMG = ONE - VMG * AMG * CHI(SXLYR)
         DENOMF = ONE - VMF * AMF * CHI(SXLYR)

      END SELECT

    END SUBROUTINE PROPAGATE

  END SUBROUTINE EDSX_COEF

  SUBROUTINE MDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
       ZS,S,XI_V,XI_H,F_V,ETA_V,ETA_H,G_V)
    !---------------------------------------------------------------------------

    !***  Called by
    !***  Calls PROPAGATE

    !  For an arbitrarily oriented magnetic dipole source at ZS in layer SXLYR of a
    !  halfspace with NLYR-1 layers above basement, MDSX_COEF computes the coefficients
    !  for the vertical and horizontal F (electric) and G (magnetic) potentials
    !  These coefficients can be used to compute magnetic and electric fields.
    !
    !          Input
    !          -----
    !  KFG indicates source type and layer locations of source and receiver: air, basement or intermediate
    !
    !  KFG = IJK : I = type; J = Tx layer; K = Rx layer
    !
    !        I = 1 => magnetic dipole source
    !
    !        J = 0 => Transmitter in air
    !        J = 3 => Transmitter in basement
    !
    !        K = 0 => Receiver in air
    !        K = 3 => Receiver in basement
    !
    !        When BOTH tranamitter nor receiver are in an intermediate layer:
    !
    !        JK = 11 => Transmitter and recever are in the same layer
    !        JK = 12 => Transmitter layer is above receiver layer
    !        JK = 21 => Transmitter layer is below receiver layer
    !
    !   RXLYR - layer containing receiver
    !   SXLYR - layer containing transmitter
    !   LMBDA - Hankel transform variable
    !    NLYR - number of layers
    !    THKD - thickness of layer J
    !   DPTHL - depth to TOP of layer J
    !    RMUD - mu(i) / mu(0)
    !    SIGL - complex conductivity including Cole-Cole + dimagnetic terms
    !    KSQL - iwu * SIGL
    !      ZS - depth of dipole transmitter (negative above earth)
    !
    !          Output
    !          ------
    !             S - Layer property variable in Hankel space
    !   XI_V, ETA_V - coefficients for the vertical magnetic Schelkunoff potentials.
    !   XI_H, ETA_H - coefficients for the horizontal magnetic Schelkunoff potential
    !
    !   F_V,  G_V   - coefficients for the vertical electric Schelkunoff potentials.
    !
    !  P (F_V, XI_V,  XI_H)  are all used in the generic form:  P * EXP (S(RXLYR) * (ZR - DPTHL(RXLYR+1)))
    !  Q (G_V, ETA_V, ETA_H) are all used in the generic form:  Q * EXP (S(RXLYR) * (DPTHL(RXLYR) - ZR))
    !                               where ZR = receiver depth relative to surface

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX(KIND=QL), PARAMETER :: ONE=(1._QL,0._QL),ZERO=(0._QL,0._QL)
    INTEGER NLYR,KFG,RXLYR,SXLYR,J
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,ZS
    REAL(KIND=QL), DIMENSION (NLYR) ::  THKD,DPTHL,RMUSQ
    COMPLEX(KIND=QL) SM,SL,VLG,VMG,AMG,VLF,VMF,AMF,XPA,XP1,XP2,XQ1,XQ2,DENOMF,DENOMG, &
         PRJG,PRJF,XI_V,XI_H,F_V,ETA_V,ETA_H,G_V,XI_VBAR,XI_HBAR, &
         F_VBAR,ETA_VBAR,ETA_HBAR,G_VBAR,LMBSQ,VACHI
    COMPLEX(KIND=QL), DIMENSION (0:NLYR) :: S,T,R,AF,AG,VF,VG,CHI
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL

    S = ZERO; T = ZERO; R = ZERO; AF = ZERO; AG = ZERO; VF = ZERO; VG = ZERO; CHI = ONE
    F_V = ZERO;  XI_V  = ZERO;  XI_H  = ZERO
    G_V = ZERO;  ETA_V = ZERO;  ETA_H = ZERO


    ! VF & VG are the downward propagators for the F & G potentials respectively.
    ! AF & AG are the upward propagators.
    ! T & R are the magnetic and magnetic reflection coefficients


    LMBSQ = CMPLX (LMBDA * LMBDA, 0._QL, KIND=QL)
    S(0) = CMPLX (LMBDA, 0._QL,KIND=QL)
    DO J = 1,NLYR
       S(J) = SQRT (KSQL(J) + LMBSQ)
       RMUSQ(J) = RMUD(J) * RMUD(J)
    END DO
    T(0) = ( (RMUSQ(1) - 1._QL) * LMBSQ - KSQL(1) ) / ( RMUD(1)*S(0) + S(1) )**2
    R(0) = ONE
    DO J = 1,NLYR-1
       T(J) = (RMUSQ(J+1) - RMUSQ(J)) * LMBSQ + (RMUSQ(J+1) * KSQL(J) - RMUSQ(J) * KSQL(J+1)) &
            / (RMUD(J+1) * S(J) + RMUD(J) * S(J+1))**2
       R(J) = (SIGL(J+1) * S(J) - SIGL(J) * S(J+1)) / (SIGL(J+1) * S(J) + SIGL(J) * S(J+1))
       CHI(J) = EXP (-2._QL * S(J) * THKD(J))
    END DO

    SM = S(SXLYR)
    SL = S(RXLYR)

    SELECT CASE (KFG)
    CASE (100)                                  ! MD Tx in Air - Rx in Air
       CALL PROPAGATE (0)
       XI_V = VMG * EXP (SM * ZS)
       XI_H = -XI_V

    CASE (101)                                  ! MD Tx in air - Rx in Layer
       XPA = ZERO
       DO J = 1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       CALL PROPAGATE (0)
       DO J = 0, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
       END DO
       ETA_V = PRJG * EXP (SM * ZS)
       XI_V  = VLG * EXP (-SL * THKD(RXLYR)) * ETA_V
       XI_H  = -XI_V
       ETA_H = -ETA_V

    CASE (103)                                  ! MD Tx in Air - Rx in Basement
       XPA = ZERO
       DO J = 1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       CALL PROPAGATE (0)
       PRJG = EXP (XPA)
       DO J = 0, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
       END DO
       ETA_V = PRJG * EXP (SM * ZS)
       ETA_H = -ETA_V

    CASE (110)                                  ! MD Tx in Layer - Rx in Air
       XP1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       XP2 = EXP (SM * (ZS - DPTHL(SXLYR+1) - THKD(SXLYR)))
       CALL PROPAGATE (1)
       XI_VBAR = (XP1 + VMG * XP2) / DENOMG
       XI_HBAR = (XP1 - VMG * XP2) / DENOMG

       XPA = ZERO
       DO J = RXLYR+1, SXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)

       DO J = RXLYR, SXLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
       END DO
       XI_V = PRJG * XI_VBAR
       XI_H = PRJG * XI_HBAR

    CASE (130)                              ! MD Tx in basement - Rx in Air
       XPA = ZERO
       DO J = RXLYR+1, NLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)

       CALL PROPAGATE (2)
       DO J = RXLYR, SXLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
       END DO
       XI_V = PRJG * EXP (SM * (DPTHL(SXLYR) - ZS))
       XI_H = XI_V

    CASE (111)                                  ! MD Tx in Rx Layer
       XP1 = EXP (SM * (DPTHL(SXLYR) - THKD(SXLYR) - ZS))
       XP2 = EXP (SM * (ZS - DPTHL(SXLYR+1)))
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       XQ2 = EXP (SM * (ZS - DPTHL(SXLYR+1) - THKD(SXLYR)))

       CALL PROPAGATE (1)
       XI_V = VMG * (AMG * XP1 + XP2) / DENOMG
       XI_H = VMG * (AMG * XP1 - XP2) / DENOMG
       F_V  = VMF * (AMF * XP1 + XP2) / DENOMF

       ETA_V = AMG * (XQ1 + VMG * XQ2) / DENOMG
       ETA_H = AMG * (XQ1 - VMG * XQ2) / DENOMG
       G_V   = AMF * (XQ1 + VMF * XQ2) / DENOMF

    CASE (112)                                  ! MD Tx Layer above Rx Layer
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS - THKD(SXLYR)))
       XQ2 = EXP (SM * (ZS - DPTHL(SXLYR+1)))
       CALL PROPAGATE (1)
       ETA_VBAR = (AMG * XQ1 + XQ2) / DENOMG
       ETA_HBAR = (AMG * XQ1 - XQ2) / DENOMG
       G_VBAR   = (AMF * XQ1 + XQ2) / DENOMF

       XPA = ZERO
       DO J = SXLYR+1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG
       DO J = SXLYR, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
          PRJF = PRJF * (ONE + VF(J)) / (ONE + VF(J+1) * CHI(J+1))
       END DO
       ETA_V = PRJG * ETA_VBAR
       ETA_H = PRJG * ETA_HBAR
       G_V   = PRJF * G_VBAR
       XP1   = EXP (-SL * THKD(RXLYR))
       XI_V  = VLG * XP1 * ETA_V
       XI_H  = VLG * XP1 * ETA_H
       F_V   = VLF * XP1 * G_V

    CASE (113)                                  ! MD Tx in Layer - Rx in Basement
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS - THKD(SXLYR)))
       XQ2 = EXP (SM * (ZS - DPTHL(SXLYR+1)))
       CALL PROPAGATE (1)
       ETA_VBAR = (AMG * XQ1 + XQ2) / DENOMG
       ETA_HBAR = (AMG * XQ1 - XQ2) / DENOMG
       G_VBAR   = (AMF * XQ1 + XQ2) / DENOMF

       XPA = ZERO
       DO J = SXLYR+1, RXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG
       DO J = SXLYR, RXLYR-1
          PRJG = PRJG * (ONE + VG(J)) / (ONE + VG(J+1) * CHI(J+1))
          PRJF = PRJF * (ONE + VF(J)) / (ONE + VF(J+1) * CHI(J+1))
       END DO
       ETA_V = PRJG * ETA_VBAR
       ETA_H = PRJG * ETA_HBAR
       G_V   = PRJF * G_VBAR

    CASE (121)                                  ! MD Tx Layer below Rx Layer
       XP1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       XP2 = EXP (SM * (ZS - DPTHL(SXLYR+1) - THKD(SXLYR)))
       CALL PROPAGATE (1)
       XI_VBAR = (XP1 + VMG * XP2) / DENOMG
       XI_HBAR = (XP1 - VMG * XP2) / DENOMG
       F_VBAR  = (XP1 + VMF * XP2) / DENOMF

       XPA = ZERO
       DO J = RXLYR+1, SXLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG

       DO J = RXLYR, SXLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
          PRJF = PRJF * (ONE + AF(J+1)) / (ONE + AF(J) * CHI(J))
       END DO
       XI_V = PRJG * XI_VBAR
       XI_H = PRJG * XI_HBAR
       F_V  = PRJF * F_VBAR

       XQ1 = EXP (-SL * THKD(RXLYR))
       ETA_V = AG(RXLYR) * XQ1 * XI_V
       ETA_H = AG(RXLYR) * XQ1 * XI_H
       G_V   = AF(RXLYR) * XQ1 * F_V

    CASE (131)                                  ! MD Tx in basement - Rx in Layer
       XPA = ZERO
       DO J = RXLYR+1, NLYR-1
          XPA = XPA - S(J) * THKD(J)
       END DO
       PRJG = EXP (XPA)
       PRJF = PRJG

       CALL PROPAGATE (2)
       DO J = RXLYR, NLYR-1
          PRJG = PRJG * (ONE + AG(J+1)) / (ONE + AG(J) * CHI(J))
          PRJF = PRJF * (ONE + AF(J+1)) / (ONE + AF(J) * CHI(J))
       END DO
       XP1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       F_V  = PRJF * XP1
       XI_V = PRJG * XP1
       XI_H = XI_V

       XQ1 = EXP (-SL * THKD(RXLYR))
       G_V   = AF(RXLYR) * XQ1 * F_V
       ETA_V = AG(RXLYR) * XQ1 * XI_V
       ETA_H = ETA_V

    CASE (133)                              ! MD Tx in basement - Rx in Basement
       XQ1 = EXP (SM * (DPTHL(SXLYR) - ZS))
       CALL PROPAGATE (2)
       ETA_V = AMG * XQ1
       G_V   = AMF * XQ1
       ETA_H = ETA_V
    END SELECT

  CONTAINS

    SUBROUTINE PROPAGATE (LSX)
      !  --------------------------

      INTEGER LSX

      SELECT CASE (LSX)
      CASE (0)                  !  SXLYR = 0 - Build downward source propagator only
         VG(NLYR-1) = T(NLYR-1)
         VF(NLYR-1) = R(NLYR-1)
         DO J = NLYR-2, 0, -1
            VACHI = VG(J+1) * CHI(J+1)
            VG(J) = (VACHI + T(J)) / (ONE + VACHI* T(J))
            VACHI = VF(J+1) * CHI(J+1)
            VF(J) = (VACHI + R(J)) / (ONE + VACHI* R(J))
         END DO
         VLG = VG(RXLYR)
         VMG = VG(0)

      CASE (2)                 ! SXLYR = NLYR - Build upward source propagator only
         AG(1) = -T(0)
         AF(1) = -ONE
         DO J = 2, NLYR
            VACHI = AG(J-1) * CHI(J-1)
            AG(J) = (VACHI - T(J-1)) / (ONE - VACHI* T(J-1))
            VACHI = AF(J-1) * CHI(J-1)
            AF(J) = (VACHI - R(J-1)) / (ONE - VACHI* R(J-1))
         END DO
         AMG = AG(NLYR)
         AMF = AF(NLYR)

      CASE (1)                     ! Build downward and upward source propagators
         VG(NLYR-1) = T(NLYR-1)
         VF(NLYR-1) = R(NLYR-1)
         DO J = NLYR-2, 0, -1
            VACHI = VG(J+1) * CHI(J+1)
            VG(J) = (VACHI + T(J)) / (ONE + VACHI* T(J))
            VACHI = VF(J+1) * CHI(J+1)
            VF(J) = (VACHI + R(J)) / (ONE + VACHI* R(J))
         END DO

         AG(1) = -T(0)
         AF(1) = -ONE
         DO J = 2, NLYR
            VACHI = AG(J-1) * CHI(J-1)
            AG(J) = (VACHI - T(J-1)) / (ONE - VACHI* T(J-1))
            VACHI = AF(J-1) * CHI(J-1)
            AF(J) = (VACHI - R(J-1)) / (ONE - VACHI* R(J-1))
         END DO
         VLG = VG(RXLYR)
         VLF = VF(RXLYR)
         VMG = VG(SXLYR)
         VMF = VF(SXLYR)
         AMG = AG(SXLYR)
         AMF = AF(SXLYR)
         DENOMG = ONE - VMG * AMG * CHI(SXLYR)
         DENOMF = ONE - VMF * AMF * CHI(SXLYR)

      END SELECT

    END SUBROUTINE PROPAGATE

  END SUBROUTINE MDSX_COEF


  !==========================================================================================
  !*****************************
  !       BEGIN 3D CODE
  !       -------------
  !*****************************



  subroutine ROT_BFT_FOR_LEROIAIR(SVAZM,BFD_SCAT_LEROI,BFD_SCAT,NFRQ,NSTAT)
    INTEGER NFRQ,NSTAT
    REAL SVAZM(NSTAT)
    COMPLEX :: BFD_SCAT(NFRQ,NSTAT,3)
    COMPLEX :: BFD_SCAT_LEROI(NFRQ,1,NSTAT,3)
    REAL CAZ0,SAZ0

    INTEGER JS,JF    

    COMPLEX Q1(1:2) 

    DO JS=1,NSTAT
       CAZ0 = COS (SVAZM (JS))
       SAZ0 = SIN (SVAZM (JS))


       DO JF=1,NFRQ

          Q1(1:2) =BFD_SCAT_LEROI(JF,1,JS,1:2)*1.0e9
          BFD_SCAT(JF,JS,1) =  CAZ0 * Q1(1) + SAZ0 * Q1(2)
          BFD_SCAT(JF,JS,2) = -SAZ0 * Q1(1) + CAZ0 * Q1(2)

          BFD_SCAT(JF,JS,3) = BFD_SCAT_LEROI(JF,1,JS,3)*1.0e9
       END DO
    END DO





  end subroutine ROT_BFT_FOR_LEROIAIR

  SUBROUTINE LEROI_3D (IPR,NFRQ,FREQ,SOURCE_TYPE,NTX,MXVRTX,NVRTX,SXN,SXE,SXZ,SXDIP,SXAZM,NRXTX, &
       MRXTX,RXID,MQVR,MXRS,XRXTX,YRXTX,ZRXTX,NLYR,THKD,RES,RMUD,REPS,CHRG,CTAU, &
       CFREQ,NPLT,MXAB,CELLW,PLNGTH,PLWDTH,XCNTR,YCNTR,PLTOP,PLAZM,PLDIP,PLUNJ,  &
       INTRUDE,SIG_T,CHRGP,CTAUP,CFREQP,MXRHO,RHOTRP,INVERT,BFD_SCAT,leroiair_failure_count)
    !----------------------------------------------------------------------------------------------

    !***  Called by MAIN
    !***  Calls SET_MGT, SET_MAX_INTRP

    ! Main routine for 3D Leroi computation for the scattered field.
    ! For magnetic dipole and loop receivers, BFD_SCAT in Teslas per unit amp.
    !
    ! For magnetic dipole receivers, BFD_SCAT(JF,JR,JS,1:3) contains the
    ! 1: north, 2: east & 3:vertical components for frequency JF, transmitter JS, receiver JR.
    !
    ! The response for electric dipoles and loop receivers is contained in BFD_SCAT(JF,JR,JS,1),
    ! BFD_SCAT(JF,JR,JS,2:3) is set to zero.
    !
    !   NFRQ         - number of frequencies
    !   FREQ         - array of frequencies
    !   SOURCE_TYPE  = 1 => general loop
    !                = 2 => grounded wire
    !                = 3 => magnetic dipole
    !                = 4 => coincident loop
    !   NTX          - number of transmitter positions
    !   MXVRTX       - maximum number of vertices for any transmitter
    !   NVRTX(J)     - number of vertices for transmitter J
    !   SXE(K,J)     = local east coordinate of vertex K for loop position J
    !   SXN(K,J)     = local coordinate of vertex K for loop position J
    !   SXZ(J)       = depth of Tx J
    !   SXDIP(J)     = dip (in radians) of dipole J (eg; vertical = 0, horizontal = 90)
    !   SXAZM(J)     = azimuth (in radians) of dipole J (north = 0, east = 90)
    !   NRXTX(J)     - number of receivers for transmitter J
    !   MRXTX        - maximum number of receivers per transmitter
    !   RXID(I,J)    - RX_TYPE of receiver I for transmitter J. 1 => MD; 2 => ED; 4=> cdnt loop.
    !   MQVR         - maximum number of vertices for all receivers (= 1 if all sources are magnetic dipoles)
    !   XRXTX(I,J,K) - north coordinate of the Kth vertex of the Ith receiver of transmitter J
    !   YRXTX(I,J,K) - east coordinate of the Kth vertex of the Ith receiver of transmitter J
    !   ZRXTX(I,J)   - depth of the Ith receiver of transmitter J
    !                - K = 1 only for mag dipole Rx; 1 to 2 for electric dipole Rx; 1 to 4 for loop Rx
    !   NLYR         - number of layers
    !   RES          - layer conductivities
    !   RMUD         - mu(i) / mu(0)
    !   REPS         - array of relative dislectric constants
    !   THKD         - thicknesses of NLYR -1 layers above basement
    !   CHRG         - C-C chargeability
    !   CTAU         - array of layer relaxation times (sec).
    !   CFREQ        - array of layer frequency parameters.
    !   RHOTRP       - horizontal distance interpolation array (15 pts / decade) of dimension MXRHO
    !
    !           Parameters for NPLT plates
    !           --------------------------
    !
    !   MXAB   - Number of cells in biggest plate
    !   CELLW  - nominal cell dimension
    !   PLNGTH - strike length for each plate
    !   PLWDTH - dip width for each plate
    !   XCNTR  - north coordinates of plate reference & pivot point
    !   YCNTR  - east coordinates of plate reference & pivot point
    !   PLTOP  - depth to top from surface
    !   PLAZM  - strike angle (radians) = dip azimuth - pi/2
    !   PLDIP  - dip angle
    !   PLUNJ  - plunge rotation
    !   SIG_T  - conductivity thickness product
    !   CHRGP  - Cole Cole chargeability
    !   CTAUP  - Cole Cole time constant
    !   CFREQP - Cole Cole frequency constant
    !

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80), NMG1=3, NQS=1000
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NLYR,NPLT,NTPL,MXAB,MXB,NCELL2(0:NPLT),ICCL(NLYR),IPR,NFRQ,SOURCE_TYPE,NTX, &
         MXVRTX,NVRTX(NTX),NRXTX(NTX),MRXTX,NRS(MRXTX,NTX),MXRS,MQVR,MXRHO,RXID(MRXTX,NTX), &
         MXCL2,NMGP,NRPRM,NREGT,NRMGT,NPPD,ACC,NZ1,NZ2,NZ3,IFIN,J1,J2,JF,JS,JR,JP,JB,JL
    INTEGER, DIMENSION(NPLT) :: NA,NB,ICCP,PLYR,IDPL
    REAL FRQ,FREQ(NFRQ),CELLW,DPTHB,RHOTRP(MXRHO),ZMIN,ZMAX,ZMIN2,ZMAX2,SKN,SPAN,DELZ, &
         QSTORE(NQS),DEL
    REAL, DIMENSION(NLYR) :: RES,REPS,CTAU,CFREQ,CHRG
    REAL, DIMENSION(NTX) :: SXDIP,SXAZM,SXZ
    REAL, DIMENSION(NPLT) :: SIG_T,CHRGP,CTAUP,CFREQP,XCNTR,YCNTR,PLTOP,PLWDTH, &
         PLNGTH,PLAZM,PLDIP,PLUNJ,DA,DB,WMG
    REAL, DIMENSION(MXVRTX,NTX) :: SXN,SXE
    REAL, DIMENSION(MRXTX,NTX) :: EDCS,EDSN,ZRXTX
    REAL, DIMENSION(MRXTX,NTX,MQVR) :: XRXTX,YRXTX
    REAL, DIMENSION(MXRS,MRXTX,NTX) :: XRS,YRS,WTRS    ! Rx subnet
    COMPLEX BFD_SCAT(NFRQ,MRXTX,NTX,3)
    COMPLEX, DIMENSION(NPLT) :: KSQT, SIGT

    REAL(KIND=QL) RMUD(0:NLYR)
    REAL(KIND=QL), DIMENSION(NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    LOGICAL MDRX,EDRX,QUIT,DCMP_FAIL,INVERT,INTRUDE

    REAL, ALLOCATABLE, DIMENSION(:) :: ZV1,ZV2,ZC1L
    REAL, ALLOCATABLE, DIMENSION(:,:) :: XCELL,YCELL,ZCELL,ZC1,ZC3,XMG,YMG,ZMG
    COMPLEX, ALLOCATABLE, DIMENSION(:,:,:,:) :: J_SCAT,E_PRYM

    INTEGER ::leroiair_failure_count
    ! Depth interpolation arrays for basement plates:
    ! -----------------------------------------------
    !  ZV1(NZ1) will be used for MGT & EGTRX for 2D interpolation relating basement sources to receivers
    !  These are distances from the surface.
    !
    !  ZV2(NZ2) is used for EGT_BOSS for interpolating z + z - 2 * DPTHB
    !
    ! Depth interpolation arrays for plates in layers above basement:
    ! --------------------------------------------------------------
    ! ZC1 (MXB,NTPL) will be used for PRM_BOSS.  It contains the cell row centres of plates above basement

    ! Construct plate representation

    DPTHL = 0._QL
    DO JL = 2,NLYR
       DPTHL(JL) = DPTHL(JL-1) + THKD(JL-1)     ! Depth to top of layer
    END DO
    DPTHB = REAL (DPTHL(NLYR))                 ! Depth to basement

    NTPL = 0
    IDPL = 0
    MXB = 1
    PLYR = NLYR
    IF (INTRUDE) THEN
       DO JP = 1,NPLT
          DO JL = 1,NLYR
             IF (PLTOP(JP) + 0.01 > REAL (DPTHL(JL))) PLYR(JP) = JL      ! Find layer containing Plate JP
          END DO
          DEL = PLTOP(JP) - REAL (DPTHL(PLYR(JP)))
          IF (DEL < 0.01) PLTOP(JP) = REAL (DPTHL(PLYR(JP))) + 0.01 
          IF (PLYR(JP) < NLYR) THEN
             NTPL = NTPL + 1           !  mumber of plates above basement
             IDPL(NTPL) = JP           !  ID of each plate above basement
          END IF
       END DO
    END IF

    ! Adjust plates and set cell dimensions
    CALL SET_CELLS_1 (IPR,DPTHB,NLYR,NPLT,PLYR,CELLW,PLNGTH,PLWDTH,PLTOP,PLAZM, &
         PLDIP,PLUNJ,NA,NB,DA,DB,MXCL2,MXAB,NCELL2,ZMIN,ZMAX)

    DO J1 = 1,NTPL
       JP = IDPL(J1)
       MXB = MAX (MXB,NB(JP))
    END DO
    NZ3 = 3 * MXB

    ALLOCATE (XCELL(MXAB,NPLT),YCELL(MXAB,NPLT),ZCELL(MXAB,NPLT),ZC1(MXB,NTPL),ZC3(NZ3,NTPL), &
         ZC1L(MXB),J_SCAT(2,MXAB,NTX,NPLT),E_PRYM(2,MXAB,NTX,NPLT))

    ! Set cell locations
    CALL SET_CELLS_2 (IPR,NPLT,MXAB,XCNTR,YCNTR,PLTOP,PLAZM,PLDIP, &
         PLUNJ,NA,NB,DA,DB,XCELL,YCELL,ZCELL)

    !print *,xcell
    !print *,ycell                  
    !print *,zcell


    ZC1 = 0.
    ZC3 = 0.
    DO J1 = 1,NTPL
       JP = IDPL(J1)
       DELZ = SIN (PLDIP(JP)) * DB(JP) / 3.
       DO JB = 1,NB(JP)
          J2 = (JB-1) * NA(JP) + 1   ! index of first cell of row JB of Plate JP for plates above basement
          ZC1(JB,JP) = ZCELL(J2,JP)  ! depth of centre of cell row JB of Plate JP for plates above basement
          ZC3(3*JB-1,JP) = ZC1(JB,JP)
          ZC3(3*JB-2,JP) = ZC1(JB,JP) - DELZ
          ZC3(3*JB,JP)   = ZC1(JB,JP) + DELZ
       END DO
    END DO


    EDRX = .FALSE.       ! Compute electric field on surface?
    MDRX = .FALSE.       ! Compute magnetic field on surface?

    ! Set up receiver subnets for loop and electric dipole receivers

    IF (SOURCE_TYPE == 4) THEN
       MDRX = .TRUE.

    ELSE
       DO JS = 1,NTX
          DO JR = 1,NRXTX(JS)
             IF (RXID(JR,JS) == 1) MDRX = .TRUE.
             IF (RXID(JR,JS) == 2 .OR. RXID(JR,JS) == 3) EDRX = .TRUE.
          END DO
       END DO
    END IF

    XRS = 0;  YRS = 0;   WTRS = 1;  EDCS = 0.;  EDSN = 0.

    IF (SOURCE_TYPE == 4) THEN
       CALL SET_RX_SUBNET_CL (NTX,SXN,SXE,MXRS,NRS,XRS,YRS,WTRS)
    ELSE
       CALL SET_RX_SUBNET (NTX,MRXTX,NRXTX,MXRS,NRS,MQVR,RXID,XRXTX,YRXTX,XRS,YRS,WTRS,EDCS,EDSN)
    END IF


    !print *,XRXTX
    !print *,YRXTX

    ! Set up horizontal distance descriptors and arrays for
    ! primary field, & electric & magnetic Green's FUNCTION s.

    ! Set up uniform integration for magnetic field computation

    NMGP = NMG1**2
    ALLOCATE (XMG(NMGP,NPLT),YMG(NMGP,NPLT),ZMG(NMGP,NPLT))

    CALL SET_MGT (NPLT,NMG1,NMGP,DA,DB,PLAZM,PLDIP,PLUNJ,XMG,YMG,ZMG,WMG)

    CALL SET_MAX_INTRP (MXRHO,RHOTRP,MXAB,NPLT,NA,NB,DA,PLNGTH,XCELL,YCELL,NTX,MXVRTX, &
         NVRTX,SXN,SXE,MRXTX,NRXTX,MXRS,NRS,XRS,YRS,NRMGT,NRPRM,NREGT)


    !print *,xcell
    !print *,Ycell
    !print *,zcell


    !  Set depth interpolation

    ZMIN2 = 2.* (ZMIN - DPTHB)
    ZMAX2 = 2.* (ZMAX - DPTHB)
    ZMIN2 = MAX (ZMIN2, 0.02)

    NPPD = 15
    ACC = 1

    BFD_SCAT = ZERO

    IF (.NOT. INVERT) WRITE(*,1) NFRQ
    ICCL = 0; ICCP = 0
    DO J1 = 1,NPLT
       IF (CTAUP(J1) > 1.E-8) ICCP(J1) = 1
    END DO
    DO J1 = 1,NLYR
       IF (CTAU(J1) > 1.E-8) ICCL(J1) = 1
    END DO

    QUIT = .FALSE.
    FREQUENCY_LOOP: DO JF = 1,NFRQ
       IFIN = INT (100. * (JF-1) / REAL (NFRQ) )
       FRQ = FREQ(JF)
       IF (.NOT. INVERT) WRITE(*,2) JF,FRQ,IFIN

       ! Set up complex conductivities.  Then compute primary fields, Green's tensors,
       ! scattering matrices and scattering currents for each plate individually.

       CALL COLRES_3D (FRQ,NLYR,RMUD,RES,REPS,ICCL,CHRG,CTAU,CFREQ,NPLT, &
            SIG_T,CHRGP,CTAUP,CFREQP,ICCP,SIGL,KSQL,SIGT,KSQT)

       SKN = 1.0 / REAL (SQRT(KSQL(NLYR)), 4)
       SPAN = MIN (SKN,10.)
       SPAN = MAX (SPAN,5.)
       DELZ = 0.2 * SKN

       !  Set basement interpolation array for MGT & PRM routines.
       !  ZV1 measures depth extending from DEPTHB downwards

       CALL SET_Z (ACC,NPPD,ZMIN,ZMAX,SPAN,DELZ,NQS,QSTORE,NZ1)
       ALLOCATE (ZV1(NZ1))
       ZV1(1:NZ1) = QSTORE(1:NZ1)
       IF (ZV1(1) < DPTHB) THEN
          ZV1(2) = (ZMIN + DPTHB) / 2.
          ZV1(1) = (ZV1(2) + DPTHB) / 2.
       END IF

       ! Set basement interpolation array for EGT routines
       ! ZV2 measure reflection distance in basement from DEPTHB

       CALL SET_Z (ACC,NPPD,ZMIN2,ZMAX2,SPAN,DELZ,NQS,QSTORE,NZ2)
       ALLOCATE (ZV2(NZ2))
       ZV2(1:NZ2) = QSTORE(1:NZ2)

       !  Compute the layered earth electric fields on the target, E_PRYM.

       E_PRYM = ZERO
       IF (SOURCE_TYPE == 3) THEN   ! Magnetic dipole
          IF (MAXVAL (PLYR) == NLYR) &    ! basement plates
               CALL PRM_BOSS_MD (FRQ,NTX,SXN,SXE,SXZ,SXDIP,SXAZM,NRPRM,RHOTRP,NLYR,THKD,DPTHL, &
               RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB,NB,NA,XCELL,  &
               YCELL,ZCELL,NZ1,ZV1,E_PRYM)


          DO J1 = 1, NTPL          ! plates above basement
             JP = IDPL(J1)
             ZC1L(1:MXB) = ZC1(1:MXB,JP)
             CALL PRM_BOSS_UL_MD (JP,FRQ,NTX,SXN,SXE,SXZ,SXDIP,SXAZM,NRPRM,RHOTRP,NLYR,THKD, &
                  DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB,MXB, &
                  NB,NA,XCELL,YCELL,ZC1L,E_PRYM)
          END DO
       ELSE                          ! Open or closed loop
          IF (MAXVAL (PLYR) == NLYR) &    ! basement plates
               CALL PRM_BOSS_LP (SOURCE_TYPE,NTX,MXVRTX,NVRTX,SXN,SXE,SXZ,NRPRM,RHOTRP,NLYR,  &
               THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB, &
               NB,NA,XCELL,YCELL,ZCELL,NZ1,ZV1,E_PRYM)

          DO J1 = 1, NTPL          ! plates above basement
             JP = IDPL(J1)
             ZC1L(1:MXB) = ZC1(1:MXB,JP)
             CALL PRM_BOSS_UL_LP (JP,SOURCE_TYPE,NTX,MXVRTX,NVRTX,SXN,SXE,SXZ,NRPRM,RHOTRP,NLYR, &
                  THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB,    &
                  MXB,NB,NA,XCELL,YCELL,ZC1L,E_PRYM)
          END DO
       END IF



       !  Set up scattering matrix SCAT_MTRX as an LU decomposition.

       CALL SCAT_MTRX_BOSS (NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,NTPL,IDPL,PLYR,MXB,MXAB,NCELL2, &
            MXCL2,NA,NB,DA,DB,SIGT,KSQT,PLTOP,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,    &
            ZCELL,NZ2,ZV2,ZC1,NREGT,RHOTRP,NTX,E_PRYM,J_SCAT,DCMP_FAIL)

       !print *,e_prym(1,1,1,1),e_prym(1,10,1,1)
       !print *,J_SCAT(1,1,1,1),J_SCAT(1,10,1,1)

       IF (DCMP_FAIL) THEN
          leroiair_failure_count=1
          !WRITE(*,3)
          !STOP
          RETURN
       END IF

       !  Compute BFD_SCAT, the scattered frequency-domain magnetic fields.

       CALL SCAT_EM (JF,NFRQ,NPLT,PLYR,NTPL,IDPL,MXAB,MXB,NA,NB,DA,DB,PLAZM,PLDIP,PLUNJ,XCELL,  &
            YCELL,ZCELL,NMGP,XMG,YMG,ZMG,WMG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX, &
            NRXTX,RXID,MXRS,NRS,XRS,YRS,ZRXTX,WTRS,EDCS,EDSN,NRMGT,RHOTRP,NZ1,ZV1,NZ3, &
            ZC3,MDRX,EDRX,J_SCAT,BFD_SCAT,QUIT)

       !print *,XRS
       !print *,YRS
       !print *,zrxtx

       IF (QUIT) EXIT    !  If scattered fields are negligible, end frequency stepping

       DEALLOCATE (ZV1,ZV2)
    END DO FREQUENCY_LOOP
    DEALLOCATE (XMG,YMG,ZMG,XCELL,YCELL,ZCELL,J_SCAT,E_PRYM)

1   FORMAT(/T3,'A maximum of',I3,' 3D frequency-domain responses', &
         /T3,'will be computed initially.'/)
2   FORMAT(T3,'frequency',I3,'  =',G12.4,I8,' percent done')
3   FORMAT (//T3,'An evil spirit has entered SCAT_MTRX_LU_DCMP causing the matrix to be singular.', &
         /T3,'The model leading to this crash is Described in Leroi.out.' &
         /T3,'COMPUTATION HALTED.  SEEK HELP.  (art.raiche@optusnet.com.au)')

  END SUBROUTINE LEROI_3D

  SUBROUTINE COLRES_3D (FRQ,NLYR,RMUD,RES,REPS,ICCL,CHRG,CTAU,CFREQ,NPLT, &
       SIG_T,CHRGP,CTAUP,CFREQP,ICCP,SIGL,KSQL,SIGT,KSQT)
    !------------------------------------------------------------------------

    !  Computes SIGL, the complex conductivities of layers and SIGT, the complex
    !  conductances of plates, at frequency FRQ using the layered earth Cole-Cole
    !  parameters, CHRG, CTAU, CFREQ, the plate Cole-Cole parameters: CHRGP,
    !  CTAUP, CFREQP,the NLYR real layer resistivities, RES, and the real conductance,
    !  SIG_T, SIGL and SIGT include displacement currents.

    !  KSQL = iwu * SIGL = the layered earth propagation constants.
    !  KSQT = iwu * SIGT = the propagation constants for plates.

    !***  Called by MAIN

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    REAL, PARAMETER :: TWOPI=6.2831853, MU0=12.56637E-7, EPS0=8.854156E-12
    COMPLEX, PARAMETER :: ONE=(1.,0.)
    INTEGER J,NLYR,NPLT,ICCL(NLYR),ICCP(NPLT)
    REAL, DIMENSION(NLYR) :: RES,REPS,CHRG,CALF,CTAU,CFREQ
    REAL FRQ
    REAL, DIMENSION(NPLT) :: SIG_T,CHRGP,CALFP,CTAUP,CFREQP
    REAL(KIND=QL) RMUD(0:NLYR)
    COMPLEX A1,IW,P
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    COMPLEX, DIMENSION(NPLT) :: KSQT, SIGT

    CALF = 1. - CHRG
    CALFP = 1. - CHRGP
    IW = TWOPI * CMPLX (0.,FRQ)
    DO J = 1,NLYR                ! Layers
       A1 = CMPLX (1./RES(J), 0.)
       P = ICCL(J) * (IW * CTAU(J) )**CFREQ(J)
       A1 = A1 * (ONE + P) / (ONE + CALF(J)*P)
       A1 = A1 + IW * EPS0 * REPS(J)  !  Add in displacement term
       SIGL(J) = CMPLX (A1,KIND=QL)
       A1 = IW * MU0 * A1
       KSQL(J) = RMUD(J) * CMPLX (A1,KIND=QL)
    END DO

    DO J = 1,NPLT                ! Plates
       SIGT(J) = CMPLX (SIG_T(J), 0.)
       P = ICCP(J) * (IW * CTAUP(J) )**CFREQP(J)
       SIGT(J) = SIGT(J) * (ONE + P) / (ONE + CALFP(J)*P)
       KSQT(J) = IW * MU0 * REAL (RMUD(NLYR)) * SIGT(J)
    END DO

  END SUBROUTINE COLRES_3D

  !======================================================================================
  !======================================================================================
  !
  !        SINGLE PLATE GREENS FUNCTION ROUTINES
  !        -------------------------------------


  SUBROUTINE EGT_BOSS (NAL,NBL,NAB,DAL,DBL,KSQN,DPTHB,XCEL1,YCEL1,ZCEL1,CDP,SDP,CPL, &
       SPL,NZ2,ZV2,NREGT,RHOTRP,GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,  &
       GI4Z,GR5Z,GI5Z,GR6Z,GI6Z,SAA,SBA,SBB,VAA,VAB,VBA,VBB)
    ! ---------------------------------------------------------------------------------

    !***  Calls EGTDIR
    !***  Called by SCAT_MTRX_BOSS

    !         INPUT
    !         -----
    !
    !     NBL,NAL - number of cell rows and columns respectively
    !     DBL,DAL - cell dimensions down dip and along strike respectively
    !        KSQN - basement propagation constant
    !       DPTHB - depth to basement
    !    CDP, SDP - dip cosine and sine
    !    CPL, SPL - rotation cosine and sine
    !    XCEL1,YCEL1,ZCEL1 - X,Y,Z coordinates of cells on plate
    !    ZV2 - array of NZ2 depths used for vertical interpolation
    !    RHOTRP - array of NREGT logrithmically spaced points used for horizontalal interpolation
    !    GR1Z to GR6Z - 2D grid of real component of 6 Green's tensor components integrals
    !    GI1Z to GI6Z - 2D grid of imaginary component of 6 Green's tensor components integrals
    !
    !         OUPUT
    !         ------
    !
    !    SAA, SBB, SBA - divergence free integrated Green's tensor elements
    !    VAA, VBB, VAB, VBA - curl free integrated Green's tensor elements
    !                         A => along strike
    !                         B => down dip
    !
    !  EGT_BOSS computes the integrals over the "source" cell of the Green's tensor
    !  elements ( GTE ) for single plates contained in a uniform half-space or
    !  entirely inthe bottom layer of a two layer half-space.  The direct portion is
    !  computed separately from the reflected/transmitted scattered terms.

    !  In what follows, the GTE have the units of electric field divided by a
    !  factor (-iwu) because this factor is explicitly included as a multiplier
    !  outside the integral over area when solving the integral equation.
    !
    !  In the formulation the integrated Green's tensor G relates the field at r'
    !  to the current at r by
    !                                           _                      _
    !                                          |  Gaa(r.r')  Gab(r.r')  |
    !  { Ea(r'), Eb(r') } =  { Ja(r), Jb(r) }  |                        |
    !                                          |  Gba(r.r')  Gbb(r.r')  |
    !                                          |_                      _|
    !
    !  These GTE, Gij were derived by computing the i'th component of the field at r
    !  due to a j-oriented unit electric dipole at r'.  The integral of the GTE is
    !  over r so we have the contradiction of designating the cells over which we
    !  integrate the product of the GTE and scattering curent as the receiver cells
    !  and the cell where we evaluate the field as the source cell.  Let's change
    !  this by first putting the above form into the more expected operator form by
    !  writing the GTE matrix in transposed form as:
    !
    !   _        _       _                      _    _       _
    !  |  Ea(r')  |     |  Gaa(r,r')  Gba(r,r')  |  |  Ja(r)  |
    !  |          |  =  |                        |  |         |
    !  |  Eb(r')  |     |  Gab(r,r')  Gbb(r,r')  |  |  Jb(r)  |
    !  |_        _|     |_                      _|  |_       _|
    !
    !
    !  Using the self-adjoint nature of the GTE, we can rewrite this as the transpose
    !  by switching the role of "source" and "receiver" in the GTE.
    !
    !
    !   _        _        _                       _    _       _
    !  |  Ea(r')  |      |   Gaa(r',r)  Gab(r',r)  |  |  Ja(r)  |
    !  |          |   =  |                         |  |         |
    !  |  Eb(r')  |      |   Gba(r',r)  Gbb(r',r)  |  |  Jb(r)  |
    !  |_        _|      |_                       _|  |_       _|
    !
    !    Now, Gij(r',r) = i'th component at r' due to j-oriented source at r
    !    Thus the second operator form relates the observed field at r'
    !    to the source at r in the more expected way

    !    Although the Gij are computed initially as the received field at r due to
    !    a source at r', the expression above requires that the Gij are to be used
    !    in a system centred at the receiver point rather than the spource point.
    !    This affects only the cross terms with z.  Gxz(r',r) = -Gxz(r,r')
    !    Gzx(r',r) = -Gxz(r',r)
    !
    !    Thus in what follows, the integration over r is now referred to as the
    !    integration over the source cell rather than the receiver cell due to the
    !    use of the adjoint form.
    !
    !  Weidelt's solution for the induced scattering current Js(r') requies that
    !  the integrated Green's FUNCTION s be computed in the form
    !
    !  Gaa = Saa + Haa /Ksq_bas;  Gab = Sab + Hab /Ksq_bas;
    !                             Gba = Sba + Hba /Ksq_bas  &
    !  Gbb = Sbb + Hbb /Ksq_bas   where  Ksq_bas :=  i * omega * mu / res(basement).
    !
    !  Saa, Sab=Sba, & Sbb are the induced (divergence free) part of the GTE,
    !  corresponding to currents enclosed within the plate.
    !  Haa, Hab, Hba, & Hbb are the curl-free or current channelling part
    !  of the GTE which are closed outside the plate.
    !
    !    OUTPUT:
    !   The inoitial "reversed" Green's FUNCTION s are expressed as:
    !
    !  VAAI (JCR,JCS) - relate the along strike component of the electric field at
    !  SAAI (JCR,JCS)   cell JCR to the along strike component of the scattering
    !                   current of cell JCS
    !
    !  VBAI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBAI (JCR,JCS)   cell JCR due to the along strike component of the
    !                   scattering current of cell JCS
    !
    !  VABI (JCR,JCS) - relate the along strike component of the electric field at
    !  SABI (JCR,JCS)   cell JCR due to the down dip component of the scattering
    !                   current of cell JCS
    !
    !  VBBI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBBI (JCR,JCS)   cell JCR due to the down dip component of the scattering
    !                   current of cell JCS of plate JPS
    !
    !  the  OUTPUT is  Sij and converts Hij such that Hij -> Hij + Ksq_bas * Sij
    !
    !  the forms used by the SUBROUTINE SCAT_MTRX_BUILD
    !
    !  Symmetry is used to reduce computation.  If the source is in row JB and the
    !  receiver point in row KB, the GTE will be FUNCTION of horizontal separation
    !  (translation independent).  In what follows, KB and JB are the row indices
    !  of the receiver and source cells respectively.  JA is a column index
    !  denoting horizontal separation.
    !
    !  Thus, SAB(KB,JB,JA) is the electric field in the XI-oriented (along-strike)
    !  field at row KB, due to a ETA (down dip)) oriented electric dipole current
    !  integrated over a cell in row JB, column spearation JA.
    !  SAA is the XI electric field due to a XI-oriented dipole.
    !  SBB is the ETA electric field caused by an ETA-oriented electric dipole.
    !  Similarly for VAA, VAB, VBA, & VBB.
    !
    !  In what follows, XI is the coordinate along strike which is defined as a
    !  clockwise rotation (East of North) from the X (North) axis).
    !  ETA is the coordinate down dip.  ETA = X*CDIP + Z*SDIP.
    !  The "reeiver cell" has cell numbers (KB,1) in the (ETA,XI) direction.
    !  The "source cell" has cell numbers (JB,JA) in the (ETA,XI) direction.
    !  Integration is over the source cell.
    !
    !  NAL & NBL are the number of cells along strike and down dip respectively.
    !  DAL & DBL are the corresponding lengths of the cells.
    !  DPTHB is depth to basement.
    !  PLTOP is the distance to the top of the plate and (CDIP, SDIP) refer
    !  to the dip.
    !  A vertical body has these as (0,1) and a flat lying plate as (1,0)
    !  VBBT * VABT are temporary storage variables.
    !
    ! -------------------------------------------------------------------------

    IMPLICIT NONE
    INTEGER, PARAMETER :: NGL=5
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NAL,NBL,NAB,NREGT,NZ2,J1,J2,KB,KA,JB,JA,JB_KB,JA_KA,JAB,KAB
    REAL, DIMENSION(4,NREGT,NZ2) :: GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,GI5Z,GR6Z,GI6Z
    REAL, DIMENSION(NGL) :: GLX,GLW,WGHTA,WGHTB,XI_GL,ETA_GL(NGL)
    REAL RHOTRP(NREGT),ZV2(NZ2),DPTHB,DAL,DALH,DBL,DBLH,CDP,SDP,CPL,SPL,CAZ,SAZ,X,XC, &
         XGL,Y,YC,YGL,ZCR,ZGL,ZTR,RHO,XBAR,XBARSQ,YBAR,YBARSQ,R23(2,3),R32(3,2)
    REAL, DIMENSION(NAB) :: XCEL1,YCEL1,ZCEL1
    COMPLEX, DIMENSION(NBL,NAL) :: SAAD,VAAD,VABD,VBBD
    COMPLEX, DIMENSION(NBL,NBL,NAL,NAL) :: SAA,SBA,SBB,VAA,VAB,VBA,VBB
    COMPLEX GAB(2,2),VAB22(2,2),SAB22(2,2),GXYZ(3,3),RTMP(3,2)
    COMPLEX KSQN,KBASE,AAS,AAV,ABV,BBV,GC1,GC2,GC3,GC4,GC5,GC6

    DATA GLX / -.9061798, -.5384693,    0.,    .5384693, .9061798/
    DATA GLW /  .2369269,  .4786287, .5688888, .4786287, .2369269/

    SAA=ZERO; SBA=ZERO; SBB=ZERO; VAA=ZERO; VAB=ZERO; VBA=ZERO; VBB=ZERO;

    ! Set up propagation constants, integration weights, and interpolation range for
    ! Gauss-Legendre integration in ETA direction at density of 1/5 modified skin depth.

    CAZ = 1.
    SAZ = 0.
    CALL RXYZ2PLT (CAZ,SAZ,CDP,SDP,CPL,SPL,R23)
    CALL RPLT2XYZ (CAZ,SAZ,CDP,SDP,CPL,SPL,R32)

    WGHTB = GLW * DBL /2.  ! Set weight array
    DBLH = DBL / 2.
    ETA_GL = GLX * DBLH
    DALH = DAL / 2.
    KBASE = SQRT (KSQN)
    IF (REAL (KBASE) < 0) KBASE = -KBASE

    ! Compute the direct component for use after indirect component integration
    ! Because it depends only on the intercell distance and not plate position,
    ! it can be computed directly in plate system, requiring no rotation.
    ! VBA picks up the direct component from VAB further down.

    DO JA = 1,NAL
       DO JB = 1, NBL
          CALL EGTDIR (JB,JA,KBASE,DAL,DBL,AAS,AAV,ABV,BBV)
          SAAD(JB,JA) = AAS
          VAAD(JB,JA) = AAV
          VBBD(JB,JA) = BBV
          VABD(JB,JA) = ABV
       END DO
    END DO

    !  ETA, ETAS, ETAR refer to distances down dip from designated top edge of plate.
    !  They are in the "plate" coordinate system and are independent of dip & rotation.
    !  Similarly, XI refers to distances along strike in the "plate" coordinate system.

    DO KB = 1, NBL                                  ! receiver cell row loop
       DO JB = KB, NBL                               ! source cell row loop
          DO J1 = 1, NGL
             YGL = ETA_GL(J1) * CDP
             ZGL = ETA_GL(J1) * SDP

             KA = 1                     !     JA = KA.  Use symmetry wrt XI.
             KAB = KA + (KB-1)* NAL
             JAB = KA + (JB-1)* NAL
             XC = XCEL1(JAB) - XCEL1(KAB)
             YC = YCEL1(JAB) - YCEL1(KAB)
             ZCR = ZCEL1(KAB) + ZCEL1(JAB) - 2.* DPTHB

             Y = YC + YGL

             XI_GL = (GLX + 1.) * DALH / 2.
             WGHTA = GLW * DAL /4.  ! Set weight array

             SAB22 = ZERO;  VAB22 = ZERO
             DO J2 = 1,NGL
                XGL =  XI_GL(J2)
                X = XC  + XGL * CPL - ZGL * SPL
                ZTR = ZCR + XGL * SPL + ZGL * CPL

                RHO = SQRT (X**2 + Y**2)
                XBAR = X / RHO
                XBARSQ = XBAR**2
                YBAR = Y / RHO
                YBARSQ = YBAR**2

                GC1 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR1Z,GI1Z,RHO,ZTR)
                GC2 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR2Z,GI2Z,RHO,ZTR)
                GC3 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR3Z,GI3Z,RHO,ZTR)
                GC4 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR4Z,GI4Z,RHO,ZTR)
                GC5 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR5Z,GI5Z,RHO,ZTR)

                GXYZ = ZERO; GAB = ZERO

                GXYZ(1,1) = (1. - 2.*YBARSQ) * GC4 + YBARSQ * GC1             ! Sxx
                GXYZ(2,2) = (1. - 2.*XBARSQ) * GC4 + XBARSQ * GC1             ! Syy
                GXYZ(3,3) = ZERO                                              ! Szz

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)
                SAB22 = SAB22 + WGHTA(J2) * GAB

                GXYZ = ZERO; GAB = ZERO

                GXYZ(1,1) = (1. - 2.*XBARSQ) * GC5 + XBARSQ * GC2             ! Vxx
                GXYZ(2,2) = (1. - 2.*YBARSQ) * GC5 + YBARSQ * GC2             ! Vyy
                GXYZ(3,3) = -GC3                                              ! Vzz

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)
                VAB22 = VAB22 + WGHTA(J2) * GAB
             END DO

             SAA(KB,JB,KA,KA) = SAA(KB,JB,KA,KA) + 2. * WGHTB(J1) * SAB22(1,1)
             SBA(KB,JB,KA,KA) = SBA(KB,JB,KA,KA) + 2. * WGHTB(J1) * SAB22(2,1)
             SBB(KB,JB,KA,KA) = SBB(KB,JB,KA,KA) + 2. * WGHTB(J1) * SAB22(2,2)
             VAA(KB,JB,KA,KA) = VAA(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(1,1)
             VBB(KB,JB,KA,KA) = VBB(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(2,2)
             VAB(KB,JB,KA,KA) = VAB(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(1,2)
             VBA(KB,JB,KA,KA) = VBA(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(2,1)

             XI_GL = GLX * DALH
             WGHTA = GLW * DALH                      ! Set weight array
             DO JA = 2, NAL                       ! receiver cell column loop
                JAB = JA + (JB-1)* NAL

                XC = XCEL1(JAB) - XCEL1(KAB)
                YC = YCEL1(JAB) - YCEL1(KAB)
                ZCR = ZCEL1(KAB) + ZCEL1(JAB) - 2.* DPTHB

                Y = YC + YGL

                SAB22 = ZERO;  VAB22 = ZERO
                DO J2 = 1, NGL
                   XGL =  XI_GL(J2)
                   X = XC  + XGL * CPL - ZGL * SPL
                   ZTR = ZCR + XGL * SPL + ZGL * CPL

                   RHO = SQRT (X**2 + Y**2)
                   XBAR = X / RHO
                   YBAR = Y / RHO
                   XBARSQ = XBAR**2
                   YBARSQ = YBAR**2

                   GC1 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR1Z,GI1Z,RHO,ZTR)
                   GC2 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR2Z,GI2Z,RHO,ZTR)
                   GC3 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR3Z,GI3Z,RHO,ZTR)
                   GC4 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR4Z,GI4Z,RHO,ZTR)
                   GC5 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR5Z,GI5Z,RHO,ZTR)
                   GC6 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR6Z,GI6Z,RHO,ZTR)

                   GXYZ = ZERO; GAB = ZERO

                   GXYZ(1,1) = (1. - 2.*YBARSQ) * GC4 + YBARSQ * GC1             ! Sxx
                   GXYZ(2,2) = (1. - 2.*XBARSQ) * GC4 + XBARSQ * GC1             ! Syy
                   GXYZ(3,3) = ZERO                                              ! Szz
                   GXYZ(1,2) = XBAR * YBAR * (2.* GC4 - GC1)                     ! Sxy
                   GXYZ(2,1) = GXYZ(1,2)                                         ! Syx

                   RTMP = MATMUL (GXYZ, R32)
                   GAB =  MATMUL (R23, RTMP)
                   SAB22 = SAB22 + WGHTA(J2) * GAB
                   GXYZ = ZERO; GAB = ZERO

                   GXYZ(1,1) = (1. - 2.*XBARSQ) * GC5 + XBARSQ * GC2             ! Vxx
                   GXYZ(2,2) = (1. - 2.*YBARSQ) * GC5 + YBARSQ * GC2             ! Vyy
                   GXYZ(3,3) = -GC3                                              ! Vzz
                   GXYZ(1,2) = XBAR * YBAR * (GC2 - 2.* GC5)                     ! Vxy
                   GXYZ(2,1) = GXYZ(1,2)                                         ! VyX
                   GXYZ(3,1) = XBAR * GC6                                        ! Vzx
                   GXYZ(3,2) = YBAR * GC6                                        ! Vzy
                   GXYZ(1,3) = -XBAR * GC6                                       ! Vxz
                   GXYZ(2,3) = -YBAR * GC6                                       ! Vyz

                   RTMP = MATMUL (GXYZ, R32)
                   GAB =  MATMUL (R23, RTMP)
                   VAB22 = VAB22 + WGHTA(J2) * GAB
                END DO

                SAA(KB,JB,KA,JA) = SAA(KB,JB,KA,JA) + WGHTB(J1) * SAB22(1,1)
                SBA(KB,JB,KA,JA) = SBA(KB,JB,KA,JA) + WGHTB(J1) * SAB22(2,1)
                SBB(KB,JB,KA,JA) = SBB(KB,JB,KA,JA) + WGHTB(J1) * SAB22(2,2)
                VAA(KB,JB,KA,JA) = VAA(KB,JB,KA,JA) + WGHTB(J1) * VAB22(1,1)
                VBB(KB,JB,KA,JA) = VBB(KB,JB,KA,JA) + WGHTB(J1) * VAB22(2,2)
                VAB(KB,JB,KA,JA) = VAB(KB,JB,KA,JA) + WGHTB(J1) * VAB22(1,2)
                VBA(KB,JB,KA,JA) = VBA(KB,JB,KA,JA) + WGHTB(J1) * VAB22(2,1)
             END DO                   ! JA Loop: 1 to NAL
          END DO                   ! J1 Loop: 1 to NGL down dip

          DO KA = 2,NAL
             DO JA = KA,NAL
                JA_KA = 1 + ABS (JA - KA)
                SAA(KB,JB,KA,JA) = SAA(KB,JB,1,JA_KA)
                SBB(KB,JB,KA,JA) = SBB(KB,JB,1,JA_KA)
                VAA(KB,JB,KA,JA) = VAA(KB,JB,1,JA_KA)
                VBB(KB,JB,KA,JA) = VBB(KB,JB,1,JA_KA)
                SBA(KB,JB,KA,JA) = SBA(KB,JB,1,JA_KA)
                VBA(KB,JB,KA,JA) = VBA(KB,JB,1,JA_KA)
                VAB(KB,JB,KA,JA) = VAB(KB,JB,1,JA_KA)
             END DO
          END DO

          !  Add in the direct contributions for JB >= KB & JA >= KA.
          !  Use symmetry to fill in the rest of the matrix.

          !  Symmetry:  VAB = A* Vxy + B* Vxz.  VBA = A* Vxy - B* Vxz = A* Vxy + B* Vzx
          !  Thus under interchange of A (or x) VAB -> -VAB  & VBA -> -VBA
          !  But under interchange of B (or y) VAB -> -VBA  & VBA -> -VAB

          JB_KB = JB - KB + 1
          DO KA = 1,NAL
             DO JA = KA,NAL
                JA_KA = JA - KA + 1

                SAA(KB,JB,KA,JA) = SAA(KB,JB,KA,JA) + SAAD(JB_KB,JA_KA)
                SBB(KB,JB,KA,JA) = SBB(KB,JB,KA,JA) + SAAD(JB_KB,JA_KA)
                VAA(KB,JB,KA,JA) = VAA(KB,JB,KA,JA) + VAAD(JB_KB,JA_KA)
                VBB(KB,JB,KA,JA) = VBB(KB,JB,KA,JA) + VBBD(JB_KB,JA_KA)
                VAB(KB,JB,KA,JA) = VAB(KB,JB,KA,JA) + VABD(JB_KB,JA_KA)
                VBA(KB,JB,KA,JA) = VBA(KB,JB,KA,JA) + VABD(JB_KB,JA_KA)


                SAA(KB,JB,JA,KA) =  SAA(KB,JB,KA,JA)
                SBB(KB,JB,JA,KA) =  SBB(KB,JB,KA,JA)
                VAA(KB,JB,JA,KA) =  VAA(KB,JB,KA,JA)
                VBB(KB,JB,JA,KA) =  VBB(KB,JB,KA,JA)
                SBA(KB,JB,JA,KA) = -SBA(KB,JB,KA,JA)
                VBA(KB,JB,JA,KA) = -VBA(KB,JB,KA,JA)
                VAB(KB,JB,JA,KA) = -VAB(KB,JB,KA,JA)
             END DO
          END DO
       END DO                   ! JB Loop: 1 to NBL

       DO JB = KB+1, NBL
          SAA(JB,KB,1:NAL,1:NAL) =  SAA(KB,JB,1:NAL,1:NAL)
          SBB(JB,KB,1:NAL,1:NAL) =  SAA(KB,JB,1:NAL,1:NAL)
          VAA(JB,KB,1:NAL,1:NAL) =  VAA(KB,JB,1:NAL,1:NAL)
          VBB(JB,KB,1:NAL,1:NAL) =  VBB(KB,JB,1:NAL,1:NAL)
          SBA(JB,KB,1:NAL,1:NAL) = -SBA(KB,JB,1:NAL,1:NAL)
          VAB(JB,KB,1:NAL,1:NAL) = -VBA(KB,JB,1:NAL,1:NAL)
          VBA(JB,KB,1:NAL,1:NAL) = -VAB(KB,JB,1:NAL,1:NAL)
       END DO
    END DO                   ! KB Loop: 1 to NBL

    ! SET UP S-V SUM AND STORE IT IN V.

    VAA = VAA + SAA * KSQN
    VAB = VAB + SBA * KSQN
    VBA = VBA + SBA * KSQN
    VBB = VBB + SBB * KSQN

  END SUBROUTINE EGT_BOSS

  SUBROUTINE EGT_PL_BOSS (NAL,NBL,NAB,DAL,DBL,KSQN,DPTHB,PTOPL,CDP,SDP,CPL,SPL,NZ2,ZV2, &
       NREGT,RHOTRP,GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,    &
       GI5Z,GR6Z,GI6Z,SAA,SBA,SBB,VAA,VAB,VBA,VBB)
    ! ---------------------------------------------------------------------------------

    !***  Calls EGTDIR
    !***  Called by SCAT_MTRX_BOSS

    !         INPUT
    !         -----
    !
    !     NBL,NAL - number of cell rows and columns respectively
    !     DBL,DAL - cell dimensions down dip and along strike respectively
    !        KSQN - basement propagation constant
    !       DPTHB - depth to basement
    !    CDP, SDP - dip cosine and sine
    !    CPL, SPL - rotation cosine and sine
    !    ZV2 - array of NZ2 depths used for vertical interpolation
    !    RHOTRP - array of NREGT logrithmically spaced points used for horizontalal interpolation
    !    GR1Z to GR6Z - 2D grid of real component of 6 Green's tensor components integrals
    !    GI1Z to GI6Z - 2D grid of imaginary component of 6 Green's tensor components integrals
    !
    !         OUPUT
    !         ------
    !
    !    SAA, SBB, SBA - divergence free integrated Green's tensor elements
    !    VAA, VBB, VAB, VBA - curl free integrated Green's tensor elements
    !                         A => along strike
    !                         B => down dip
    !
    !  EGT_BOSS computes the integrals over the "source" cell of the Green's tensor
    !  elements ( GTE ) for single plates contained in a uniform half-space or
    !  entirely inthe bottom layer of a two layer half-space.  The direct portion is
    !  computed separately from the reflected/transmitted scattered terms.
    !  Azimuth is irrelevant for single plate EGT
    !
    !  In what follows, the GTE have the units of electric field divided by a
    !  factor (-iwu) because this factor is explicitly included as a multiplier
    !  outside the integral over area when solving the integral equation.
    !
    !  In the formulation the integrated Green's tensor G relates the field at r'
    !  to the current at r by
    !                                           _                      _
    !                                          |  Gaa(r.r')  Gab(r.r')  |
    !  { Ea(r'), Eb(r') } =  { Ja(r), Jb(r) }  |                        |
    !                                          |  Gba(r.r')  Gbb(r.r')  |
    !                                          |_                      _|
    !
    !  These GTE, Gij were derived by computing the i'th component of the field at r
    !  due to a j-oriented unit electric dipole at r'.  The integral of the GTE is
    !  over r so we have the contradiction of designating the cells over which we
    !  integrate the product of the GTE and scattering curent as the receiver cells
    !  and the cell where we evaluate the field as the source cell.  Let's change
    !  this by first putting the above form into the more expected operator form by
    !  writing the GTE matrix in transposed form as:
    !
    !   _        _       _                      _    _       _
    !  |  Ea(r')  |     |  Gaa(r,r')  Gba(r,r')  |  |  Ja(r)  |
    !  |          |  =  |                        |  |         |
    !  |  Eb(r')  |     |  Gab(r,r')  Gbb(r,r')  |  |  Jb(r)  |
    !  |_        _|     |_                      _|  |_       _|
    !
    !
    !  Using the self-adjoint nature of the GTE, we can rewrite this as the transpose
    !  by switching the role of "source" and "receiver" in the GTE.
    !
    !
    !   _        _        _                       _    _       _
    !  |  Ea(r')  |      |   Gaa(r',r)  Gab(r',r)  |  |  Ja(r)  |
    !  |          |   =  |                         |  |         |
    !  |  Eb(r')  |      |   Gba(r',r)  Gbb(r',r)  |  |  Jb(r)  |
    !  |_        _|      |_                       _|  |_       _|
    !
    !    Now, Gij(r',r) = i'th component at r' due to j-oriented source at r
    !    Thus the second operator form relates the observed field at r'
    !    to the source at r in the more expected way

    !    Although the Gij are computed initially as the received field at r due to
    !    a source at r', the expression above requires that the Gij are to be used
    !    in a system centred at the receiver point rather than the spource point.
    !    This affects only the cross terms with z.  Gxz(r',r) = -Gxz(r,r')
    !    Gzx(r',r) = -Gxz(r',r)
    !
    !    Thus in what follows, the integration over r is now referred to as the
    !    integration over the source cell rather than the receiver cell due to the
    !    use of the adjoint form.
    !
    !  Weidelt's solution for the induced scattering current Js(r') requies that
    !  the integrated Green's FUNCTION s be computed in the form
    !
    !  Gaa = Saa + Haa /Ksq_bas;  Gab = Sab + Hab /Ksq_bas;
    !                             Gba = Sba + Hba /Ksq_bas  &
    !  Gbb = Sbb + Hbb /Ksq_bas   where  Ksq_bas :=  i * omega * mu / res(basement).
    !
    !  Saa, Sab=Sba, & Sbb are the induced (divergence free) part of the GTE,
    !  corresponding to currents enclosed within the plate.
    !  Haa, Hab, Hba, & Hbb are the curl-free or current channelling part
    !  of the GTE which are closed outside the plate.
    !
    !    OUTPUT:
    !   The inoitial "reversed" Green's FUNCTION s are expressed as:
    !
    !  VAAI (JCR,JCS) - relate the along strike component of the electric field at
    !  SAAI (JCR,JCS)   cell JCR to the along strike component of the scattering
    !                   current of cell JCS
    !
    !  VBAI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBAI (JCR,JCS)   cell JCR due to the along strike component of the
    !                   scattering current of cell JCS
    !
    !  VABI (JCR,JCS) - relate the along strike component of the electric field at
    !  SABI (JCR,JCS)   cell JCR due to the down dip component of the scattering
    !                   current of cell JCS
    !
    !  VBBI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBBI (JCR,JCS)   cell JCR due to the down dip component of the scattering
    !                   current of cell JCS of plate JPS
    !
    !  the  OUTPUT is  Sij and converts Hij such that Hij -> Hij + Ksq_bas * Sij
    !
    !  the forms used by the SUBROUTINE SCAT_MTRX_BUILD
    !
    !  Thus, SAB(KB,JB,JA) is the electric field in the XI-oriented (along-strike)
    !  field at row KB, due to a ETA (down dip)) oriented electric dipole current
    !  integrated over a cell in row JB, column spearation JA.
    !  SAA is the XI electric field due to a XI-oriented dipole.
    !  SBB is the ETA electric field caused by an ETA-oriented electric dipole.
    !  Similarly for VAA, VAB, VBA, & VBB.
    !
    !  In what follows, XI is the coordinate along strike which is defined as a
    !  clockwise rotation (East of North) from the X (North) axis).
    !  ETA is the coordinate down dip.  ETA = X*CDIP + Z*SDIP.
    !  The "reeiver cell" has cell numbers (KB,1) in the (ETA,XI) direction.
    !  The "source cell" has cell numbers (JB,JA) in the (ETA,XI) direction.
    !  Integration is over the source cell.
    !
    !  NAL & NBL are the number of cells along strike and down dip respectively.
    !  DAL & DBL are the corresponding lengths of the cells.
    !  DPTHB is depth to basement.
    !  PLTOP is the distance to the top of the plate and (CDIP, SDIP) refer
    !  to the dip.
    !  A vertical body has these as (0,1) and a flat lying plate as (1,0)
    !  VBBT * VABT are temporary storage variables.
    !
    ! -------------------------------------------------------------------------

    IMPLICIT NONE
    INTEGER, PARAMETER :: NGL=5
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NAL,NBL,NAB,NREGT,NZ2,J1,J2,KB,KA,JB,JA,JB_KB,JA_KA,JAB,KAB
    REAL, DIMENSION(4,NREGT,NZ2) :: GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,GI5Z,GR6Z,GI6Z
    REAL, DIMENSION(NGL) :: GLX,GLW,WGHTA,WGHTB,XI_GL,ETA_GL(NGL)
    REAL RHOTRP(NREGT),ZV2(NZ2),DPTHB,PTOPL,DAL,DALH,DBL,DBLH,CDP,SDP,CPL,SPL,CAZ,SAZ,X, &
         Y,ZTR,RHO,XBAR,XBARSQ,YBAR,YBARSQ,R23(2,3),R32(3,2), &
         XI2D(2),XI3D(3),RCL2D(2),RCL3D(3),ETA0,XI0,WGHTAB
    REAL, DIMENSION(NAB) :: XCELL,YCELL
    COMPLEX, DIMENSION(NBL,NAL) :: SAAD,VAAD,VABD,VBBD
    COMPLEX, DIMENSION(NBL,NBL,NAL,NAL) :: SAA,SBA,SBB,VAA,VAB,VBA,VBB
    COMPLEX GAB(2,2),VAB22(2,2),SAB22(2,2),GXYZ(3,3),RTMP(3,2)
    COMPLEX KSQN,KBASE,AAS,AAV,ABV,BBV,GC1,GC2,GC3,GC4,GC5,GC6

    DATA GLX / -.9061798, -.5384693,    0.,    .5384693, .9061798/
    DATA GLW /  .2369269,  .4786287, .5688888, .4786287, .2369269/

    SAA=ZERO; SBA=ZERO; SBB=ZERO; VAA=ZERO; VAB=ZERO; VBA=ZERO; VBB=ZERO;

    ! Set up propagation constants, integration weights, and interpolation range for
    ! Gauss-Legendre integration in ETA direction at density of 1/5 modified skin depth.

    DALH = DAL / 2.
    DBLH = DBL / 2.
    XI_GL = GLX * DALH
    ETA_GL = GLX * DBLH
    WGHTA = GLW * DALH
    WGHTB = GLW * DBLH  ! Set weight array
    KBASE = SQRT (KSQN)
    IF (REAL (KBASE) < 0) KBASE = -KBASE

    !  The single plate EGT is independent of plate azimuth and horizontal origin.
    !  Set up flat plate with strike along X-axis with origin at the midpoint of
    !  west side

    ! Then compute the direct component for use after indirect component integration.
    ! Since it depends only on the intercell distance and not plate position, it can
    ! be computed directly in plate system, requiring no dip or rotation.
    ! VBA picks up the direct component from VAB further down.

    XI0 = -(NAL + 1) * DALH
    ETA0 =  -DBLH
    DO JB = 1,NBL
       Y = ETA0 + JB * DBL
       DO JA = 1,NAL
          X = XI0 + JA * DAL
          JAB = JA + (JB-1) * NAL
          XCELL(JAB) = X
          YCELL(JAB) = Y

          CALL EGTDIR (JB,JA,KBASE,DAL,DBL,AAS,AAV,ABV,BBV)
          SAAD(JB,JA) = AAS
          VAAD(JB,JA) = AAV
          VBBD(JB,JA) = BBV
          VABD(JB,JA) = ABV
       END DO
    END DO

    !  Compute the rotation matrices for transfer between (X,Y,Z) and (XI,ETA) representations.

    CAZ = 1.
    SAZ = 0.
    CALL RXYZ2PLT (CAZ,SAZ,CDP,SDP,CPL,SPL,R23)
    CALL RPLT2XYZ (CAZ,SAZ,CDP,SDP,CPL,SPL,R32)


    !  ETA, ETAS, ETAR refer to distances down dip from designated top edge of plate.
    !  They are in the "plate" coordinate system and are independent of dip & rotation.
    !  Similarly, XI refers to distances along strike in the "plate" coordinate system.

    DO KB = 1, NBL                      ! receiver cell row loop
       DO JB = KB, NBL                    ! source cell row loop
          DO KA = 1, NAL                    ! receiver cell column loop
             KAB = KA + (KB-1)* NAL
             RCL2D(1) = XCELL(KAB)            ! Pre-rotated coordinates of receiver cell
             RCL2D(2) = YCELL(KAB)
             RCL3D = MATMUL (R32,RCL2D)        ! 3D rotated receiver cell coordinates
             DO JA = KA, NAL
                JAB = JA + (JB-1)* NAL
                SAB22 = ZERO;  VAB22 = ZERO
                DO J1 = 1, NGL
                   XI2D(1) = XI_GL(J1) + XCELL(JAB)
                   DO J2 = 1, NGL
                      WGHTAB = WGHTA(J2) * WGHTB(J1)
                      XI2D(2) = ETA_GL(J2) + YCELL(JAB)
                      XI3D = MATMUL (R32,XI2D)
                      X = XI3D(1) - RCL3D(1)
                      Y = XI3D(2) - RCL3D(2)
                      ZTR = XI3D(3) + RCL3D(3)  + 2.* (PTOPL - DPTHB)

                      RHO = SQRT (X**2 + Y**2)
                      XBAR = 0. ; YBAR = 0.
                      IF (RHO > 0.01) THEN
                         XBAR = X / RHO
                         YBAR = Y / RHO
                      END IF
                      XBARSQ = XBAR**2
                      YBARSQ = YBAR**2

                      GC1 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR1Z,GI1Z,RHO,ZTR)
                      GC2 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR2Z,GI2Z,RHO,ZTR)
                      GC3 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR3Z,GI3Z,RHO,ZTR)
                      GC4 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR4Z,GI4Z,RHO,ZTR)
                      GC5 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR5Z,GI5Z,RHO,ZTR)
                      GC6 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR6Z,GI6Z,RHO,ZTR)

                      GXYZ = ZERO; GAB = ZERO

                      GXYZ(1,1) = (1. - 2.*YBARSQ) * GC4 + YBARSQ * GC1             ! Sxx
                      GXYZ(2,2) = (1. - 2.*XBARSQ) * GC4 + XBARSQ * GC1             ! Syy
                      GXYZ(3,3) = ZERO                                              ! Szz
                      GXYZ(1,2) = XBAR * YBAR * (2.* GC4 - GC1)                     ! Sxy
                      GXYZ(2,1) = GXYZ(1,2)                                         ! Syx

                      RTMP = MATMUL (GXYZ, R32)
                      GAB =  MATMUL (R23, RTMP)
                      SAB22 = SAB22 + WGHTAB * GAB
                      GXYZ = ZERO; GAB = ZERO

                      GXYZ(1,1) = (1. - 2.*XBARSQ) * GC5 + XBARSQ * GC2             ! Vxx
                      GXYZ(2,2) = (1. - 2.*YBARSQ) * GC5 + YBARSQ * GC2             ! Vyy
                      GXYZ(3,3) = -GC3                                              ! Vzz
                      GXYZ(1,2) = XBAR * YBAR * (GC2 - 2.* GC5)                     ! Vxy
                      GXYZ(2,1) = GXYZ(1,2)                                         ! Vyx
                      GXYZ(3,1) = XBAR * GC6                                        ! Vzx
                      GXYZ(3,2) = YBAR * GC6                                        ! Vzy
                      GXYZ(1,3) = -XBAR * GC6                                       ! Vxz
                      GXYZ(2,3) = -YBAR * GC6                                       ! Vyz

                      RTMP = MATMUL (GXYZ, R32)
                      GAB =  MATMUL (R23, RTMP)
                      VAB22 = VAB22 + WGHTAB * GAB
                   END DO

                   SAA(KB,JB,KA,JA) = SAA(KB,JB,KA,JA) + SAB22(1,1)
                   SBA(KB,JB,KA,JA) = SBA(KB,JB,KA,JA) + SAB22(2,1)
                   SBB(KB,JB,KA,JA) = SBB(KB,JB,KA,JA) + SAB22(2,2)
                   VAA(KB,JB,KA,JA) = VAA(KB,JB,KA,JA) + VAB22(1,1)
                   VBB(KB,JB,KA,JA) = VBB(KB,JB,KA,JA) + VAB22(2,2)
                   VAB(KB,JB,KA,JA) = VAB(KB,JB,KA,JA) + VAB22(1,2)
                   VBA(KB,JB,KA,JA) = VBA(KB,JB,KA,JA) + VAB22(2,1)
                END DO               ! JA Loop: 1 to NAL
             END DO                 ! J1 Loop: 1 to NGL down dip
          END DO                   ! KA Loop: 1 to NAL


          !  Add in the direct contributions for JB >= KB & JA >= KA.
          !  Use symmetry to fill in the rest of the matrix.

          !  Symmetry:  VAB = A* Vxy + B* Vxz.  VBA = A* Vxy - B* Vxz = A* Vxy + B* Vzx
          !  Thus under interchange of A (or x) VAB -> -VAB  & VBA -> -VBA
          !  But under interchange of B (or y) VAB -> -VBA  & VBA -> -VAB

          JB_KB = JB - KB + 1
          DO KA = 1,NAL
             DO JA = KA,NAL
                JA_KA = JA - KA + 1

                SAA(KB,JB,KA,JA) = SAA(KB,JB,KA,JA) + SAAD(JB_KB,JA_KA)
                SBB(KB,JB,KA,JA) = SBB(KB,JB,KA,JA) + SAAD(JB_KB,JA_KA)
                VAA(KB,JB,KA,JA) = VAA(KB,JB,KA,JA) + VAAD(JB_KB,JA_KA)
                VBB(KB,JB,KA,JA) = VBB(KB,JB,KA,JA) + VBBD(JB_KB,JA_KA)
                VAB(KB,JB,KA,JA) = VAB(KB,JB,KA,JA) + VABD(JB_KB,JA_KA)
                VBA(KB,JB,KA,JA) = VBA(KB,JB,KA,JA) + VABD(JB_KB,JA_KA)


                SAA(KB,JB,JA,KA) =  SAA(KB,JB,KA,JA)
                SBB(KB,JB,JA,KA) =  SBB(KB,JB,KA,JA)
                VAA(KB,JB,JA,KA) =  VAA(KB,JB,KA,JA)
                VBB(KB,JB,JA,KA) =  VBB(KB,JB,KA,JA)
                SBA(KB,JB,JA,KA) = -SBA(KB,JB,KA,JA)
                VBA(KB,JB,JA,KA) = -VBA(KB,JB,KA,JA)
                VAB(KB,JB,JA,KA) = -VAB(KB,JB,KA,JA)
             END DO
          END DO
       END DO                   ! JB Loop: 1 to NBL

       DO JB = KB+1, NBL
          SAA(JB,KB,1:NAL,1:NAL) =  SAA(KB,JB,1:NAL,1:NAL)
          SBB(JB,KB,1:NAL,1:NAL) =  SAA(KB,JB,1:NAL,1:NAL)
          VAA(JB,KB,1:NAL,1:NAL) =  VAA(KB,JB,1:NAL,1:NAL)
          VBB(JB,KB,1:NAL,1:NAL) =  VBB(KB,JB,1:NAL,1:NAL)
          SBA(JB,KB,1:NAL,1:NAL) = -SBA(KB,JB,1:NAL,1:NAL)
          VAB(JB,KB,1:NAL,1:NAL) = -VBA(KB,JB,1:NAL,1:NAL)
          VBA(JB,KB,1:NAL,1:NAL) = -VAB(KB,JB,1:NAL,1:NAL)
       END DO
    END DO                   ! KB Loop: 1 to NBL

    ! SET UP S-V SUM AND STORE IT IN V.

    VAA = VAA + SAA * KSQN
    VAB = VAB + SBA * KSQN
    VBA = VBA + SBA * KSQN
    VBB = VBB + SBB * KSQN

  END SUBROUTINE EGT_PL_BOSS

  SUBROUTINE EGTDIR (JB,JA,KBASE,DAL,DBL,AAS,AAV,ABV,BBV)
    !-------------------------------------------------------

    !**  Called by EGT_BOSS

    !  Computes the integral of the direct (or full space) Green's
    !  tensor elements over the receiver cell (JB,JA) for a tangential
    !  unit source dipole in cell (1,1).  In the code below, "a" refers
    !  to the strike direction (X axis) and "b" refers to the width
    !  direction ( Y cos(beta) + Z sin(beta) ).  However, for the internals
    !  of the whole space GF computation, "b" may be taken in the Z
    !  direction with no loss of generality.
    !
    !  (A,B) is the distance from the "source dipole" to the centre of the
    !  receiver cell.
    !
    !  C2 :=  KBASE**2 = i * omega * mu / cres(basement)
    !  DAL and DBL are the cell dimensions in the a and b directions respectively.
    !
    !  The integrated Green's FUNCTION s are expressed as:
    ! GAA = AAS + AAV/C2;   GAB = ABV / C2;   GBA = GAB;   GBB = AAS + BBV/C2
    !
    !     Defining Q  as EXP (-KBASE * R) / (4*PI * R), then
    ! AAS = INT {Q} da db       ABV = -Q
    ! AAV = -INT {dQ/da} db     BBV = -INT {dQ/db} da
    !
    ! For same cell integration AAS, = INT (1/r) + INT (exp(-kr) / r  - 1/r)
    !
    !  1/r can be integrated analytically and the second term -> -k as r -> 0


    IMPLICIT NONE
    COMPLEX, PARAMETER :: ZERO=(0.,0.), ONE=(1.,0.), FRPIC=(12.56637, 0.)
    INTEGER, PARAMETER :: NGL=5
    INTEGER JB,JA,J1,J2
    REAL A,B,DAL,DBL,DAH,DBH,XL,XR,ZT,ZB,ASR,RR
    REAL, DIMENSION (NGL) :: GLX,WGL,X,Z,WGX,WGZ
    COMPLEX KBASE,QB,AAS,AAV,BBV,ABV
    LOGICAL PARTS

    INTENT (IN) JB,JA,KBASE,DAL,DBL
    INTENT (OUT) AAS,AAV,ABV,BBV

    DATA GLX / -.9061798, -.5384693, 0., .5384693, .9061798/
    DATA WGL / .2369269, .4786287, .5688888, .4786287, .2369269/

    ! Set inter-cell distance and Gauss-Legendre integration points and
    ! weights.  For the sake of exposition, regarding B as in the Z direction,
    ! B is positive (negative) if 'source" is above (below) receiver cell.
    ! XL and XR will refer to the left and right cell boundaries
    ! and ZT and ZB to the top and bottom boundaries respectively.

    A = DAL* (JA-1)
    B = DBL* (JB-1)
    DAH = DAL / 2.
    DBH = DBL / 2.
    XL = A - DAH
    XR = A + DAH
    ZT = B - DBH
    ZB = B + DBH

    X = A + GLX * DAH
    Z = B + GLX * DBH
    WGX = WGL * DAH
    WGZ = WGL * DBH

    ! Zero out FUNCTION s.  Evaluate ABV analytically.  If same cell or nearest
    ! neighbours, integrate AAV and BBV by parts and subtract 1/R part from
    ! AAS.  Then integrate remainder.  Otherwise, integrate full FUNCTION s.
    ! Z is positive downwards so integrals go from top to bottom
    ! and from left to right of receiver cell.

    AAS = ZERO; AAV = ZERO; BBV = ZERO
    IF ((JA == 1) .OR. (JB == 1)) THEN
       ABV = ZERO
    ELSE
       ABV = Q (KBASE,XL,ZB) + Q (KBASE,XR,ZT) - Q (KBASE,XR,ZB) - Q (KBASE,XL,ZT)
    END IF

    PARTS = .FALSE.
    IF ( JB < 3 .AND. JA < 3) PARTS = .TRUE.
    IF (PARTS) THEN
       AAV = AAVP1 (KBASE,XL,ZT) + AAVP1 (KBASE,XR,ZB) &
            - AAVP1 (KBASE,XR,ZT) - AAVP1 (KBASE,XL,ZB )
       BBV = AAVP1 (KBASE,ZT,XL) + AAVP1 (KBASE,ZB,XR) &
            - AAVP1 (KBASE,ZB,XL) - AAVP1 (KBASE,ZT,XR )
       ASR = RINT (XL,ZT) + RINT (XR,ZB) - RINT (XR,ZT) - RINT (XL,ZB)
       AAS = CMPLX (ASR, 0.)
       DO J1 = 1, NGL
          AAV = AAV + WGZ(J1) * ( AAVP2 (KBASE,XR,Z(J1)) - &
               AAVP2 (KBASE,XL,Z(J1)) )
          BBV = BBV + WGX(J1) * ( AAVP2 (KBASE,ZB,X(J1)) - &
               AAVP2 (KBASE,ZT,X(J1)) )
          DO J2 = 1, NGL
             RR = R (X(J1),Z(J2) )
             QB = - KBASE
             IF (RR > 1.0E-10) QB = (EXP (-KBASE*RR) -ONE) /RR
             AAS = AAS + QB * WGX(J1) * WGZ(J2)
          END DO
       END DO

    ELSE

       DO J1 = 1, NGL
          AAV = AAV + WGZ(J1) * ( DQDX (KBASE,XR,Z(J1)) - DQDX (KBASE,XL,Z(J1)) )
          BBV = BBV + WGX(J1) * ( DQDX (KBASE,ZB,X(J1)) - DQDX (KBASE,ZT,X(J1)) )
          DO J2 = 1, NGL
             AAS = AAS + WGX(J1) * WGZ(J2) * Q (KBASE,X(J1),Z(J2))
          END DO
       END DO
    END IF

    AAS = AAS/ FRPIC;  AAV = AAV/ FRPIC;  ABV = ABV/ FRPIC;  BBV = BBV/ FRPIC

    ! Define in-line whole space FUNCTION s.  RINT is the integral of 1/R.

  CONTAINS

    REAL FUNCTION R(X1,Z1)
      !  ----------------------

      REAL X1,Z1
      R = SQRT (X1*X1 + Z1*Z1)
    END FUNCTION R

    REAL FUNCTION RINT (X1,Z1)
      !  --------------------------

      !  Integral of 1/r dx dz

      REAL X1,Z1,RQ
      RQ = SQRT (X1*X1 + Z1*Z1)
      RINT = Z1* ALOG (RQ + X1) + X1*ALOG (RQ + Z1)
    END FUNCTION RINT

    COMPLEX FUNCTION AAVP1 (KBASE,X1,Z1)
      !  ------------------------------------

      REAL X1,Z1,RQ
      COMPLEX KBASE

      RQ = SQRT (X1*X1 + Z1*Z1)
      AAVP1 = Z1 * EXP (-KBASE*RQ) / (X1*RQ)

    END FUNCTION AAVP1

    COMPLEX FUNCTION AAVP2 (KBASE,X1,Z1)
      !  ------------------------------------

      REAL X1,Z1,RQ
      COMPLEX KBASE

      RQ = SQRT (X1*X1 + Z1*Z1)
      AAVP2 = KBASE * EXP (-KBASE*RQ) / X1

    END FUNCTION AAVP2

    COMPLEX FUNCTION DQDX (KBASE,X1,Z1)
      !  -----------------------------------

      REAL X1,Z1,RQ
      COMPLEX KBASE

      RQ = SQRT (X1*X1 + Z1*Z1)
      DQDX  = (ONE + KBASE*RQ) * EXP (-KBASE*RQ)  * X1 /RQ**3

    END FUNCTION DQDX

    COMPLEX FUNCTION Q (KBASE,X1,Z1)
      !  --------------------------------

      REAL X1,Z1,RQ
      COMPLEX KBASE

      RQ = SQRT (X1*X1 + Z1*Z1)
      Q = EXP (-KBASE*RQ) / RQ

    END FUNCTION Q

  END SUBROUTINE EGTDIR

  SUBROUTINE EGT_CSPL (NREGT,RHOTRP,NLYR,THKD,RMUD,SIGL,KSQL,ZTR,GR1,GI1, &
       GR2,GI2,GR3,GI3,GR4,GI4,GR5,GI5,GR6,GI6)
    !----------------------------------------------------------------------

    !***  Calls EGT_HNK, CUBSPL
    !***  Called by SCAT_MTRX_BOSS

    ! Sets up cubic spline representations, GRj & GIj (j = 1,6), for the five
    ! Hankel integrals needed to compute the electric Green's tensor elements
    ! as a FUNCTION of RHOTRP.

    !   RHOTRP - interpolation array of rho values
    !    NREGT - number of interpolation points needed for EGT
    !     NLYR - number of layers
    !     THKD - array of layer thicknesses
    !     RMUD - relative permeability of layers
    !     SIGL - complex resistivity of layers
    !     KSQL - propagation constants
    !      ZTR = the reflected distance between "source" & "receiver"
    !            points off bottom of overburden.

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    INTEGER JR,NREGT,NLYR
    REAL, DIMENSION (4,NREGT) :: GR1,GI1,GR2,GI2,GR3,GI3,GR4,GI4,GR5,GI5,GR6,GI6
    REAL RHOTRP(NREGT),ZTR
    REAL (KIND=QL) RMUD(0:NLYR),THKD(NLYR)
    COMPLEX(KIND=QL) KSQL(NLYR),SIGL(NLYR),EHRI(NREGT,6)

    GR1 = 0; GR2 = 0; GR3 = 0; GR4 = 0; GR5 = 0; GR6 = 0
    GI1 = 0; GI2 = 0; GI3 = 0; GI4 = 0; GI5 = 0; GI6 = 0

    CALL EGT_HNK (NREGT,RHOTRP,NLYR,THKD,RMUD,SIGL,KSQL,ZTR,EHRI)

    DO JR = 1, NREGT
       GR1(1,JR) = REAL (EHRI(JR,1), 4)
       GI1(1,JR) = REAL (AIMAG (EHRI(JR,1)), 4)
       GR2(1,JR) = REAL (EHRI(JR,2), 4)
       GI2(1,JR) = REAL (AIMAG (EHRI(JR,2)), 4)
       GR3(1,JR) = REAL (EHRI(JR,3), 4)
       GI3(1,JR) = REAL (AIMAG (EHRI(JR,3)), 4)
       GR4(1,JR) = REAL (EHRI(JR,4), 4)
       GI4(1,JR) = REAL (AIMAG (EHRI(JR,4)), 4)
       GR5(1,JR) = REAL (EHRI(JR,5), 4)
       GI5(1,JR) = REAL (AIMAG (EHRI(JR,5)), 4)
       GR6(1,JR) = REAL (EHRI(JR,6), 4)
       GI6(1,JR) = REAL (AIMAG (EHRI(JR,6)), 4)
    END DO

    CALL CUBSPL (RHOTRP,GR1,NREGT)
    CALL CUBSPL (RHOTRP,GI1,NREGT)
    CALL CUBSPL (RHOTRP,GR2,NREGT)
    CALL CUBSPL (RHOTRP,GI2,NREGT)
    CALL CUBSPL (RHOTRP,GR3,NREGT)
    CALL CUBSPL (RHOTRP,GI3,NREGT)
    CALL CUBSPL (RHOTRP,GR4,NREGT)
    CALL CUBSPL (RHOTRP,GI4,NREGT)
    CALL CUBSPL (RHOTRP,GR5,NREGT)
    CALL CUBSPL (RHOTRP,GI5,NREGT)
    CALL CUBSPL (RHOTRP,GR6,NREGT)
    CALL CUBSPL (RHOTRP,GI6,NREGT)

  END SUBROUTINE EGT_CSPL

  SUBROUTINE EGT_HNK (NRHO,RHOTRP,NLYR,THKD,RMUD,SIGL,KSQL,ZTR,EHRI)
    !-----------------------------------------------------------------

    !***  Called by EGT_CSPL
    !***  Calls EGT_KER

    ! Sets up the five integrals EHRI (JR,J1), J1 = 1,6, needed to compute the
    ! electric Green's tensor elements in EGT_BOSS.  It uses the flow through
    ! Hankel transform method to compute values at RHOTRP(JR), (15 point per decade
    ! spacing).  It uses a 15 point per decade filter coefficient set derived from
    ! Christensen's program, FLTGEN.

    !   RHOTRP - interpolation array of rho values
    !     NRHO - number of interpolation points needed for EGT
    !     THKD - array of layer thicknesses
    !     RMUD - relative permeability of layers
    !     SIGL - complex resistivity of layers
    !     KSQL - propagation constants
    !      ZTR = the reflected distance between "source" & "receiver"
    !            points off bottom of overburden.
    !     EHRI - inverse Hankel transform (J = 1,6)

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL(KIND=QL), PARAMETER :: FOURPI=12.56637_QL
    COMPLEX (KIND=QL), PARAMETER :: ZERO=(0._QL, 0._QL)
    INTEGER NLYR,NRHO,L,JR,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1
    REAL RHOTRP(NRHO),ZTR
    REAL(KIND=QL) DELTA,Y1,Y,RD,RMUD(0:NLYR),THKD(NLYR),LMBDA,ZTRD,RHOD
    COMPLEX(KIND=QL) KSQL(NLYR),SIGL(NLYR),KER(JNLO-NRHO:JNHI,6),EHRI(NRHO,6)
    LOGICAL JUMP

    ZTRD = REAL (ZTR,QL)

    EHRI = ZERO
    KER = ZERO
    DELTA = LOG (10._QL)/ REAL (NDEC_JN,QL)

    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = REAL (RHOTRP(1),QL)
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA -  SHFTJN

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       CALL EGT_KER (NRHO,K,JR,L,LMBDA,NLYR,THKD,RMUD,SIGL,KSQL,ZTRD,KER,EHRI,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL EGT_KER (NRHO,K,JR,L,LMBDA,NLYR,THKD,RMUD,SIGL,KSQL,ZTRD,KER,EHRI,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRHO)

    JR = NRHO
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - SHFTJN
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.
       IF (L > JNHI .OR. L < JNLO) CYCLE
       EHRI(JR,1:3) = EHRI(JR,1:3) + KER(K,1:3) * WJ0(L)
       EHRI(JR,4:6) = EHRI(JR,4:6) + KER(K,4:6) * WJ1(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (Y)
          CALL EGT_KER (NRHO,K,JR,L,LMBDA,NLYR,THKD,RMUD,SIGL,KSQL,ZTRD,KER,EHRI,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRHO-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          IF (L > JNHI .OR. L < JNLO) CYCLE
          EHRI(JR,1:3) = EHRI(JR,1:3) + KER(K,1:3) * WJ0(L)
          EHRI(JR,4:6) = EHRI(JR,4:6) + KER(K,4:6) * WJ1(L)
       END DO
    END DO

    DO JR = 1,NRHO
       RHOD = REAL (RHOTRP(JR),KIND=QL)
       EHRI(JR,4:5) = EHRI(JR,4:5) / RHOD
       EHRI(JR,1:6) = EHRI(JR,1:6) / (FOURPI * RHOD)
    END DO
  END SUBROUTINE EGT_HNK

  SUBROUTINE EGT_KER (NRHO,K,JR,L,LMBDA,NLYR,THKD,RMUD,SIGL,KSQL,ZTRD,KER,EHRI,JUMP)
    !---------------------------------------------------------------------------------

    !***  Called by EGT_HNK

    ! Accumulates the integrals for EHRI(J), the five inverse Hankel transforms
    ! needed for evaluation of Green's tensor elements

    !     NRHO - number of points in 15 point / decade array
    !        K - filter kernel index
    !       JR - RHO interpolation index
    !        L - filter point index
    !    LMBDA - Hankel transform variable
    !     NLYR - number of layers
    !     THKD - array of layer thicknesses
    !     RMUD - relative permeability of layers
    !     SIGL - complex resistivity of layers
    !     KSQL - propagation constants
    !     ZTRD = (ZS - THKD) + (ZR - THKD) = the reflected distance between
    !                 "source" & "receiver" points off bottom of overburden.
    !      KER - stored integral kernels
    !  EHRI(J) - accumulated complex integrals for inverse Hankel transform (J = 1,6)
    !     JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX (KIND=QL), PARAMETER :: ONE = (1._QL,0._QL)
    INTEGER NRHO,K,JR,L,NLYR,J
    REAL (KIND=QL) LMBDA,THKD(NLYR),RMUD(0:NLYR),RMUSQ(NLYR),ZTRD,EHR,EHI,AR,AI
    COMPLEX (KIND=QL) LMBSQ,SN,EHRI(NRHO,6),KER(JNLO-NRHO:JNHI,6),G,ETA,KS,KV,TXP2,TMP(6)
    COMPLEX (KIND=QL), DIMENSION(NLYR) :: SIGL,KSQL,CHI,AF,AG
    COMPLEX (KIND=QL), DIMENSION(0:NLYR) :: S,R,T
    LOGICAL TOO_BIG,JUMP

    LMBSQ = CMPLX (LMBDA * LMBDA, 0._QL, KIND=QL)
    S(0) = CMPLX (LMBDA, 0._QL,KIND=QL)
    DO J = 1,NLYR
       S(J) = SQRT (KSQL(J) + LMBSQ)
       RMUSQ(J) = RMUD(J) * RMUD(J)
    END DO
    SN = S(NLYR)
    T(0) = ( (RMUSQ(1) - 1._QL) * LMBSQ - KSQL(1) ) / ( RMUD(1)*S(0) + S(1) )**2
    R(0) = ONE
    DO J = 1,NLYR-1
       T(J) = (RMUSQ(J+1) - RMUSQ(J)) * LMBSQ + (RMUSQ(J+1) * KSQL(J) - RMUSQ(J) * KSQL(J+1)) &
            / (RMUD(J+1) * S(J) + RMUD(J) * S(J+1))**2
       R(J) = (SIGL(J+1) * S(J) - SIGL(J) * S(J+1)) / (SIGL(J+1) * S(J) + SIGL(J) * S(J+1))
       CHI(J) = EXP (-2._QL * S(J) * THKD(J))
    END DO

    AF(1) = -R(0)           ! ref SUBROUTINE EDSX_COEF
    AG(1) = -T(0)
    DO J = 1, NLYR-1
       AF(J+1) = (AF(J) * CHI(J) - R(J)) / (ONE -  R(J) * AF(J) * CHI(J))
       AG(J+1) = (AG(J) * CHI(J) - T(J)) / (ONE -  T(J) * AG(J) * CHI(J))
    END DO

    TXP2 = EXP (-SN * ZTRD)
    G   = TXP2 * AF(NLYR)
    ETA = TXP2 * AG(NLYR)
    KS = ETA / SN
    KV = -G * SN

    KER(K,1) = KS * LMBDA             ! Sxx, Syx, Syy, Sxy
    KER(K,2) = KV * LMBDA             ! Vxx, Vyx, Vyy, Vyx
    KER(K,3) = G   * LMBDA**3 / SN    ! Vzz
    KER(K,4) = KS                     ! Sxx, Syx, Syy, Sxy
    KER(K,5) = KV                     ! Vxx, Vyx, Vyy, Vyx
    KER(K,6) = G   * LMBSQ            ! Vzx

    TMP(1:3) = WJ0(L) * KER(K,1:3)
    TMP(4:6) = WJ1(L) * KER(K,4:6)

    JUMP = .TRUE.
    DO J = 1,6
       EHRI(JR,J) = EHRI(JR,J) + TMP(J)
       AR = ABS (REAL (TMP(J)))
       AI = ABS (AIMAG (TMP(J)))
       EHR = ABS (REAL (EHRI(JR,J)))
       EHI = ABS (AIMAG (EHRI(JR,J)))
       TOO_BIG = .FALSE.
       IF (AR > TOL* EHR) TOO_BIG = .TRUE.
       IF (AI > TOL* EHI) TOO_BIG = .TRUE.
       IF (TOO_BIG) JUMP = .FALSE.
    END DO
  END SUBROUTINE EGT_KER

  SUBROUTINE EGT_UL_BOSS (NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NAL,NBL,NAB,DAL,DBL,XCEL1,YCEL1, &
       ZC1L,RXLYR,CDP,SDP,NREGT,RHOTRP,SAA,SBA,SBB,VAA,VAB,VBA,VBB)
    ! --------------------------------------------------------------------------------------

    !***  Calls EGTDIR
    !***  Called by SCAT_MTRX_BOSS

    !         INPUT
    !         -----
    !
    !     NBL,NAL - number of cell rows and columns respectively
    !     DBL,DAL - cell dimensions down dip and along strike respectively
    !        KSQL - propagation constant for layers
    !       DPTHL - depth to top of each layer
    !    CDP, SDP - dip cosine and sine
    !    XCEL1,YCEL1,ZC1L - X,Y,Z coordinates of cells on plate
    !    RHOTRP - array of NREGT logrithmically spaced points used for horizontalal interpolation
    !
    !         OUPUT
    !         ------
    !
    !    SAA, SBB, SBA - divergence free integrated Green's tensor elements
    !    VAA, VBB, VAB, VBA - curl free integrated Green's tensor elements
    !                         A => along strike
    !                         B => down dip
    !
    !  EGT_BOSS computes the integrals over the "source" cell of the Green's tensor
    !  elements ( GTE ) for single plates contained in a uniform half-space or
    !  entirely inthe bottom layer of a two layer half-space.  The direct portion is
    !  computed separately from the reflected/transmitted scattered terms.

    !  In what follows, the GTE have the units of electric field divided by a
    !  factor (-iwu) because this factor is explicitly included as a multiplier
    !  outside the integral over area when solving the integral equation.
    !
    !  In the formulation the integrated Green's tensor G relates the field at r'
    !  to the current at r by
    !                                           _                      _
    !                                          |  Gaa(r.r')  Gab(r.r')  |
    !  { Ea(r'), Eb(r') } =  { Ja(r), Jb(r) }  |                        |
    !                                          |  Gba(r.r')  Gbb(r.r')  |
    !                                          |_                      _|
    !
    !  These GTE, Gij were derived by computing the i'th component of the field at r
    !  due to a j-oriented unit electric dipole at r'.  The integral of the GTE is
    !  over r so we have the contradiction of designating the cells over which we
    !  integrate the product of the GTE and scattering curent as the receiver cells
    !  and the cell where we evaluate the field as the source cell.  Let's change
    !  this by first putting the above form into the more expected operator form by
    !  writing the GTE matrix in transposed form as:
    !
    !   _        _       _                      _    _       _
    !  |  Ea(r')  |     |  Gaa(r,r')  Gba(r,r')  |  |  Ja(r)  |
    !  |          |  =  |                        |  |         |
    !  |  Eb(r')  |     |  Gab(r,r')  Gbb(r,r')  |  |  Jb(r)  |
    !  |_        _|     |_                      _|  |_       _|
    !
    !
    !  Using the self-adjoint nature of the GTE, we can rewrite this as the transpose
    !  by switching the role of "source" and "receiver" in the GTE.
    !
    !
    !   _        _        _                       _    _       _
    !  |  Ea(r')  |      |   Gaa(r',r)  Gab(r',r)  |  |  Ja(r)  |
    !  |          |   =  |                         |  |         |
    !  |  Eb(r')  |      |   Gba(r',r)  Gbb(r',r)  |  |  Jb(r)  |
    !  |_        _|      |_                       _|  |_       _|
    !
    !    Now, Gij(r',r) = i'th component at r' due to j-oriented source at r
    !    Thus the second operator form relates the observed field at r'
    !    to the source at r in the more expected way

    !    Although the Gij are computed initially as the received field at r due to
    !    a source at r', the expression above requires that the Gij are to be used
    !    in a system centred at the receiver point rather than the spource point.
    !    This affects only the cross terms with z.  Gxz(r',r) = -Gxz(r,r')
    !    Gzx(r',r) = -Gxz(r',r)
    !
    !    Thus in what follows, the integration over r is now referred to as the
    !    integration over the source cell rather than the receiver cell due to the
    !    use of the adjoint form.
    !
    !  Weidelt's solution for the induced scattering current Js(r') requies that
    !  the integrated Green's FUNCTION s be computed in the form
    !
    !  Gaa = Saa + Haa /Ksq_bas;  Gab = Sab + Hab /Ksq_bas;
    !                             Gba = Sba + Hba /Ksq_bas  &
    !  Gbb = Sbb + Hbb /Ksq_bas   where  Ksq_bas :=  i * omega * mu / res(basement).
    !
    !  Saa, Sab=Sba, & Sbb are the induced (divergence free) part of the GTE,
    !  corresponding to currents enclosed within the plate.
    !  Haa, Hab, Hba, & Hbb are the curl-free or current channelling part
    !  of the GTE which are closed outside the plate.
    !
    !    OUTPUT:
    !   The inoitial "reversed" Green's FUNCTION s are expressed as:
    !
    !  VAAI (JCR,JCS) - relate the along strike component of the electric field at
    !  SAAI (JCR,JCS)   cell JCR to the along strike component of the scattering
    !                   current of cell JCS
    !
    !  VBAI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBAI (JCR,JCS)   cell JCR due to the along strike component of the
    !                   scattering current of cell JCS
    !
    !  VABI (JCR,JCS) - relate the along strike component of the electric field at
    !  SABI (JCR,JCS)   cell JCR due to the down dip component of the scattering
    !                   current of cell JCS
    !
    !  VBBI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBBI (JCR,JCS)   cell JCR due to the down dip component of the scattering
    !                   current of cell JCS of plate JPS
    !
    !  the  OUTPUT is  Sij and converts Hij such that Hij -> Hij + Ksq_bas * Sij
    !
    !  the forms used by the SUBROUTINE SCAT_MTRX_BUILD
    !
    !  Symmetry is used to reduce computation.  If the source is in row JB and the
    !  receiver point in row KB, the GTE will be FUNCTION of horizontal separation
    !  (translation independent).  In what follows, KB and JB are the row indices
    !  of the receiver and source cells respectively.  JA is a column index
    !  denoting horizontal separation.
    !
    !  Thus, SAB(KB,JB,JA) is the electric field in the XI-oriented (along-strike)
    !  field at row KB, due to a ETA (down dip)) oriented electric dipole current
    !  integrated over a cell in row JB, column spearation JA.
    !  SAA is the XI electric field due to a XI-oriented dipole.
    !  SBB is the ETA electric field caused by an ETA-oriented electric dipole.
    !  Similarly for VAA, VAB, VBA, & VBB.
    !
    !  In what follows, XI is the coordinate along strike which is defined as a
    !  clockwise rotation (East of North) from the X (North) axis).
    !  ETA is the coordinate down dip.  ETA = X*CDIP + Z*SDIP.
    !  The "reeiver cell" has cell numbers (KB,1) in the (ETA,XI) direction.
    !  The "source cell" has cell numbers (JB,JA) in the (ETA,XI) direction.
    !  Integration is over the source cell.
    !
    !  NAL & NBL are the number of cells along strike and down dip respectively.
    !  DAL & DBL are the corresponding lengths of the cells.
    !  PLTOP is the distance to the top of the plate and (CDIP, SDIP) refer
    !  to the dip.
    !  A vertical body has these as (0,1) and a flat lying plate as (1,0)
    !  VBBT * VABT are temporary storage variables.
    !
    ! -------------------------------------------------------------------------

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80), NGL=5
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NAL,NBL,NAB,NREGT,NLYR,SXLYR,RXLYR,KFG,J1,J2,KB,KA,JB,JA,JB_KB,JA_KA,JAB,KAB
    REAL, DIMENSION(4,NREGT) :: GR1,GI1,GR2,GI2,GR3,GI3,GR4,GI4,GR5,GI5,GR6,GI6,GR7,GI7
    REAL, DIMENSION(NGL) :: GLX,GLW,WGHTA,WGHTB,XI_GL,ETA_GL(NGL)
    REAL RHOTRP(NREGT),DAL,DALH,DBL,ZC1L(NBL),CDP,SDP,CAZ,SAZ,X,XC,XGL,Y,YC,YGL, &
         ZGL,RHO,XBAR,XBARSQ,YBAR,YBARSQ,R23(2,3),R32(3,2)
    REAL, DIMENSION(NAB) :: XCEL1,YCEL1
    REAL (KIND=QL) RMUD(0:NLYR),THKD(NLYR),DPTHL(NLYR),ZR,ZS
    COMPLEX, DIMENSION(NBL,NAL) :: SAAD,VAAD,VABD,VBBD
    COMPLEX, DIMENSION(NBL,NBL,NAL,NAL) :: SAA,SBA,SBB,VAA,VAB,VBA,VBB
    COMPLEX GAB(2,2),VAB22(2,2),SAB22(2,2),GXYZ(3,3),RTMP(3,2)
    COMPLEX KSQN,KBASE,AAS,AAV,ABV,BBV,GC1,GC2,GC3,GC4,GC5,GC6,GC7
    COMPLEX(KIND=QL) KSQL(NLYR),SIGL(NLYR)

    DATA GLX / -.9061798, -.5384693,    0.,    .5384693, .9061798/
    DATA GLW /  .2369269,  .4786287, .5688888, .4786287, .2369269/

    SAA=ZERO; SBA=ZERO; SBB=ZERO; VAA=ZERO; VAB=ZERO; VBA=ZERO; VBB=ZERO;

    ! Set up propagation constants, integration weights, and interpolation range for
    ! Gauss-Legendre integration in ETA direction at density of 1/5 modified skin depth.

    IF (RXLYR == NLYR) THEN
       WRITE(4,1); WRITE(*,1)
       STOP
    END IF
    SXLYR = RXLYR
    KFG = 211

    CAZ = 1.
    SAZ = 0.
    CALL RXYZ2PLT (CAZ,SAZ,CDP,SDP,1.,0.,R23)
    CALL RPLT2XYZ (CAZ,SAZ,CDP,SDP,1.,0.,R32)

    ETA_GL(1:NGL) = GLX(1:NGL) * DBL /2.
    DALH = DAL / 2.
    WGHTB = GLW * DBL /2.                         ! Set weight array for cells in basement

    ! Compute the direct (or full space) Green's tensor elements over the receiver
    ! cell (JB,JA) for a tangential unit source dipole in cell (1,1).  Because it
    ! depends only on the intercell distance and not plate position, it can be
    ! computed directly in plate system, requiring no rotation.

    KSQN = CMPLX (KSQL(RXLYR))
    KBASE = SQRT (KSQN)                        !  Direct term for layer RXLYR
    IF (REAL (KBASE) < 0) KBASE = -KBASE
    DO JB = 1, NBL
       DO JA = 1,NAL
          CALL EGTDIR (JB,JA,KBASE,DAL,DBL,AAS,AAV,ABV,BBV)
          SAAD(JB,JA) = AAS
          VAAD(JB,JA) = AAV
          VBBD(JB,JA) = BBV
          VABD(JB,JA) = ABV
       END DO
    END DO

    ! Plunge must = 0 for this SUBROUTINE to be called.
    ! Index cell depth as a FUNCTION of row number.

    !  ETA, ETAS, ETAR refer to distances down dip from designated top edge of plate.
    !  They are in the "plate" coordinate system and are independent of dip & rotation.
    !  Similarly, XI refers to distances along strike in the "plate" coordinate system.

    DO KB = 1, NBL                                  ! receiver cell row loop
       ZR = ZC1L(KB)
       DO JB = KB, NBL                               ! source cell row loop
          DO J1 = 1, NGL
             YGL = ETA_GL(J1) * CDP
             ZGL = ETA_GL(J1) * SDP
             ZS = ZC1L(JB) + ZGL
             CALL EGT_UL_CSPL (NREGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZS,ZR, &
                  GR1,GI1,GR2,GI2,GR3,GI3,GR4,GI4,GR5,GI5,GR6,GI6,GR7,GI7)
             KA = 1
             KAB = KA + (KB-1)* NAL
             JAB = KA + (JB-1)* NAL
             XC = XCEL1(JAB) - XCEL1(KAB)
             YC = YCEL1(JAB) - YCEL1(KAB)

             Y = YC + YGL

             XI_GL = (GLX + 1.) * DALH / 2.
             WGHTA = GLW * DAL /4.  ! Set weight array

             SAB22 = ZERO;  VAB22 = ZERO
             DO J2 = 1,NGL
                XGL =  XI_GL(J2)
                X = XC  + XGL

                RHO = SQRT (X**2 + Y**2)
                XBAR = X / RHO
                XBARSQ = XBAR**2
                YBAR = Y / RHO
                YBARSQ = YBAR**2

                CALL CCUBVAL(RHOTRP,NREGT,GR1,GI1,RHO,GC1)
                CALL CCUBVAL(RHOTRP,NREGT,GR2,GI2,RHO,GC2)
                CALL CCUBVAL(RHOTRP,NREGT,GR3,GI3,RHO,GC3)
                CALL CCUBVAL(RHOTRP,NREGT,GR4,GI4,RHO,GC4)
                CALL CCUBVAL(RHOTRP,NREGT,GR5,GI5,RHO,GC5)

                GXYZ = ZERO; GAB = ZERO

                GXYZ(1,1) = (1. - 2.* YBARSQ) * GC4 + YBARSQ * GC1        ! Sxx
                GXYZ(2,2) = (1. - 2.* XBARSQ) * GC4 + XBARSQ * GC1        ! Syy
                GXYZ(3,3) = ZERO                                          ! Szz

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)
                SAB22 = SAB22 + WGHTA(J2) * GAB

                GXYZ = ZERO; GAB = ZERO

                GXYZ(1,1) = (1. - 2.*XBARSQ) * GC5 + XBARSQ * GC2             ! Vxx
                GXYZ(2,2) = (1. - 2.*YBARSQ) * GC5 + YBARSQ * GC2             ! Vyy
                GXYZ(3,3) = -GC3                                              ! Vzz

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)
                VAB22 = VAB22 + WGHTA(J2) * GAB
             END DO

             SAA(KB,JB,KA,KA) = SAA(KB,JB,KA,KA) + 2. * WGHTB(J1) * SAB22(1,1)
             SBA(KB,JB,KA,KA) = SBA(KB,JB,KA,KA) + 2. * WGHTB(J1) * SAB22(2,1)
             SBB(KB,JB,KA,KA) = SBB(KB,JB,KA,KA) + 2. * WGHTB(J1) * SAB22(2,2)
             VAA(KB,JB,KA,KA) = VAA(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(1,1)
             VBB(KB,JB,KA,KA) = VBB(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(2,2)
             VAB(KB,JB,KA,KA) = VAB(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(1,2)
             VBA(KB,JB,KA,KA) = VBA(KB,JB,KA,KA) + 2. * WGHTB(J1) * VAB22(2,1)

             XI_GL = GLX * DALH
             WGHTA = GLW * DALH                      ! Set weight array
             DO JA = KA+1, NAL                       ! receiver cell column loop
                JAB = JA + (JB-1)* NAL

                XC = XCEL1(JAB) - XCEL1(KAB)
                YC = YCEL1(JAB) - YCEL1(KAB)

                Y = YC + YGL

                SAB22 = ZERO;  VAB22 = ZERO
                DO J2 = 1, NGL
                   XGL =  XI_GL(J2)
                   X = XC  + XGL

                   RHO = SQRT (X**2 + Y**2)
                   XBAR = X / RHO
                   YBAR = Y / RHO
                   XBARSQ = XBAR**2
                   YBARSQ = YBAR**2

                   CALL CCUBVAL(RHOTRP,NREGT,GR1,GI1,RHO,GC1)
                   CALL CCUBVAL(RHOTRP,NREGT,GR2,GI2,RHO,GC2)
                   CALL CCUBVAL(RHOTRP,NREGT,GR3,GI3,RHO,GC3)
                   CALL CCUBVAL(RHOTRP,NREGT,GR4,GI4,RHO,GC4)
                   CALL CCUBVAL(RHOTRP,NREGT,GR5,GI5,RHO,GC5)
                   CALL CCUBVAL(RHOTRP,NREGT,GR6,GI6,RHO,GC6)
                   CALL CCUBVAL(RHOTRP,NREGT,GR7,GI7,RHO,GC7)

                   GXYZ = ZERO; GAB = ZERO

                   GXYZ(1,1) = (1. - 2.* YBARSQ) * GC4 + YBARSQ * GC1            ! Sxx
                   GXYZ(2,2) = (1. - 2.* XBARSQ) * GC4 + XBARSQ * GC1            ! Syy
                   GXYZ(3,3) = ZERO                                              ! Szz
                   GXYZ(1,2) = XBAR * YBAR * (2.* GC4 - GC1)                     ! Sxy
                   GXYZ(2,1) = GXYZ(1,2)                                         ! Syx

                   RTMP = MATMUL (GXYZ, R32)
                   GAB =  MATMUL (R23, RTMP)
                   SAB22 = SAB22 + WGHTA(J2) * GAB
                   GXYZ = ZERO; GAB = ZERO

                   GXYZ(1,1) = (1. - 2.*XBARSQ) * GC5 + XBARSQ * GC2             ! Vxx
                   GXYZ(2,2) = (1. - 2.*YBARSQ) * GC5 + YBARSQ * GC2             ! Vyy
                   GXYZ(3,3) = -GC3                                              ! Vzz
                   GXYZ(1,2) = XBAR * YBAR * (GC2 - 2.* GC5)                     ! Vxy
                   GXYZ(2,1) = GXYZ(1,2)                                         ! Vxy
                   GXYZ(3,1) = XBAR * GC6                                        ! Vzx
                   GXYZ(3,2) = YBAR * GC6                                        ! Vzy
                   GXYZ(1,3) = XBAR * GC7                                      ! Vxz
                   RTMP = MATMUL (GXYZ, R32)
                   GAB =  MATMUL (R23, RTMP)
                   VAB22 = VAB22 + WGHTA(J2) * GAB
                END DO

                SAA(KB,JB,KA,JA) = SAA(KB,JB,KA,JA) + WGHTB(J1) * SAB22(1,1)
                SBA(KB,JB,KA,JA) = SBA(KB,JB,KA,JA) + WGHTB(J1) * SAB22(2,1)
                SBB(KB,JB,KA,JA) = SBB(KB,JB,KA,JA) + WGHTB(J1) * SAB22(2,2)
                VAA(KB,JB,KA,JA) = VAA(KB,JB,KA,JA) + WGHTB(J1) * VAB22(1,1)
                VBB(KB,JB,KA,JA) = VBB(KB,JB,KA,JA) + WGHTB(J1) * VAB22(2,2)
                VAB(KB,JB,KA,JA) = VAB(KB,JB,KA,JA) + WGHTB(J1) * VAB22(1,2)
                VBA(KB,JB,KA,JA) = VBA(KB,JB,KA,JA) + WGHTB(J1) * VAB22(2,1)
             END DO                   ! JA Loop: 1 to NAL
          END DO                   ! J1 Loop: 1 to NGL down dip

          !  Fill in KA-JA values for JA >= KA

          DO KA = 2,NAL
             DO JA = KA,NAL
                JA_KA = JA - KA + 1
                SAA(KB,JB,KA,JA) = SAA(KB,JB,1,JA_KA)
                SBB(KB,JB,KA,JA) = SBB(KB,JB,1,JA_KA)
                VAA(KB,JB,KA,JA) = VAA(KB,JB,1,JA_KA)
                VBB(KB,JB,KA,JA) = VBB(KB,JB,1,JA_KA)
                SBA(KB,JB,KA,JA) = SBA(KB,JB,1,JA_KA)
                VBA(KB,JB,KA,JA) = VBA(KB,JB,1,JA_KA)
                VAB(KB,JB,KA,JA) = VAB(KB,JB,1,JA_KA)
             END DO
          END DO

          !  Add in the direct contributions if both Tx & Rx are in basement (KB > 1)
          !  or if both in layer above basement (JB = KB = 1)

          JB_KB = JB - KB + 1
          DO KA = 1,NAL
             DO JA = KA,NAL
                JA_KA = JA - KA + 1

                SAA(KB,JB,KA,JA) = SAA(KB,JB,KA,JA) + SAAD(JB_KB,JA_KA)
                SBB(KB,JB,KA,JA) = SBB(KB,JB,KA,JA) + SAAD(JB_KB,JA_KA)
                VAA(KB,JB,KA,JA) = VAA(KB,JB,KA,JA) + VAAD(JB_KB,JA_KA)
                VBB(KB,JB,KA,JA) = VBB(KB,JB,KA,JA) + VBBD(JB_KB,JA_KA)
                VAB(KB,JB,KA,JA) = VAB(KB,JB,KA,JA) + VABD(JB_KB,JA_KA)
                VBA(KB,JB,KA,JA) = VBA(KB,JB,KA,JA) + VABD(JB_KB,JA_KA)

                !  Use horizontal symmetry to fill in the cell row aspect of the matrix.

                SAA(KB,JB,JA,KA) =  SAA(KB,JB,KA,JA)
                SBB(KB,JB,JA,KA) =  SBB(KB,JB,KA,JA)
                VAA(KB,JB,JA,KA) =  VAA(KB,JB,KA,JA)
                VBB(KB,JB,JA,KA) =  VBB(KB,JB,KA,JA)
                SBA(KB,JB,JA,KA) = -SBA(KB,JB,KA,JA)
                VBA(KB,JB,JA,KA) = -VBA(KB,JB,KA,JA)
                VAB(KB,JB,JA,KA) = -VAB(KB,JB,KA,JA)
             END DO
          END DO
       END DO                   ! JB Loop: 1 to NBL

       DO JB = KB+1, NBL
          SAA(JB,KB,1:NAL,1:NAL) =  SAA(KB,JB,1:NAL,1:NAL)
          SBB(JB,KB,1:NAL,1:NAL) =  SAA(KB,JB,1:NAL,1:NAL)
          VAA(JB,KB,1:NAL,1:NAL) =  VAA(KB,JB,1:NAL,1:NAL)
          VBB(JB,KB,1:NAL,1:NAL) =  VBB(KB,JB,1:NAL,1:NAL)
          SBA(JB,KB,1:NAL,1:NAL) = -SBA(KB,JB,1:NAL,1:NAL)
          VAB(JB,KB,1:NAL,1:NAL) = -VBA(KB,JB,1:NAL,1:NAL)
          VBA(JB,KB,1:NAL,1:NAL) = -VAB(KB,JB,1:NAL,1:NAL)
       END DO
    END DO                   ! KB Loop: 1 to NBL

    ! SET UP S-V SUM AND STORE IT IN V.

    VAA = VAA + SAA * KSQN
    VAB = VAB + SBA * KSQN
    VBA = VBA + SBA * KSQN
    VBB = VBB + SBB * KSQN

1   FORMAT (T3,' An evil spirit has entered EGT_UL_BOSS.  Seek help !')

  END SUBROUTINE EGT_UL_BOSS

  SUBROUTINE EGT_UL_CSPL (NREGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZS, &
       ZR,QR1,QI1,QR2,QI2,QR3,QI3,QR4,QI4,QR5,QI5,QR6,QI6,QR7,QI7)
    !--------------------------------------------------------------------------------------------

    !***  Calls EGT_HNK, CUBSPL
    !***  Called by SCAT_MTRX_BOSS

    ! Sets up cubic spline representations, QRj & QIj (j = 1,6), for the five
    ! Hankel integrals needed to compute the electric Green's tensor elements
    ! as a FUNCTION of RHOTRP.

    !   RHOTRP - interpolation array of rho values
    !    NREGT - number of interpolation points needed for EGT
    !     NLYR - number of layers
    !     THKD - array of layer thicknesses
    !     RMUD - relative permeability of layers
    !     SIGL - complex resistivity of layers
    !     KSQL - propagation constants

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    INTEGER JR,NREGT,NLYR,SXLYR,RXLYR,KFG
    REAL, DIMENSION (4,NREGT) :: QR1,QI1,QR2,QI2,QR3,QI3,QR4,QI4,QR5,QI5,QR6,QI6,QR7,QI7
    REAL RHOTRP(NREGT)
    REAL (KIND=QL) RMUD(0:NLYR),ZS,ZR
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) KSQL(NLYR),SIGL(NLYR),GTED(NREGT,7)

    QR1 = 0; QR2 = 0; QR3 = 0; QR4 = 0; QR5 = 0; QR6 = 0; QR7 = 0.
    QI1 = 0; QI2 = 0; QI3 = 0; QI4 = 0; QI5 = 0; QI6 = 0; QI7 = 0.

    CALL EGT_UL_HNK (NREGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZS,ZR,GTED)

    DO JR = 1, NREGT
       QR1(1,JR) = REAL (GTED(JR,1), 4)
       QI1(1,JR) = REAL (AIMAG (GTED(JR,1)), 4)
       QR2(1,JR) = REAL (GTED(JR,2), 4)
       QI2(1,JR) = REAL (AIMAG (GTED(JR,2)), 4)
       QR3(1,JR) = REAL (GTED(JR,3), 4)
       QI3(1,JR) = REAL (AIMAG (GTED(JR,3)), 4)
       QR4(1,JR) = REAL (GTED(JR,4), 4)
       QI4(1,JR) = REAL (AIMAG (GTED(JR,4)), 4)
       QR5(1,JR) = REAL (GTED(JR,5), 4)
       QI5(1,JR) = REAL (AIMAG (GTED(JR,5)), 4)
       QR6(1,JR) = REAL (GTED(JR,6), 4)
       QI6(1,JR) = REAL (AIMAG (GTED(JR,6)), 4)
       QR7(1,JR) = REAL (GTED(JR,7), 4)
       QI7(1,JR) = REAL (AIMAG (GTED(JR,7)), 4)
    END DO

    CALL CUBSPL (RHOTRP,QR1,NREGT)
    CALL CUBSPL (RHOTRP,QI1,NREGT)
    CALL CUBSPL (RHOTRP,QR2,NREGT)
    CALL CUBSPL (RHOTRP,QI2,NREGT)
    CALL CUBSPL (RHOTRP,QR3,NREGT)
    CALL CUBSPL (RHOTRP,QI3,NREGT)
    CALL CUBSPL (RHOTRP,QR4,NREGT)
    CALL CUBSPL (RHOTRP,QI4,NREGT)
    CALL CUBSPL (RHOTRP,QR5,NREGT)
    CALL CUBSPL (RHOTRP,QI5,NREGT)
    CALL CUBSPL (RHOTRP,QR6,NREGT)
    CALL CUBSPL (RHOTRP,QI6,NREGT)
    CALL CUBSPL (RHOTRP,QR7,NREGT)
    CALL CUBSPL (RHOTRP,QI7,NREGT)

  END SUBROUTINE EGT_UL_CSPL

  SUBROUTINE EGT_UL_HNK (NREGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZS,ZR,GTED)
    !------------------------------------------------------------------------------------------------

    !***  Calls EGT_UL_KER
    !***  Called by PRM_BOSS_LP

    !  Computes the integrals for the electric Green's tensor elements when the top
    !  row of the plate is in the layer above basement.  (RXLYR set to NLYR - 1)
    !  It uses the flow through Hankel transform method to evaluate the three Hankel
    !  integrals at discrete depths.  The Hankel transform integral uses a 15 point
    !  per decade filter coefficient set derived from Christensen's FLTGEN program.

    !       NREGT - number of horizontal interpolation points
    !      RHOTRP - 15 points per decade interpolation array
    !         KFG - Case selector variable
    !       RXLYR - "receiver" layer (NLYR or NLYR-1)
    !       SXLYR - "source" layer (NLYR or NLYR-1)
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        THKD - thickness of each layer above basement
    !       DPTHL - depth to top of each layer including basement
    !        RMUD - relative magetic permeability
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !          ZS - transmitter point depth
    !          ZR - receiver point depth
    !
    !  GTED(JR,7) - integrals for Green's tensor elements
    !

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL(KIND=QL), PARAMETER :: FOURPI = 12.56637061_QL
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER L,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,JR,NLYR,SXLYR,RXLYR,KFG,NREGT
    REAL RHOTRP(NREGT)
    REAL(KIND=QL) RMUD(0:NLYR),ZS,ZR,DELTA,Y1,Y,RD,LMBDA,RHOD
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) GTED(NREGT,7),KER(JNLO-NREGT:JNHI,7)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL JUMP

    GTED = ZERO
    KER = ZERO
    DELTA = LOG (10.D0)/ DBLE (NDEC_JN)

    ! Basic integral for open and closed loops.
    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = DBLE (RHOTRP(1) )
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       CALL EGT_UL_KER (NREGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD, &
            DPTHL,RMUD,SIGL,KSQL,ZS,ZR,KER,GTED,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL EGT_UL_KER (NREGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD, &
            DPTHL,RMUD,SIGL,KSQL,ZS,ZR,KER,GTED,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NREGT)

    JR = NREGT
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.

       GTED(JR,1:3) =  GTED(JR,1:3) + KER(K,1:3) * WJ0(L)
       GTED(JR,4:7) =  GTED(JR,4:7) + KER(K,4:7) * WJ1(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (SNGL(Y))
          CALL EGT_UL_KER (NREGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD, &
               DPTHL,RMUD,SIGL,KSQL,ZS,ZR,KER,GTED,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NREGT-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          GTED(JR,1:3) =  GTED(JR,1:3) + KER(K,1:3) * WJ0(L)
          GTED(JR,4:7) =  GTED(JR,4:7) + KER(K,4:7) * WJ1(L)
       END DO
    END DO

    DO JR = 1, NREGT
       RHOD = REAL (RHOTRP(JR),KIND=QL)
       GTED(JR,1:7) = GTED(JR,1:7) / (FOURPI * RHOD)
       GTED(JR,4:5) = GTED(JR,4:5) / RHOD
    END DO

  END SUBROUTINE EGT_UL_HNK

  SUBROUTINE EGT_UL_KER (NREGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD, &
       DPTHL,RMUD,SIGL,KSQL,ZS,ZR,KER,GTED,JUMP)
    !----------------------------------------------------------------------

    !***  Called by EGT_UL_HNK_

    !  Compute the kernels for EGT for plates that intrude above basement
    !  The receiver is the row of cells above basement.

    !     NREGT - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !        ZS - source location  (negative in air, positive in ground)
    !      NLYR - number of layers including basement. (1 or 2 only)
    !      SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !      KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !      RMUD - relative magetic permeability
    !      THKD - thickness of each layer above basement
    !     DPTHL - depth to top of each layer including basement
    !       KFG - Case selector variable
    !       KER - kernels for hankel integraion
    !
    !   GTED(*,1,*) - needed for both closed and open loops
    !   GTED(*,2,*) - used only for grounded wire segments
    !   GTED(*,3,*) - used only for grounded wire segments
    !
    !           JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER JR,L,K,NLYR,SXLYR,RXLYR,KFG,NREGT,JI
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,LMBSQ,ZS,ZR,AR,AI,GTEDR,GTEDI
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX (KIND=QL) XI_V,F_V,F_H,ETA_V,G_V,G_H,KER(JNLO-NREGT:JNHI,7), &
         S(0:NLYR),SL,SM,KV,KS,XPU,XPD,GTED(NREGT,7),TMP(7)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    ! Compute layered-earth coefficients.

    KER(K,1:7) = ZERO

    LMBSQ = LMBDA * LMBDA
    CALL EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)
    SL = S(RXLYR)
    SM = S(SXLYR)
    XPU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
    XPD = EXP (SL * (DPTHL(RXLYR) - ZR))

    ! Convert from squiggle to hat form.  (Green's FUNCTION notes, Raiche,2008)

    XI_V = XI_V * XPU
    F_V  =  F_V * XPU
    F_H  =  F_H * XPU

    ETA_V = ETA_V * XPD
    G_V   =   G_V * XPD
    G_H   =   G_H * XPD
    TMP = ZERO

    KS = (XI_V + ETA_V) * RMUD(SXLYR) / (RMUD(RXLYR) * SM)
    KV = (F_H - G_H) * SL

    KER(K,1) = KS * LMBDA                                    ! Sxx, Sxy & Syy
    KER(K,2) = KV * LMBDA                                    ! Vxx, Vxy & Vyy
    KER(K,3) = (F_V + G_V) * LMBDA**3 / SM
    KER(K,4) = KS                          ! Sxx, Sxy & Syy
    KER(K,5) = KV                          ! Vxx, Vxy & Vyy
    KER(K,6) = (F_H + G_H) * LMBSQ
    KER(K,7) = (F_V - G_V) * LMBSQ * SL /SM
    JUMP = .TRUE.
    TMP(1:3) = KER(K,1:3) * WJ0(L)
    TMP(4:7) = KER(K,4:7) * WJ1(L)

    GTED(JR,1:7) = GTED(JR,1:7) + TMP(1:7)
    DO JI = 1,7
       AR = ABS ( REAL (TMP(JI)) )
       AI = ABS (AIMAG (TMP(JI)) )
       TOO_BIG = .FALSE.
       GTEDR = ABS ( REAL (GTED(JR,JI)) )
       GTEDI = ABS (AIMAG (GTED(JR,JI)) )
       IF (AR > TOL* GTEDR) TOO_BIG = .TRUE.
       IF (AI > TOL* GTEDI) TOO_BIG = .TRUE.
       IF (TOO_BIG) JUMP = .FALSE.
    END DO

  END SUBROUTINE EGT_UL_KER

  !======================================================================================
  !======================================================================================
  !
  !        MULTI-PLATE GREENS FUNCTION ROUTINES
  !        ------------------------------------

  SUBROUTINE INTER_EGT_BOSS (JPS,JPR,MXAB,NPLT,NA,NB,DPTHB,KSQN,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL, &
       NZ2,ZV2,NREGT,RHOTRP,GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,GI5Z, &
       GR6Z,GI6Z,VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI)
    !-------------------------------------------------------------------------------------------------------

    !***  Calls:  RXYZ2PLT, RPLT2XYZ, INTER_EGT_DIR
    !***  Called by: SCAT_MTRX_BOSS

    !  Computes the Green's tensor elements which give the response at plate JPR
    !  due to electric currents in plate JPS.  In what follows, the GTE have the
    !  units of electric field divided by a factor (-iwu) because this factor is
    !  explicitly included as a multiplier outside the integral over area when
    !  solving the integral equation.
    !
    !  This formulation differs from that of EGT_BOSS in two ways.  Firstly, the
    !  area integration is done in the calling routine rather than here.
    !  Secondly, a different breakup of GIJ = SIJ + HIJ / KSQ is used.
    !
    !  Two conventions of EGT_BOSS are used.  Firstly, HIJ is redefined to be
    !  HIJ = HIJ' + KSQ * SIJ is output where HIJ' is the curl free part and
    !  SIJ is the divergence-free part.
    !
    !  In the formulation the integrated Green's tensor G relates the field at r'
    !  to the current at r by
    !                                           _                      _
    !                                          |  Gaa(r.r')  Gab(r.r')  |
    !  { Ea(r'), Eb(r') } =  { Ja(r), Jb(r) }  |                        |
    !                                          |  Gba(r.r')  Gbb(r.r')  |
    !                                          |_                      _|
    !
    !  This can be put into the more expected operator form by writing this in
    !  transposed form as:
    !
    !   _        _       _                      _    _       _
    !  |  Ea(r')  |     |  Gaa(r,r')  Gba(r,r')  |  |  Ja(r)  |
    !  |          |  =  |                        |  |         |
    !  |  Eb(r')  |     |  Gab(r,r')  Gbb(r,r')  |  |  Jb(r)  |
    !  |_        _|     |_                      _|  |_       _|
    !
    !                    _                       _    _       _
    !                   |   Gaa(r',r)  Gab(r',r)  |  |  Ja(r)  |
    !                =  |                         |  |         |
    !                   |   Gba(r',r)  Gbb(r',r)  |  |  Jb(r)  |
    !                   |_                       _|  |_       _|
    !
    !                            _                                  _    _        _
    !         _             _   |   Gxx(r',r)  Gxy(r',r)  Gxz(r',r)  |  |          |   _       _
    !        |               |  |                                    |  |          |  |  Ja(r)  |
    !     =  |   R23 (r')    |  |   Gyx(r',r)  Gyy(r',r)  Gyz(r',r)  |  |  R32 (r) |  |         |
    !        |               |  |                                    |  |          |  |  Jb(r)  |
    !        |_             _|  |   Gzx(r',r)  Gzy(r',r)  Gzz(r',r)  |  |          |  |_       _|
    !                           |_                                  _|  |_        _|
    !
    !
    !    Gij(r,r') = ith component at r due to j oriented source at r'
    !    Thus the second operator form relates the observed field at r'
    !    to the source at r in the more expected way BUT note that the
    !    Gij are derived as the field at the source point.  This affects only
    !    the cross terms with z.  Gxz(r',r) = -Gxz(r,r')
    !    Gzx(r',r) = -Gxz(r',r)
    !
    !    We can use the second form by modifying the normaly computed GTEs
    !
    !  NA & NB are the number of cells along strike and down dip respectively.
    !  SIG contains the complex layer conductivities.
    !  KSQN = iwu * SIG(basement)
    !  DPTHB is the depth to basement.
    !
    !    OUTPUT:
    !   The adjoint Green's FUNCTION s are expressed as:
    !
    !  VAAI (JCR,JCS) - relate the along strike component of the electric field at
    !  SAAI (JCR,JCS)   cell JCR of plate JPR due to the along strike component
    !                   of the scattering current of cell JCS of plate JPS
    !
    !  VBAI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBAI (JCR,JCS)   cell JCR of plate JPR due to the along strike component
    !                   of the scattering current of cell JCS of plate JPS
    !
    !  VABI (JCR,JCS) - relate the along strike component of the electric field at
    !  SABI (JCR,JCS)   cell JCR of plate JPR due to the down dip component
    !                   of the scattering current of cell JCS of plate JPS
    !
    !  VBBI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBBI (JCR,JCS)   cell JCR of plate JPR due to the down dip component
    !                   of the scattering current of cell JCS of plate JPS
    !
    ! -------------------------------------------------------------------------

    IMPLICIT NONE
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER JPS,JPR,MXAB,NPLT,NA(NPLT),NB(NPLT),NREGT,NZ2,JCS,JCR, &
         JB1,JB2,JA1,JA2
    REAL XD,YD,ZD,ZTR,RHO,XBAR,XBARSQ,YBAR,YBARSQ,DPTHB,ZV2(NZ2),R23(2,3),R32(3,2), &
         XCELL(MXAB,NPLT),YCELL(MXAB,NPLT),ZCELL(MXAB,NPLT),CD2,SD2,CD1,SD1,CP1,    &
         CP2,SP1,SP2,CA2,SA2,CA1,SA1,RHOTRP(NREGT)
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ
    REAL, DIMENSION(4,NREGT,NZ2) :: GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,GI5Z,GR6Z,GI6Z
    COMPLEX KSQN,KBASE,Q1,Q2,Q3,Q4,Q5,Q6
    COMPLEX SXXD,VXXD,VYYD,VZZD,VXYD,VYZD,VZXD
    COMPLEX GXYZ(3,3),GAB(2,2),RTMP(3,2)
    COMPLEX, DIMENSION(MXAB,MXAB) :: VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI

    CA1 = COS (PLAZM(JPS)); CA2 = COS (PLAZM(JPR)); SA1 = SIN (PLAZM(JPS)); SA2 = SIN (PLAZM(JPR))
    CD1 = COS (PLDIP(JPS)); CD2 = COS (PLDIP(JPR)); SD1 = SIN (PLDIP(JPS)); SD2 = SIN (PLDIP(JPR))
    CP1 = COS (PLUNJ(JPS)); CP2 = COS (PLUNJ(JPR)); SP1 = SIN (PLUNJ(JPS)); SP2 = SIN (PLUNJ(JPR))


    CALL RXYZ2PLT (CA2,SA2,CD2,SD2,CP2,SP2,R23)
    CALL RPLT2XYZ (CA1,SA1,CD1,SD1,CP1,SP1,R32)


    KBASE = SQRT (KSQN)
    IF (REAL (KBASE) < 0) KBASE = -KBASE

    VAAI = ZERO;  VBAI = ZERO;  VABI = ZERO;  VBBI = ZERO
    SAAI = ZERO;  SBAI = ZERO;  SABI = ZERO;  SBBI = ZERO

    ! Set up splines for integrals for indirect terms

    DO JB1 = 1,NB(JPS)                             ! Step over source plate depths.
       DO JA1 = 1,NA(JPS)
          JCS = JA1 + (JB1-1) * NA(JPS)
          DO JB2 = 1,NB(JPR)                           ! Step over receiver plate depths.


             DO JA2 = 1,NA(JPR)
                JCR = JA2 + (JB2-1) * NA(JPR)
                XD =  XCELL(JCR,JPR) - XCELL(JCS,JPS)
                YD =  YCELL(JCR,JPR) - YCELL(JCS,JPS)
                ZD =  ZCELL(JCR,JPR) - ZCELL(JCS,JPS)
                ZTR = ZCELL(JCR,JPR) + ZCELL(JCS,JPS) - 2. * DPTHB
                RHO = SQRT (XD**2 + YD**2)
                XBAR = 0.;  YBAR = 0.
                IF (RHO > 1.E-6) THEN
                   XBAR = XD / RHO
                   YBAR = YD / RHO
                END IF
                XBARSQ = XBAR**2
                YBARSQ = YBAR**2

                ! Get direct terms for each cell pair.

                CALL INTER_EGT_DIR (XD,YD,ZD,KBASE,KSQN,SXXD,VXXD,VYYD,VZZD,VXYD,VYZD,VZXD)

                ! Evaluate the integrals and reflected terms for each cell pair

                Q1 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR1Z,GI1Z,RHO,ZTR)
                Q2 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR2Z,GI2Z,RHO,ZTR)
                Q3 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR3Z,GI3Z,RHO,ZTR)
                Q4 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR4Z,GI4Z,RHO,ZTR)
                Q5 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR5Z,GI5Z,RHO,ZTR)
                Q6 = C2DINTRP (RHOTRP,NREGT,ZV2,NZ2,GR6Z,GI6Z,RHO,ZTR)

                ! Compute the divergence free indirect terms, add direct terms and
                ! rotate them into the plate system.

                GXYZ = ZERO
                GXYZ(1,1) = SXXD + (1. - 2.*YBARSQ)  * Q4 + YBARSQ * Q1
                GXYZ(2,2) = SXXD + (1. - 2.*XBARSQ)  * Q4 + XBARSQ * Q1
                GXYZ(3,3) = SXXD
                GXYZ(1,2) = XBAR * YBAR * (2.* Q4 - Q1)
                GXYZ(2,1) = GXYZ(1,2)

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)

                SAAI(JCR,JCS) = GAB(1,1)
                SABI(JCR,JCS) = GAB(1,2)
                SBAI(JCR,JCS) = GAB(2,1)
                SBBI(JCR,JCS) = GAB(2,2)

                ! Compute the curl free indirect terms,  add direct terms and
                ! rotate them into the plate system.

                GXYZ(1,1) = VXXD + KSQN * GXYZ(1,1) + (1. - 2.*XBARSQ) * Q5 + XBARSQ * Q2
                GXYZ(2,2) = VYYD + KSQN * GXYZ(2,2) + (1. - 2.*YBARSQ) * Q5 + YBARSQ * Q2
                GXYZ(3,3) = VZZD + KSQN * GXYZ(3,3) - Q3
                GXYZ(1,2) = VXYD + KSQN * GXYZ(1,2) + XBAR * YBAR * (Q2 - 2.* Q5)
                GXYZ(2,1) = GXYZ(1,2)
                GXYZ(3,1) = VZXD + XBAR * Q6
                GXYZ(1,3) = VZXD - XBAR * Q6
                GXYZ(3,2) = VYZD + YBAR * Q6
                GXYZ(2,3) = VYZD - YBAR * Q6

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)

                VAAI(JCR,JCS) = GAB(1,1)
                VABI(JCR,JCS) = GAB(1,2)
                VBAI(JCR,JCS) = GAB(2,1)
                VBBI(JCR,JCS) = GAB(2,2)

             END DO   ! receiver plate columns
          END DO     ! source plate columns
       END DO       ! receiver plate rows
    END DO         ! source plate rows

  END SUBROUTINE INTER_EGT_BOSS

  SUBROUTINE INTER_EGT_BOSS_UL (JPS,JPR,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,MXAB,  &
       NA,NB,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL,NREGT,RHOTRP, &
       VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI)
    !-------------------------------------------------------------------------------------

    !***  Calls:  RXYZ2PLT, RPLT2XYZ, INTER_EGT_DIR
    !***  Called by: SCAT_MTRX_BOSS

    !  Computes the Green's tensor elements which give the response at plate JPR
    !  due to electric currents in plate JPS.  In what follows, the GTE have the
    !  units of electric field divided by a factor (-iwu) because this factor is
    !  explicitly included as a multiplier outside the integral over area when
    !  solving the integral equation.
    !
    !  This formulation uses a different breakup of GIJ = SIJ + HIJ / KSQ from
    !  that of EGT_BOSS.  Two conventions of EGT_BOSS are used.  Firstly, HIJ
    !  is redefined to be HIJ = HIJ' + KSQ * SIJ is output where HIJ' is the
    !  curl free part and SIJ is the divergence-free part.
    !
    !  In the formulation the integrated Green's tensor G relates the field at r'
    !  to the current at r by
    !                                           _                      _
    !                                          |  Gaa(r.r')  Gab(r.r')  |
    !  { Ea(r'), Eb(r') } =  { Ja(r), Jb(r) }  |                        |
    !                                          |  Gba(r.r')  Gbb(r.r')  |
    !                                          |_                      _|
    !
    !  This can be put into the more expected operator form by writing this in
    !  transposed form as:
    !
    !   _        _       _                      _    _       _
    !  |  Ea(r')  |     |  Gaa(r,r')  Gba(r,r')  |  |  Ja(r)  |
    !  |          |  =  |                        |  |         |
    !  |  Eb(r')  |     |  Gab(r,r')  Gbb(r,r')  |  |  Jb(r)  |
    !  |_        _|     |_                      _|  |_       _|
    !
    !                    _                       _    _       _
    !                   |   Gaa(r',r)  Gab(r',r)  |  |  Ja(r)  |
    !                =  |                         |  |         |
    !                   |   Gba(r',r)  Gbb(r',r)  |  |  Jb(r)  |
    !                   |_                       _|  |_       _|
    !
    !                            _                                  _    _        _
    !         _             _   |   Gxx(r',r)  Gxy(r',r)  Gxz(r',r)  |  |          |   _       _
    !        |               |  |                                    |  |          |  |  Ja(r)  |
    !     =  |   R23 (r')    |  |   Gyx(r',r)  Gyy(r',r)  Gyz(r',r)  |  |  R32 (r) |  |         |
    !        |               |  |                                    |  |          |  |  Jb(r)  |
    !        |_             _|  |   Gzx(r',r)  Gzy(r',r)  Gzz(r',r)  |  |          |  |_       _|
    !                           |_                                  _|  |_        _|
    !
    !
    !    Gij(r,r') = ith component at r due to j oriented source at r'
    !    Thus the second operator form relates the observed field at r'
    !    to the source at r in the more expected way BUT note that the
    !    Gij are derived as the field at the source point.  This affects only
    !    the cross terms with z.  Gxz(r',r) = -Gxz(r,r')
    !    Gzx(r',r) = -Gxz(r',r)
    !
    !    We can use the second form by modifying the normaly computed GTEs
    !
    !  NA & NB are the number of cells along strike and down dip respectively.
    !  SIG contains the complex layer conductivities.
    !  KSQN = iwu * SIG(basement)
    !
    !    OUTPUT:
    !   The adjoint Green's FUNCTION s are expressed as:
    !
    !  VAAI (JCR,JCS) - relate the along strike component of the electric field at
    !  SAAI (JCR,JCS)   cell JCR of plate JPR due to the along strike component
    !                   of the scattering current of cell JCS of plate JPS
    !
    !  VBAI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBAI (JCR,JCS)   cell JCR of plate JPR due to the along strike component
    !                   of the scattering current of cell JCS of plate JPS
    !
    !  VABI (JCR,JCS) - relate the along strike component of the electric field at
    !  SABI (JCR,JCS)   cell JCR of plate JPR due to the down dip component
    !                   of the scattering current of cell JCS of plate JPS
    !
    !  VBBI (JCR,JCS) - relate the down dip component of the electric field at
    !  SBBI (JCR,JCS)   cell JCR of plate JPR due to the down dip component
    !                   of the scattering current of cell JCS of plate JPS
    !
    ! -------------------------------------------------------------------------

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NLYR,SXLYR,RXLYR,KFG,JPS,JPR,MXAB,NPLT,NREGT, &
         JCS,JCR,JB1,JB2,JA1,JA2,JABR,JABS,I1
    INTEGER, DIMENSION (NPLT) :: NA,NB,PLYR
    REAL XD,YD,ZD,RHO,XBAR,XBARSQ,YBAR,YBARSQ,R23(2,3),R32(3,2), &
         XCELL(MXAB,NPLT),YCELL(MXAB,NPLT),ZCELL(MXAB,NPLT),CD2,SD2,CD1,SD1,CP1,    &
         CP2,SP1,SP2,CA2,SA2,CA1,SA1,RHOTRP(NREGT)
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ
    REAL, DIMENSION(4,NREGT) :: QR1,QI1,QR2,QI2,QR3,QI3,QR4,QI4,QR5,QI5,QR6,QI6,QR7,QI7
    REAL (KIND=QL) RMUD(0:NLYR),THKD(NLYR),DPTHL(NLYR),ZR,ZS
    COMPLEX KSQN,KBASE,Q1,Q2,Q3,Q4,Q5,Q6,Q7
    COMPLEX SXXD,VXXD,VYYD,VZZD,VXYD,VYZD,VZXD
    COMPLEX GXYZ(3,3),GAB(2,2),RTMP(3,2)
    COMPLEX, DIMENSION(MXAB,MXAB) :: VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI
    COMPLEX(KIND=QL) KSQL(NLYR),SIGL(NLYR)

    CA1 = COS (PLAZM(JPS)); CA2 = COS (PLAZM(JPR)); SA1 = SIN (PLAZM(JPS)); SA2 = SIN (PLAZM(JPR))
    CD1 = COS (PLDIP(JPS)); CD2 = COS (PLDIP(JPR)); SD1 = SIN (PLDIP(JPS)); SD2 = SIN (PLDIP(JPR))
    CP1 = COS (PLUNJ(JPS)); CP2 = COS (PLUNJ(JPR)); SP1 = SIN (PLUNJ(JPS)); SP2 = SIN (PLUNJ(JPR))

    CALL RXYZ2PLT (CA2,SA2,CD2,SD2,CP2,SP2,R23)
    CALL RPLT2XYZ (CA1,SA1,CD1,SD1,CP1,SP1,R32)

    VAAI = ZERO;  VBAI = ZERO;  VABI = ZERO;  VBBI = ZERO
    SAAI = ZERO;  SBAI = ZERO;  SABI = ZERO;  SBBI = ZERO

    RXLYR = PLYR(JPR)
    SXLYR = PLYR(JPS)
    I1 = 2
    CALL SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)

    KSQN = CMPLX (KSQL(RXLYR))
    KBASE = SQRT (KSQN)
    IF (REAL (KBASE) < 0) KBASE = -KBASE

    DO JB1 = 1,NB(JPS)                             ! Step over source plate depths.
       JABS = 1 + (JB1 -1) * NA(JPS)
       ZS = ZCELL(JABS,JPS)                          ! depth of row JB1
       DO JB2 = 1,NB(JPR)                           ! Step over receiver plate depths.
          JABR = 1 + (JB2 -1) * NA(JPR)
          ZR = ZCELL(JABR,JPR)                        ! depth of row JB1 cell centre

          CALL EGT_UL_CSPL (NREGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZS, &
               ZR,QR1,QI1,QR2,QI2,QR3,QI3,QR4,QI4,QR5,QI5,QR6,QI6,QR7,QI7)

          ! Set up splines for integrals for indirect terms

          DO JA1 = 1,NA(JPS)
             JCS = JA1 + (JB1-1) * NA(JPS)
             DO JA2 = 1,NA(JPR)
                JCR = JA2 + (JB2-1) * NA(JPR)
                XD =  XCELL(JCR,JPR) - XCELL(JCS,JPS)
                YD =  YCELL(JCR,JPR) - YCELL(JCS,JPS)
                ZD =  ZCELL(JCR,JPR) - ZCELL(JCS,JPS)
                RHO = SQRT (XD**2 + YD**2)
                XBAR = 0.;  YBAR = 0.
                IF (RHO > 1.E-6) THEN
                   XBAR = XD / RHO
                   YBAR = YD / RHO
                END IF
                XBARSQ = XBAR**2
                YBARSQ = YBAR**2

                ! Get direct terms for each cell pair that are in the same layer.

                SXXD = ZERO
                VXXD = ZERO
                VYYD = ZERO
                VZZD = ZERO
                VXYD = ZERO
                VYZD = ZERO
                VZXD = ZERO
                IF (RXLYR == SXLYR) &
                     CALL INTER_EGT_DIR (XD,YD,ZD,KBASE,KSQN,SXXD,VXXD,VYYD,VZZD,VXYD,VYZD,VZXD)

                ! Evaluate the integrals and reflected terms for each cell pair

                CALL CCUBVAL(RHOTRP,NREGT,QR1,QI1,RHO,Q1)
                CALL CCUBVAL(RHOTRP,NREGT,QR2,QI2,RHO,Q2)
                CALL CCUBVAL(RHOTRP,NREGT,QR3,QI3,RHO,Q3)
                CALL CCUBVAL(RHOTRP,NREGT,QR4,QI4,RHO,Q4)
                CALL CCUBVAL(RHOTRP,NREGT,QR5,QI5,RHO,Q5)
                CALL CCUBVAL(RHOTRP,NREGT,QR6,QI6,RHO,Q6)
                CALL CCUBVAL(RHOTRP,NREGT,QR7,QI7,RHO,Q7)

                ! Compute the divergence free indirect terms, add direct terms and
                ! rotate them into the plate system.

                GXYZ = ZERO
                GXYZ(1,1) = SXXD + (1. - 2.*YBARSQ) * Q4 + YBARSQ * Q1
                GXYZ(2,2) = SXXD + (1. - 2.*XBARSQ) * Q4 + XBARSQ * Q1
                GXYZ(3,3) = SXXD
                GXYZ(1,2) = XBAR * YBAR * (2.* Q4 - Q1)
                GXYZ(2,1) = GXYZ(1,2)

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)

                SAAI(JCR,JCS) = GAB(1,1)
                SABI(JCR,JCS) = GAB(1,2)
                SBAI(JCR,JCS) = GAB(2,1)
                SBBI(JCR,JCS) = GAB(2,2)

                ! Compute the curl free indirect terms,  add direct terms and
                ! rotate them into the plate system.

                GXYZ(1,1) = VXXD + KSQN * GXYZ(1,1) + (1. - 2.*XBARSQ) * Q5 + XBARSQ * Q2
                GXYZ(2,2) = VYYD + KSQN * GXYZ(2,2) + (1. - 2.*YBARSQ) * Q5 + YBARSQ * Q2
                GXYZ(3,3) = VZZD + KSQN * GXYZ(3,3) - Q3
                GXYZ(1,2) = VXYD + KSQN * GXYZ(1,2) + XBAR * YBAR * (Q2 - 2.* Q5)
                GXYZ(2,1) = GXYZ(1,2)
                GXYZ(3,1) = VZXD + XBAR * Q6
                GXYZ(3,2) = VYZD + YBAR * Q6
                GXYZ(1,3) = VZXD + XBAR * Q7
                GXYZ(2,3) = VYZD + YBAR * Q7

                RTMP = MATMUL (GXYZ, R32)
                GAB =  MATMUL (R23, RTMP)

                VAAI(JCR,JCS) = GAB(1,1)
                VABI(JCR,JCS) = GAB(1,2)
                VBAI(JCR,JCS) = GAB(2,1)
                VBBI(JCR,JCS) = GAB(2,2)

             END DO   ! receiver plate columns
          END DO     ! source plate columns
       END DO       ! receiver plate rows
    END DO         ! source plate rows

  END SUBROUTINE INTER_EGT_BOSS_UL

  SUBROUTINE INTER_EGT_DIR (XD,YD,ZD,KBASE,KSQN,SXXD,HXXD,HYYD,HZZD,HXYD,HYZD,HZXD)
    !---------------------------------------------------------------------------------

    !***  Called by INTER_EGT_BOSS

    !   Computes the direct (or full space) Green's tensor elements:
    !
    !  XD, YD, ZD - receiver coordinates relative to source dipole
    !        KSQN - i omega mu sigma (basement)
    !       KBASE - sqrt (KSQN)
    !
    !   Leroi uses an integral equation formulation where an explicit factor (-iwu)
    !   appears outside the integral.  Thus the Green's tensor elements, GIJ are in
    !   units of electric field divided by this factor.  Moreover, these modified
    !   GIJ can be expressed as the sum SIJ + HIJ / KSQN, where SIJ and HIJ are the
    !   divergence free and curl free parts respectively.  This is done for reasons
    !   explained in EGT_BOSS and SCAT_MTRX_BUILD.
    !   This SUBROUTINE returns SIJ and HIJ.  It does NOT return HIJ in the form
    !   HIJ:= KSQN * GIJ = KSQN * SIJ + HIJ
    !
    !   In the direct case, SXX = SYY = SZZ.  SIJ (I/=J) = 0.
    !   Also like the indirect case HXY = HYX, but unlike the indirect case,
    !   HZX = HXZ and HZY = HYZ
    !
    !   These are symmetric wrt exchange of direction or TX-RX  point swap.
    !
    IMPLICIT NONE
    COMPLEX, PARAMETER :: ONE=(1.,0.)
    REAL XD,YD,ZD,R,RSQ
    COMPLEX KBASE,KSQN,K2R,FAC1,FAC2,BASE,SXXD,HXXD,HYYD,HZZD,HXYD,HYZD,HZXD

    INTENT (IN) XD,YD,ZD,KBASE,KSQN
    INTENT (OUT) SXXD,HXXD,HYYD,HZZD,HXYD,HYZD,HZXD

    RSQ = XD**2 + YD**2 + ZD**2
    R = SQRT (RSQ)
    K2R = KBASE * R

    SXXD = EXP (-K2R) / (4. * 3.141592654 * R)

    BASE = SXXD / RSQ
    FAC1 = ONE + K2R
    FAC2 = BASE * (3.*FAC1 + KSQN*RSQ) /RSQ
    FAC1 = FAC1 * BASE

    HXXD = FAC1 - FAC2 * XD**2
    HYYD = FAC1 - FAC2 * YD**2
    HZZD = FAC1 - FAC2 * ZD**2

    HXYD = -FAC2 * XD * YD
    HYZD = -FAC2 * YD * ZD
    HZXD = -FAC2 * XD * ZD

  END SUBROUTINE INTER_EGT_DIR

  SUBROUTINE MGT_BOSS (NPLT,PLYR,MXAB,NA,NB,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL,NLYR,THKD, &
       DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS,ZRXTX,   &
       WTRS,NRMGT,RHOTRP,NZ1,ZV1,NMGP,XMG,YMG,ZMG,WMG,HA,HB)
    !----------------------------------------------------------------------------------------

    !***  Called by SCAT_EM
    !***  Calls MGT_CSPL

    !  This rutine is used for basement plates.  It is based on interpolated Green's
    !  that can be used for all plates in the basement simultaneously.
    !
    !  Integrated magnetic Green's tensor computation for relating the along strike
    !  and down dip components of the scattering current for each plate to the
    !  X,Y,Z magnetic fields at each receiver of each transmitter.  For loop receivers
    !  this is done by subnets.  A 9 point per cell rule with uniform weights is used.
    !
    !                        INPUT
    !                        -----
    !
    !                 NPLT - Number of plates
    !                 PLYR - layer containing plate
    !                 MXAB - Number of cells in biggest plate
    !               NA, NB - number of cells along strike and down dip respectively
    !                PLAZM - plate strike angles
    !                PLDIP - plate dips
    !                PLUNJ - rotation
    !                  WMG - integration weights for each plate
    !                 NMGP - number of integration points per cell
    !        XMG, YMG, ZMG - integration points relative to cell centre, in plane of plate
    !  XCELL, YCELL, ZCELL - cell centre locations in the observer system.
    !
    !        NLYR - number of layers including overburden.
    !        THKD - QL precision layer thicknesses
    !       DPTHL - QL depth to top of each layer
    !        RMUD - QL precision relative magetic permeability
    !        SIGL - QL precision complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - QL precision iwu * SIGL for all layers (includes Cole-Cole)
    !         NTX - number of transmitters
    !       NRXTX - number of receivers per transmitter (max = MRXTX)
    !        RXID - identifies type of receiver: 1 = mag dipole;  2 = electric dipole
    !         NRS - number of subnet receivers per receiver (max = MXRS)
    !    XRS, YRS - North, East coordinates of receiver subnet for plate JP
    !        WTRS - subnet receiver weights
    !        NMGP - number of cell integration weights
    !       NRMGT - Dimension for MGT interpolations
    !      RHOTRP - horizontal interpolation array for MGT
    !    ZV1(NZ1) - vertical interpolatin array
    !
    !               OUTPUT
    !               ------
    !  HA(JAB,I,JR,JS) is the I-th component of the magnetic field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    strike direction in the centre of plate cell number JAB.

    !  HB(JAB,I,JR,JS) is the I-th component of the magnetic field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    dip direction in the centre of plate cell number JAB.

    !                    I = 1   is the North component
    !                    I = 2   is the East component
    !                    I = 3   is the vertical component

    !  HA & HB are thus combinations of magnetic Green's tensor elements
    !  integrated over the area of individual cells.  Units are Teslas per unit amp.

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NPLT,MXAB,NLYR,SXLYR,RXLYR,KFG,NTX,MRXTX,NRXTX(NTX),MXRS,NRS(MRXTX,NTX), &
         NRMGT,NZ1,NMGP,JA,JB,JP,JR,JR1,JS,JAB,J1,I1,RXID(MRXTX,NTX)
    INTEGER, DIMENSION (NPLT) :: NA,NB,PLYR
    REAL RHOTRP(NRMGT),ZV1(NZ1),R32(3,2),SD,CD,CP,SP,CS,SS,XS,YS,ZS,XD,YD,ZD,RHO, &
         XBAR,YBAR,MUB,RXVRT
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ,WMG
    REAL, DIMENSION (MXAB,NPLT) :: XCELL,YCELL,ZCELL
    REAL, DIMENSION (MXRS,MRXTX,NTX) ::  XRS,YRS,WTRS
    REAL, DIMENSION (MRXTX,NTX) :: ZRXTX
    REAL(KIND=QL) ZR,ZPRV,THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR)
    REAL, DIMENSION (4,NRMGT,NZ1) :: QB1R,QB1I,QB2R,QB2I,QB3R,QB3I,QB4R,QB4I,QB5R,QB5I
    REAL, DIMENSION (NMGP,NPLT) :: XMG,YMG,ZMG
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    COMPLEX MGT(3,3),MGTR(3,2),QQ(5),PSI(3),KB,KB0
    COMPLEX, DIMENSION (MXAB,3,MRXTX,NTX,NPLT) :: HA,HB

    MUB = REAL (RMUD(NLYR))
    KB = CMPLX (SQRT (KSQL(NLYR)) )
    KB0 = ZERO
    IF (REAL (KB) < 0.) KB = -KB
    IF (REAL (KB0) < 0.) KB0 = -KB0

    !  Step down dip cell row by cell row, and within each row, one integration
    !  line at a time.  Then step through receivers.  Set up the base integrals,
    !  QB*j for each line - receiver height combination.
    !  If next receiver has the same height, retain base integrals.

    ZPRV = -9.D4
    I1 = 2                               ! electric source
    DO JS = 1,NTX                        ! Loop over transmitters
       DO JR = 1, NRXTX(JS)               ! Loop over receivers
          IF (RXID(JR,JS) == 2 .OR.  RXID(JR,JS) == 3) CYCLE       ! This SUBROUTINE is for magnetic dipoles only.
          ZR = REAL (ZRXTX(JR,JS),QL)
          RXVRT = REAL (ABS (ZPRV - ZR))
          IF (RXVRT > .01_QL) THEN
             ZPRV = ZR
             RXLYR = 0
             DO J1 = NLYR,1,-1
                IF (ZR > DPTHL(J1)) THEN
                   RXLYR = J1
                   EXIT
                END IF
             END DO
             SXLYR = NLYR
             CALL SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)
             CALL MGT_CSPL (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZR, &
                  NZ1,ZV1,QB1R,QB1I,QB2R,QB2I,QB3R,QB3I,QB4R,QB4I,QB5R,QB5I)
          END IF


          DO JP = 1,NPLT                    ! Loop over plates
             IF (PLYR(JP) < NLYR) CYCLE
             CS = COS (PLAZM(JP))
             SS = SIN (PLAZM(JP))
             CD = COS (PLDIP(JP))
             SD = SIN (PLDIP(JP))
             CP = COS (PLUNJ(JP))
             SP = SIN (PLUNJ(JP))
             CALL RPLT2XYZ (CS,SS,CD,SD,CP,SP,R32)  ! Rotation matrix

             DO JB = 1,NB(JP)                       ! Loop over cell rows
                DO JA = 1, NA(JP)                    ! Loop over cell columns
                   JAB = JA + ((JB-1) * NA(JP))
                   MGT = ZERO
                   DO J1 = 1,NMGP                     ! Loop over cell integration points
                      XS = XCELL(JAB,JP) + XMG(J1,JP)
                      YS = YCELL(JAB,JP) + YMG(J1,JP)
                      ZS = ZCELL(JAB,JP) + ZMG(J1,JP)

                      DO JR1 = 1, NRS(JR,JS)           ! Loop over receiver subnet
                         XD = XRS(JR1,JR,JS) - XS
                         YD = YRS(JR1,JR,JS) - YS

                         ! For "source" layer receivers, add in the direct term.  Note that C2DINTRP uses ZS
                         ! rather than ZD because MGT_CSPL is called as a FUNCTION of ZR.  The interpolants
                         ! are then stored as a FUNCTION of ZS for each value of ZR.

                         ZD = REAL (ZR) - ZS
                         PSI(1:3) = ZERO
                         IF (RXLYR == NLYR) CALL MGTDIR (XD,YD,ZD,KB,MUB,PSI)
                         !! print *,zs,zd
                         RHO = SQRT (XD**2 + YD**2)
                         RHO = MAX (RHO, RHOTRP(1))
                         QQ(1) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB1R,QB1I,RHO,ZS)
                         QQ(2) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB2R,QB2I,RHO,ZS)
                         QQ(3) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB3R,QB3I,RHO,ZS)
                         QQ(1:3) = QQ(1:3) * WTRS(JR1,JR,JS)
                         XBAR = 0.
                         YBAR = 0.
                         IF (RHO > 1.E-6) THEN
                            XBAR = XD / RHO
                            YBAR = YD / RHO
                         END IF
                         MGT(1,1) = MGT(1,1) + XBAR * YBAR * (QQ(2) - 2.* QQ(1))

                         IF (RXLYR == 0) THEN
                            MGT(2,1) = MGT(2,1) + (1. - 2.*YBAR**2) * QQ(1) + YBAR**2 * QQ(2)
                            MGT(1,2) = MGT(1,2) - (1. - 2.*XBAR**2) * QQ(1) - XBAR**2 * QQ(2)
                            MGT(3,1) = MGT(3,1) + YBAR * QQ(3)
                            MGT(3,2) = MGT(3,2) - XBAR * QQ(3)
                            MGT(1:2,3) = ZERO

                         ELSE
                            QQ(4) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB4R,QB4I,RHO,ZS)
                            QQ(5) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB5R,QB5I,RHO,ZS)
                            QQ(4:5) = QQ(4:5) * WTRS(JR1,JR,JS)

                            MGT(2,1) = MGT(2,1) + (1. - 2.*YBAR**2) * QQ(1) + YBAR**2 * QQ(2) + QQ(4) - PSI(3)
                            MGT(1,2) = MGT(1,2) + (1. - 2.*YBAR**2) * QQ(1) - XBAR**2 * QQ(2) - QQ(4) + PSI(3)
                            MGT(3,1) = MGT(3,1) + YBAR * QQ(3) + PSI(2)
                            MGT(3,2) = MGT(3,2) - XBAR * QQ(3) - PSI(1)
                            MGT(1,3) = MGT(1,3) - YBAR * QQ(5) - PSI(2)
                            MGT(2,3) = MGT(2,3) + XBAR * QQ(5) + PSI(1)
                         END IF
                      END DO                ! End JR1 loop over receiver subnet
                   END DO                  ! End J1 loop over integration points

                   ! Rotate MGT from XYZ-XYZ TO XYZ-PLT system.  Apply plate weighting for each cell.

                   MGT(2,2) = -MGT(1,1)
                   MGTR = MATMUL (MGT, R32) * WMG(JP)

                   HA(JAB,1:3,JR,JS,JP) = HA(JAB,1:3,JR,JS,JP) + MGTR(1:3,1)
                   HB(JAB,1:3,JR,JS,JP) = HB(JAB,1:3,JR,JS,JP) + MGTR(1:3,2)

                END DO                    ! End JA loop over columns
             END DO                      ! End JB loop over rows
          END DO                        ! End JP loop over plates
       END DO                          ! End JR loop over receivers
    END DO                            ! End JS loop over transmitters

  END SUBROUTINE MGT_BOSS

  SUBROUTINE MGT_BOSS_UL (JP,SXLYR,NPLT,MXAB,NAL,NBL,DAL,DBL,PLAZM,PLDIP,XCELL,YCELL,NLYR, &
       THKD,DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS, &
       ZRXTX,WTRS,NRMGT,RHOTRP,NZ3L,ZC3L,HA,HB)
    !----------------------------------------------------------------------------------------

    !***  Called by SCAT_EM
    !***  Calls MGT_CSPL

    !  This rutine is used for plates above basement one at a time.
    !
    !  Integrated magnetic Green's tensor computation for relating the along strike
    !  and down dip components of the scattering current for each plate to the
    !  X,Y,Z magnetic fields at each receiver of each transmitter.  For loop receivers
    !  this is done by subnets.  A 9 point per cell rule with uniform weights is used.
    !
    !                 INPUT
    !                 -----
    !
    !            JP - plate index
    !          NPLT - Number of plates
    !          PLYR - layer containing plate
    !          MXAB - Number of cells in biggest plate
    !        NA, NB - number of cells along strike and down dip respectively
    !         PLAZM - plate strike angles
    !         PLDIP - plate dips
    !  XCELL, YCELL - cell centre locations in the observer system.
    !          NLYR - number of layers including overburden.
    !          THKD - QL precision layer thicknesses
    !         DPTHL - QL depth to top of each layer
    !          RMUD - QL precision relative magetic permeability
    !          SIGL - QL precision complex xconductivity for all layers including Cole-Cole & dielectric
    !          KSQL - QL precision iwu * SIGL for all layers (includes Cole-Cole)
    !           NTX - number of transmitters
    !         NRXTX - number of receivers per transmitter (max = MRXTX)
    !          RXID - identifies type of receiver: 1 = mag dipole;  2 = electric dipole
    !           NRS - number of subnet receivers per receiver (max = MXRS)
    !      XRS, YRS - North, East coordinates of receiver subnet for plate JP
    !          WTRS - subnet receiver weights
    !         NRMGT - Dimension for MGT interpolations
    !        RHOTRP - horizontal interpolation array for MGT
    !    ZV3L(NZ3L) - vertical interpolatin array
    !
    !               OUTPUT
    !               ------
    !  HA(JAB,I,JR,JS) is the I-th component of the magnetic field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    strike direction in the centre of plate cell number JAB.

    !  HB(JAB,I,JR,JS) is the I-th component of the magnetic field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    dip direction in the centre of plate cell number JAB.

    !                    I = 1   is the North component
    !                    I = 2   is the East component
    !                    I = 3   is the vertical component

    !  HA & HB are thus combinations of magnetic Green's tensor elements
    !  integrated over the area of individual cells.  Units are Teslas per unit amp.

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NAL,NBL,NZ3L,NPLT,MXAB,NLYR,SXLYR,RXLYR,KFG,NTX,MRXTX,NRXTX(NTX),MXRS, &
         NRS(MRXTX,NTX),NRMGT,JA,JB,JP,JR,JZ,JR1,JS,JAB,J1,J2,I1,RXID(MRXTX,NTX)
    REAL DAL,DBL,RHOTRP(NRMGT),ZC3L(NZ3L),R32(3,2),SD,CD,CP,SP,CS,SS,XS,YS,ZS,XD,YD,ZD,RHO, &
         XBAR,YBAR,MUB,RXVRT,DELX,DELY,WMG
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP
    REAL, DIMENSION (MXAB,NPLT) :: XCELL,YCELL
    REAL, DIMENSION (MXRS,MRXTX,NTX) ::  XRS,YRS,WTRS
    REAL, DIMENSION (MRXTX,NTX) :: ZRXTX
    REAL(KIND=QL) ZR,ZPRV,THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR)
    REAL, DIMENSION (4,NRMGT,NZ3L) :: G1R,G1I,G2R,G2I,G3R,G3I,G4R,G4I,G5R,G5I
    COMPLEX MGT(3,3),MGTR(3,2),QQ(5),PSI(3),KB
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    COMPLEX, DIMENSION (MXAB,3,MRXTX,NTX,NPLT) :: HA,HB

    MUB = REAL (RMUD(SXLYR))
    KB = CMPLX (SQRT (KSQL(SXLYR)) )
    IF (REAL (KB) < 0.) KB = -KB
    CS = COS (PLAZM(JP))
    SS = SIN (PLAZM(JP))
    CD = COS (PLDIP(JP))
    SD = SIN (PLDIP(JP))
    CP = 1.0
    SP = 0.0
    CALL RPLT2XYZ (CS,SS,CD,SD,CP,SP,R32)  ! Rotation matrix

    DELX = DAL / 4.
    DELY = CD * DBL / 4.
    WMG = DAL * DBL / 9.     ! 9 point rule

    !  Step down dip cell row by cell row, and within each row, one integration
    !  line at a time.  Then step through receivers.  Set up the base integrals,
    !  QB*j for each line - receiver height combination.
    !  If next receiver has the same height, retain base integrals.

    ZPRV = -9.D4
    I1 = 2                               ! electric source
    DO JS = 1,NTX                        ! Loop over transmitters
       DO JR = 1, NRXTX(JS)               ! Loop over receivers
          IF (RXID(JR,JS) == 2 .OR.  RXID(JR,JS) == 3) CYCLE       ! This SUBROUTINE is for magnetic dipoles only.
          ZR = REAL (ZRXTX(JR,JS),QL)
          RXVRT = REAL (ABS (ZPRV - ZR))
          IF (RXVRT > .01_QL) THEN
             ZPRV = ZR
             RXLYR = 0
             DO J1 = NLYR,1,-1
                IF (ZR > DPTHL(J1)) THEN
                   RXLYR = J1
                   EXIT
                END IF
             END DO
             CALL SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)
             CALL MGT_CSPL (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZR, &
                  NZ3L,ZC3L,G1R,G1I,G2R,G2I,G3R,G3I,G4R,G4I,G5R,G5I)
          END IF

          DO JB = 1,NBL
             DO JA = 1, NAL                    ! Loop over cell columns
                JAB = JA + (JB-1) * NAL
                MGT = ZERO
                DO J1 = -1,1                         ! Loop over horizontal cell integration points
                   JZ = 3*JB + J1 - 1
                   ZS = ZC3L(JZ)
                   YS = YCELL(JAB,JP) + J1 * DELY
                   ZD = REAL (ZR) - ZS
                   DO J2 = -1,1                     ! Loop over horizontal cell integration points
                      XS = XCELL(JAB,JP) + J2 * DELX
                      DO JR1 = 1, NRS(JR,JS)           ! Loop over receiver subnet
                         XD = XRS(JR1,JR,JS) - XS
                         YD = YRS(JR1,JR,JS) - YS
                         RHO = SQRT (XD**2 + YD**2)
                         RHO = MAX (RHO, RHOTRP(1))


                         CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G1R,G1I,RHO,JZ,QQ(1))
                         CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G2R,G2I,RHO,JZ,QQ(2))
                         CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G3R,G3I,RHO,JZ,QQ(3))
                         QQ(1:3) = QQ(1:3) * WTRS(JR1,JR,JS)
                         XBAR = 0.
                         YBAR = 0.
                         IF (RHO > 1.E-6) THEN
                            XBAR = XD / RHO
                            YBAR = YD / RHO
                         END IF
                         MGT(1,1) = MGT(1,1) + XBAR * YBAR * (QQ(2) - 2.* QQ(1))

                         IF (RXLYR == 0) THEN
                            MGT(2,1) = MGT(2,1) + (1. - 2.*YBAR**2) * QQ(1) + YBAR**2 * QQ(2)
                            MGT(1,2) = MGT(1,2) - (1. - 2.*XBAR**2) * QQ(1) - XBAR**2 * QQ(2)
                            MGT(3,1) = MGT(3,1) + YBAR * QQ(3)
                            MGT(3,2) = MGT(3,2) - XBAR * QQ(3)
                            MGT(1:2,3) = ZERO

                         ELSE
                            PSI(1:3) = ZERO
                            IF (RXLYR == SXLYR) CALL MGTDIR (XD,YD,ZD,KB,MUB,PSI)  ! direct whole space term
                            CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G4R,G4I,RHO,JZ,QQ(4))
                            CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G5R,G5I,RHO,JZ,QQ(5))
                            QQ(4:5) = QQ(4:5) * WTRS(JR1,JR,JS)

                            MGT(2,1) = MGT(2,1) + (1. - 2.*YBAR**2) * QQ(1) + YBAR**2 * QQ(2) + QQ(4) - PSI(3)
                            MGT(1,2) = MGT(1,2) + (1. - 2.*YBAR**2) * QQ(1) - XBAR**2 * QQ(2) - QQ(4) + PSI(3)
                            MGT(3,1) = MGT(3,1) + YBAR * QQ(3) + PSI(2)
                            MGT(3,2) = MGT(3,2) - XBAR * QQ(3) - PSI(1)
                            MGT(1,3) = MGT(1,3) - YBAR * QQ(5) - PSI(2)
                            MGT(2,3) = MGT(2,3) + XBAR * QQ(5) + PSI(1)
                         END IF
                      END DO              ! End JR1 loop over receiver subnet
                   END DO                ! End J2 loop over horizontal integration points
                END DO                  ! End J1 loop over vertical integration points

                ! Rotate MGT from XYZ-XYZ TO XYZ-PLT system.  Apply plate weighting for each cell.

                MGT(2,2) = -MGT(1,1)
                MGTR = MATMUL (MGT, R32) * WMG       ! 9 point per cell integration

                HA(JAB,1:3,JR,JS,JP) = HA(JAB,1:3,JR,JS,JP) + MGTR(1:3,1)
                HB(JAB,1:3,JR,JS,JP) = HB(JAB,1:3,JR,JS,JP) + MGTR(1:3,2)

             END DO                    ! End JA loop over columns
          END DO                      ! End JB loop over rows
       END DO                        ! End JR loop over receivers
    END DO                          ! End JS loop over transmitters

  END SUBROUTINE MGT_BOSS_UL

  SUBROUTINE MGT_CSPL (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZR, &
       NZ,ZV,QB1R,QB1I,QB2R,QB2I,QB3R,QB3I,QB4R,QB4I,QB5R,QB5I)
    ! ---------------------------------------------------------------------------------

    !  Computes QBjR, and QBjI (j = 1,5) the real and imaginary parts of the
    !  base Hankel transform integrals for specified ZR and ZS for the full
    !  range of horizontal distances between receivers and points in the plate.
    !  These are splined and used to compute magnetic Green's tensor elements.

    !                  INPUT
    !                  -----
    !         NRMGT - number of points in RHOTRP needed for MGT computation
    !        RHOTRP - abscissa array for interpolation in horizontal direction
    !          NLYR - number of layers including overburden.
    !          THKD - layer thicknesses
    !         DPTHL - depth to top of each layer
    !          RMUD - QL precision relative magetic permeability
    !          SIGL - complex conductivities of air, overburden and host
    !          KSQL - i * omega * mu * conductivity for each layer
    !         RXLYR = layer containing receiver
    !            ZR - receiver depth (negative for receiver in air)
    !            ZS - depth of induced "source point" in plate


    !***  Called by MGT_BOSS
    !***  Calls MGT_HNK, CUBSPL

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    INTEGER NRMGT,NZ,NLYR,SXLYR,RXLYR,KFG,JZ
    REAL (KIND=QL) ZR,ZS,THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR)
    REAL RHOTRP(NRMGT),ZV(NZ)
    REAL, DIMENSION (4,NRMGT) :: QR,QI
    REAL, DIMENSION (4,NRMGT,NZ) :: QB1R,QB2R,QB3R,QB4R,QB5R,QB1I,QB2I,QB3I,QB4I,QB5I
    COMPLEX (KIND=QL) KSQL(NLYR),SIGL(NLYR),MHRI(NRMGT,5)

    QB1R = 0.; QB2R = 0.; QB3R = 0.; QB4R = 0.; QB5R = 0.;
    QB1I = 0.; QB2I = 0.; QB3I = 0.; QB4I = 0.; QB5I = 0.;


    DO JZ = 1,NZ
       ZS = REAL(ZV(JZ),QL)
       CALL MGT_HNK (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,SIGL,KSQL,RMUD,ZR,ZS,MHRI)

       QR(1,1:NRMGT) =        REAL (MHRI(1:NRMGT,1), 4)
       QI(1,1:NRMGT) = REAL (AIMAG (MHRI(1:NRMGT,1)), 4)
       CALL CUBSPL (RHOTRP,QR,NRMGT)
       CALL CUBSPL (RHOTRP,QI,NRMGT)
       QB1R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
       QB1I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

       QR(1,1:NRMGT) =        REAL (MHRI(1:NRMGT,2), 4)
       QI(1,1:NRMGT) = REAL (AIMAG (MHRI(1:NRMGT,2)), 4)
       CALL CUBSPL (RHOTRP,QR,NRMGT)
       CALL CUBSPL (RHOTRP,QI,NRMGT)
       QB2R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
       QB2I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

       QR(1,1:NRMGT) =        REAL (MHRI(1:NRMGT,3), 4)
       QI(1,1:NRMGT) = REAL (AIMAG (MHRI(1:NRMGT,3)), 4)
       CALL CUBSPL (RHOTRP,QR,NRMGT)
       CALL CUBSPL (RHOTRP,QI,NRMGT)
       QB3R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
       QB3I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

       IF (RXLYR > 0) THEN
          QR(1,1:NRMGT) =        REAL (MHRI(1:NRMGT,4), 4)
          QI(1,1:NRMGT) = REAL (AIMAG (MHRI(1:NRMGT,4)), 4)
          CALL CUBSPL (RHOTRP,QR,NRMGT)
          CALL CUBSPL (RHOTRP,QI,NRMGT)
          QB4R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
          QB4I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

          QR(1,1:NRMGT) =        REAL (MHRI(1:NRMGT,5), 4)
          QI(1,1:NRMGT) = REAL (AIMAG (MHRI(1:NRMGT,5)), 4)
          CALL CUBSPL (RHOTRP,QR,NRMGT)
          CALL CUBSPL (RHOTRP,QI,NRMGT)
          QB5R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
          QB5I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)
       END IF
    END DO

  END SUBROUTINE MGT_CSPL

  SUBROUTINE MGTDIR (XD,YD,ZD,KB,MUB,PSI)
    !---------------------------------------

    !***  Called by MGT_BOSS

    !  Computes PSI, the direct whole space magnetic field (B in Teslas) when magnetic
    !  dipole receivers are in the same layer as the electric dipole sources.
    !  KB & MUB are the propagation constant * relative megnetic permeability
    !  of the whole space.
    !
    !  XD,YD,ZD are the x,y & z spacings between electric dipole Tx
    !           and magnetic dipole receiver
    !
    !  PSI is the magnetic field in Teslas
    !  It uses VFAC = mu0 * RMUD(NLYR) / (4 Pi) = 1.e-7 * 4*Pi / (4 Pi)
    !               = 1.e-7 * RMUD(NLYR)

    !  PSI(1) = whole space Myz (+) and Mzy (-).
    !  PSI(2) = whole space Mzx (+) and Mxz (-).
    !  PSI(3) = whole space Mxy (+) and Myx (-).

    IMPLICIT NONE
    REAL, PARAMETER :: VFAC0=1.e-7
    REAL XD,YD,ZD,R,MUB
    COMPLEX PSI(3),KB,BASE


    R = SQRT (XD**2 + YD**2 + ZD**2)
    IF (R < 1.E-10) THEN
       WRITE(*,'(/3X,A)') 'Magnetic dipole receiver cannot touch plate.  Computation aborted!'
       STOP
    END IF

    BASE = MUB * VFAC0 * ((1.,0.) + (KB*R)) * EXP(-KB*R) / R**3
    PSI(1) = XD * BASE
    PSI(2) = YD * BASE
    PSI(3) = ZD * BASE

  END SUBROUTINE MGTDIR

  SUBROUTINE MGT_HNK (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,SIGL,KSQL,RMUD,ZR,ZS,MHRI)
    ! ------------------------------------------------------------------------------------------

    !***  Called by MGT_CSPL
    !***  Calls MGT_KER

    !  Sets up the five integrals MHRI (JR,J1), J1 = 1,5, needed to compute the
    !  magnetic Green's tensor elements in EGT_BOSS.  It uses the flow through
    !  Hankel transform method to compute values at RHOTRP(JR), (15 point per decade
    !  spacing).  It uses a 15 point per decade filter coefficient set derived from
    !  Christensen's program, FLTGEN.

    !  This SUBROUTINE returns MHRI for a magnetic field in Teslas
    !  It uses VFAC = mu0 / (4 Pi) = 1.e-7 * 4*Pi / (4 Pi) = 1.e-7

    !              INPUT
    !              -----
    !    RHOTRP - interpolation array of rho values
    !     NRMGT - number of interpolation points needed for MGT
    !      NLYR - number of layers
    !      THKD - layer thicknesses
    !     DPTHL - QL depth to top of each layer
    !      RMUD - QL precision relative magetic permeability
    !      SIGL - complex conductivity of layers
    !      KSQL - propagation constants
    !     RXLYR = layer containing receiver
    !        ZR - receiver depth (negative for receiver in air)
    !        ZS - depth of induced "source point" in plate

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL, 0._QL)
    REAL (KIND=QL), PARAMETER :: VFAC0=1.E-7_QL         ! Mu0 / 4 Pi
    INTEGER NLYR,SXLYR,RXLYR,KFG,NRMGT,L,JR,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,NINTG
    REAL RHOTRP(NRMGT)
    REAL (KIND=QL) DELTA,Y1,Y,RD,LMBDA,THKD(NLYR),DPTHL(NLYR),ZR,ZS,RMUD(0:NLYR),VFAC
    COMPLEX (KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    COMPLEX (KIND=QL) KER(JNLO-NRMGT:JNHI,5),MHRI(NRMGT,5)
    LOGICAL JUMP

    !  Initialise variables

    NINTG = 3
    VFAC = VFAC0

    IF (RXLYR > 0) THEN
       NINTG = 5
       VFAC = VFAC0 * REAL (RMUD(RXLYR))
    END IF

    MHRI = ZERO
    KER = ZERO
    DELTA = LOG (10._QL)/ REAL (NDEC_JN,QL)

    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = REAL (RHOTRP(1),QL)
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - SHFTJN

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       CALL MGT_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
            SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,MHRI,JUMP)

       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL MGT_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
            SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,MHRI,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the renge of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRMGT)

    JR = NRMGT
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - SHFTJN
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.
       MHRI(JR,1) = MHRI(JR,1) + KER(K,1) * WJ1(L)         ! Used for Mxx, Myy, Mxy, Myx
       MHRI(JR,2) = MHRI(JR,2) + KER(K,2) * WJ0(L)         ! Used for Mxx, Myy, Mxy, Myx
       MHRI(JR,3) = MHRI(JR,3) + KER(K,3) * WJ1(L)         ! Used for Mzx, Mzy
       MHRI(JR,4) = MHRI(JR,4) + KER(K,4) * WJ0(L)         ! Used for Mxy, Myx
       MHRI(JR,5) = MHRI(JR,5) + KER(K,5) * WJ1(L)         ! Used for Mxz, Myz
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (Y)
          CALL MGT_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
               SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,MHRI,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRMGT-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          MHRI(JR,1) = MHRI(JR,1) + KER(K,1) * WJ1(L)
          MHRI(JR,2) = MHRI(JR,2) + KER(K,2) * WJ0(L)
          MHRI(JR,3) = MHRI(JR,3) + KER(K,3) * WJ1(L)
          MHRI(JR,4) = MHRI(JR,4) + KER(K,4) * WJ0(L)
          MHRI(JR,5) = MHRI(JR,5) + KER(K,5) * WJ1(L)
       END DO
    END DO

    DO JR = 1,NRMGT
       MHRI(JR,1) = MHRI(JR,1) / RHOTRP(JR)
       MHRI(JR,1:5) = VFAC * MHRI(JR,1:5) / RHOTRP(JR)
    END DO

  END SUBROUTINE MGT_HNK

  SUBROUTINE MGT_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
       SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,MHRI,JUMP)
    !-------------------------------=--------------------------------------

    !***  Called by MGT_HNK

    !  Accumulates the integrals MHRI(J) (J=1,5) for 5 inverse Hankel transforms
    !  needed for evaluation of magnetic Green's tensor elements.

    !     NRMGT - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !     RXLYR = layer containing receiver
    !       KFG = 0, 3, or 1 if Rx is in air, basement or intermediate layer respectively
    !      NLYR - number of layers
    !      THKD - layer thicknesses
    !     DPTHL - QL depth to top of each layer
    !      SIGL - complex conductivity of layers
    !      KSQL - propagation constants
    !        ZR - receiver depth (negative for receiver in air)
    !        ZS - depth of induced "source point" in plate

    !   MHRI(J) - accumulated integrals for real and imaginary parts
    !             of inverse Hankel transform (J = 1,5)
    !      JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER NINTG,NRMGT,K,JR,L,SXLYR,RXLYR,NLYR,KFG,J
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,ZS,ZR,AR,AI,MHR,MHI
    REAL(KIND=QL), DIMENSION (NLYR) ::  THKD,DPTHL
    COMPLEX(KIND=QL) S(0:NLYR),SM,SL,XI_V,F_V,F_H,ETA_V,G_V,G_H,FACV,KVS,KS,KV,EU,ED, &
         FACJ1,KER(JNLO-NRMGT:JNHI,5),MHRI(NRMGT,5),TMP(5)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    KER(K,1:5) = ZERO
    CALL EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)

    SM = S(SXLYR)
    SL = S(RXLYR)
    FACV = RMUD(SXLYR) * SL / (RMUD(RXLYR) * SM)
    FACJ1 = LMBDA**2 / SM

    IF (RXLYR == 0) THEN                            ! Rx in Air
       KER(K,1) = FACV * XI_V * EXP (SL * ZR)
       KER(K,2) = KER(K,1) * LMBDA
       KER(K,3) = KER(K,2)

    ELSE IF (RXLYR == NLYR) THEN                    ! Rx in Basement
       ED = EXP (SM * (DPTHL(NLYR) - ZR))
       ETA_V = ED * ETA_V
       G_V   = ED * G_V
       G_H   = ED * G_H
       KVS = -(FACV * ETA_V + G_H)
       KER(K,1) = KVS
       KER(K,2) = KVS * LMBDA
       KER(K,3) = ETA_V * FACJ1
       KER(K,4) = G_H * LMBDA
       KER(K,5) = G_V * FACJ1

    ELSE                                            ! Rx in intermediate layer
       EU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
       ED = EXP (SL * (DPTHL(RXLYR) - ZR))

       XI_V  = EU * XI_V
       ETA_V = ED * ETA_V
       F_V   = EU * F_V
       G_V   = ED * G_V
       F_H   = EU * F_H
       G_H   = ED * G_H
       KS = F_H + G_H
       KV = FACV * (XI_V - ETA_V)
       KVS = KV - KS
       KER(K,1) = KVS
       KER(K,2) = KVS * LMBDA
       KER(K,3) = (XI_V + ETA_V) * FACJ1
       KER(K,4) = KS * LMBDA
       KER(K,5) = (F_V + G_V) * FACJ1
    END IF

    TMP(1) =  KER(K,1) * WJ1(L)
    TMP(2) =  KER(K,2) * WJ0(L)
    TMP(3) =  KER(K,3) * WJ1(L)
    TMP(4) =  KER(K,4) * WJ0(L)
    TMP(5) =  KER(K,5) * WJ1(L)

    ! Accumulate 5 (3 for receiver in air) integrals simultaneously
    ! until convergence of all.

    JUMP = .TRUE.
    DO J = 1, NINTG
       MHRI(JR,J) = MHRI(JR,J) + TMP(J)
       AR = ABS (REAL (TMP(J)))
       AI = ABS (AIMAG (TMP(J)))
       MHR = ABS (REAL (MHRI(JR,J)))
       MHI = ABS (AIMAG (MHRI(JR,J)))
       TOO_BIG = .FALSE.
       IF (AR > TOL* MHR) TOO_BIG = .TRUE.
       IF (AI > TOL* MHI) TOO_BIG = .TRUE.
       IF (TOO_BIG) JUMP = .FALSE.
    END DO

  END SUBROUTINE MGT_KER

  SUBROUTINE EGTRX_BOSS (NPLT,PLYR,MXAB,NA,NB,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL,NLYR,THKD, &
       DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS,ZRXTX,   &
       WTRS,NRMGT,RHOTRP,NZ1,ZV1,NMGP,XMG,YMG,ZMG,WMG,HA,HB)
    !--------------------------------------------------------------------------------------------

    !***  Called by SCAT_EM
    !***  Calls EGTRX_CSPL

    !  Integrated electric Green's tensor computation for relating the along strike
    !  and down dip components of the scattering current for each plate to the
    !  X, Y electric fields at each surface receiver of each transmitter.
    !  A 9 point per cell rule with uniform weights is used.

    !                        INPUT
    !                        -----
    !
    !                 NPLT - Number of plates
    !                 PLYR - layer containing plate
    !                 MXAB - Number of cells in biggest plate
    !               NA, NB - number of cells along strike and down dip respectively
    !                PLAZM - strike angle
    !                PLDIP - plate dipS (radians)
    !                PLUNJ - rotation
    !                  WMG - integration weights for each plate
    !                 NMGP - number of integration points per cell
    !        XMG, YMG, ZMG - integration points relative to cell centre, in plane of plate
    !  XCELL, YCELL, ZCELL - cell centre locations in the observer system.
    !
    !        NLYR - number of layers including overburden.
    !        THKD - QL precision layer thicknesses
    !       DPTHL - QL depth to top of each layer
    !        RMUD - QL precision relative magetic permeability
    !        SIGL - QL precision complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - QL precision iwu * SIGL for all layers (includes Cole-Cole)
    !         NTX - QL number of transmitters
    !       NRXTX - number of receivers per transmitter (max = MRXTX)
    !        RXID - identifies type of receiver: 1 = mag dipole;  2 = electric dipole
    !         NRS - number of subnet receivers per receiver (max = MXRS)
    !    XRS, YRS - North, East coordinates of receiver subnet for plate JP
    !        WTRS - subnet receiver weights
    !       NRMGT - Dimension for MGT interpolations
    !      RHOTRP - horizontal interpolation array for MGT
    !    ZV1(NZ1) - vertical interpolation array

    !               OUTPUT
    !               ------

    !  HA(JAB,I,JR,JS) is the I-th component of the electric field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    strike direction in the centre of plate cell number JAB.

    !  HB(JAB,I,JR,JS) is the I-th component of the electric field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    dip direction in the centre of plate cell number JAB.
    !
    !                    I = 1   is the North component
    !                    I = 2   is the East component
    !                    I = 3   is the vertical component

    !  HA & HB are thus combinations of electric Green's tensor elements
    !  integrated over the area of individual cells.

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NINTG,NPLT,MXAB,NLYR,SXLYR,RXLYR,KFG,NTX,MRXTX,NRXTX(NTX),MXRS, &
         NRS(MRXTX,NTX),NRMGT,NZ1,NMGP,JA,JB,JP,JR,JR1,JS,JAB,J1,I1,RXID(MRXTX,NTX)
    INTEGER, DIMENSION (NPLT) :: NA,NB,PLYR
    REAL RHOTRP(NRMGT),ZV1(NZ1),R32(3,2),CD,SD,CP,SP,CA,SA,XD,YD,ZS,ZD,RHO,XBAR,YBAR,RXVRT
    REAL, DIMENSION (MXRS,MRXTX,NTX) :: XRS,YRS,WTRS
    REAL, DIMENSION (MRXTX,NTX) :: ZRXTX
    REAL (KIND=QL) THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR),ZPRV,ZR
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ,WMG
    REAL, DIMENSION (MXAB,NPLT) :: XCELL,YCELL,ZCELL
    REAL, DIMENSION (NMGP,NPLT) :: XMG,YMG,ZMG
    REAL, DIMENSION (4,NRMGT,NZ1) :: QB1R,QB1I,QB2R,QB2I,QB3R,QB3I,QB4R,QB4I,QB5R,QB5I,QB6R,QB6I
    COMPLEX KB,EGT(3,3),EGTR(3,2),QQ(6),EXX,EXY,EXZ,EYY,EYZ,EZZ
    COMPLEX, DIMENSION (MXAB,3,MRXTX,NTX,NPLT) :: HA,HB
    COMPLEX(KIND=QL) KSQL(NLYR), SIGL(NLYR)

    KB = CMPLX (SQRT (KSQL(NLYR)) )
    IF (REAL (KB) < 0.) KB = -KB

    !  Step down dip cell row by cell row, and within each row, one integration
    !  line at a time.  Then step through receivers.  Set up the base integrals,
    !  QB*j for each line - receiver height combination.
    !  If next receiver has the same height, retain base integrals.

    ZPRV = -9.D4
    DO JS = 1,NTX                        ! Loop over transmitters
       DO JR = 1, NRXTX(JS)               ! Loop over receivers
          IF (RXID(JR,JS) == 1) THEN
             CYCLE                          ! This SUBROUTINE is only used for electric fields
          ELSE IF (RXID(JR,JS) == 2) THEN  ! Horizontal electric dipole receiver
             NINTG = 4
          ELSE IF (RXID(JR,JS) == 3) THEN  ! 3 components of the electric field
             NINTG = 6
          END IF

          ZR = REAL (ZRXTX(JR,JS),QL)
          ZR = MAX (0.001D0,ZR)               ! Electrodes must be in contact with earth
          RXVRT = REAL (ABS (ZPRV - ZR))
          IF (RXVRT > .01_QL) THEN
             ZPRV = ZR
             RXLYR = 1
             DO J1 = NLYR,2,-1
                IF (ZR > DPTHL(J1)) THEN
                   RXLYR = J1
                   EXIT
                END IF
             END DO
             I1 = 2
             SXLYR = NLYR
             CALL SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)
             CALL EGTRX_CSPL (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZR,NZ1,ZV1, &
                  NINTG,QB1R,QB1I,QB2R,QB2I,QB3R,QB3I,QB4R,QB4I,QB5R,QB5I,QB6R,QB6I)
          END IF


          DO JP = 1,NPLT                        ! Loop over plates
             IF (PLYR(JP) < NLYR) CYCLE
             CA = COS (PLAZM(JP))
             SA = SIN (PLAZM(JP))
             CD = COS (PLDIP(JP))
             SD = SIN (PLDIP(JP))
             CP = COS (PLUNJ(JP))
             SP = SIN (PLUNJ(JP))
             CALL RPLT2XYZ (CA,SA,CD,SD,CP,SP,R32)  ! Rotation matrix

             DO JB = 1,NB(JP)                       ! Loop over cell rows
                DO JA = 1, NA(JP)                    ! Loop over cell columns
                   JAB = JA + ((JB-1) * NA(JP))
                   EGT = ZERO
                   DO J1 = 1,NMGP                ! Loop over cell integration points
                      ZS = ZCELL(JAB,JP) + ZMG(J1,JP)
                      ZD = REAL (ZR) - ZS
                      DO JR1 = 1, NRS(JR,JS)      ! Loop over receiver segments
                         XD = XRS(JR1,JR,JS) - (XCELL(JAB,JP) + XMG(J1,JP))
                         YD = YRS(JR1,JR,JS) - (YCELL(JAB,JP) + YMG(J1,JP))

                         RHO = SQRT (XD**2 + YD**2)
                         RHO = MAX (RHO, RHOTRP(1))

                         ! Note that C2DINTRP uses ZS rather than ZD because MGT_CSPL is called as a
                         ! FUNCTION of ZR.  The interpolants are then stored as a FUNCTION of ZS
                         ! for each value of ZR.    Of course, this is a moot point since the
                         ! restriction ZR = 0 is used in this version.

                         QQ(1) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB1R,QB1I,RHO,ZS)
                         QQ(2) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB2R,QB2I,RHO,ZS)
                         QQ(3) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB3R,QB3I,RHO,ZS)
                         QQ(4) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB4R,QB4I,RHO,ZS)
                         QQ(1:4) = QQ(1:4) * WTRS(JR1,JR,JS)   !  weight receiver subnet points
                         XBAR = 0.
                         YBAR = 0.
                         IF (RHO > 1.E-6) THEN
                            XBAR = XD / RHO
                            YBAR = YD / RHO
                         END IF

                         EXX = ZERO; EYY = ZERO; EZZ = ZERO
                         EXY = ZERO; EXZ = ZERO; EYZ = ZERO
                         IF (RXLYR == NLYR) CALL EGTRX_DIR (XD,YD,ZD,KB,EXX,EXY,EXZ,EYY,EYZ,EZZ)

                         EGT(1,1) = EGT(1,1) + QQ(1)* (1. - 2.*XBAR**2) + QQ(2) * XBAR**2 - QQ(3) + EXX
                         EGT(2,2) = EGT(2,2) + QQ(1)* (1. - 2.*YBAR**2) + QQ(2) * YBAR**2 - QQ(3) + EYY
                         EGT(1,2) = EGT(1,2) + XBAR * YBAR * (QQ(2) - 2.* QQ(1)) + EXY
                         EGT(1,3) = EGT(1,3) - XBAR * QQ(4) + EXZ
                         EGT(2,3) = EGT(2,3) - YBAR * QQ(4) + EYZ

                         IF (NINTG == 6) THEN       ! Compute vertical field components
                            QQ(5) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB5R,QB5I,RHO,ZS)
                            QQ(6) = C2DINTRP (RHOTRP,NRMGT,ZV1,NZ1,QB6R,QB6I,RHO,ZS)
                            EGT(3,1) = EXZ - QQ(5) * XBAR
                            EGT(3,2) = EYZ - QQ(5) * YBAR
                            EGT(3,3) = EZZ + QQ(6)
                         END IF
                      END DO                       ! End JR1 loop over receiver subnet
                   END DO                         ! End J1 loop over cell integration points

                   ! Rotate EGT from XYZ-XYZ TO XYZ-PLT system.  Apply plate weighting for each cell.

                   EGT(2,1) = EGT(1,2)
                   EGTR = MATMUL (EGT, R32) * WMG(JP)
                   HA(JAB,1:3,JR,JS,JP) = HA(JAB,1:3,JR,JS,JP) + EGTR(1:3,1)
                   HB(JAB,1:3,JR,JS,JP) = HB(JAB,1:3,JR,JS,JP) + EGTR(1:3,2)

                END DO                           ! End JR loop over cell columns
             END DO                             ! End JS loop over cell rows
          END DO                               ! End JB loop over plates
       END DO                                 ! End JB loop over receivers
    END DO                                   ! End JP loop over transmitters

    !  HA(JAB,3,JR,JS,JP) = ZERO ;  HB(JAB,3,JR,JS,JP) = ZERO

  END SUBROUTINE EGTRX_BOSS

  SUBROUTINE EGTRX_BOSS_UL (JP,SXLYR,NPLT,MXAB,NAL,NBL,DAL,DBL,PLAZM,PLDIP,XCELL,YCELL,NLYR, &
       THKD,DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS, &
       ZRXTX,WTRS,NRMGT,RHOTRP,NZ3L,ZC3L,HA,HB)
    !--------------------------------------------------------------------------------------------

    !***  Called by SCAT_EM
    !***  Calls EGTRX_CSPL

    !  This rutine is used for plates above basement one at a time.
    !
    !  Integrated electric Green's tensor computation for relating the along strike
    !  and down dip components of the scattering current for each plate to the
    !  X, Y electric fields at each surface receiver of each transmitter.
    !  A 9 point per cell rule with uniform weights is used.

    !                 INPUT
    !                 -----
    !
    !            JP - plate index
    !          NPLT - Number of plates
    !          PLYR - layer containing plate
    !          MXAB - Number of cells in biggest plate
    !        NA, NB - number of cells along strike and down dip respectively
    !         PLAZM - plate strike angles
    !         PLDIP - plate dips
    !  XCELL, YCELL - cell centre locations in the observer system.
    !          NLYR - number of layers including overburden.
    !          THKD - QL precision layer thicknesses
    !         DPTHL - QL depth to top of each layer
    !          RMUD - QL precision relative magetic permeability
    !          SIGL - QL precision complex xconductivity for all layers including Cole-Cole & dielectric
    !          KSQL - QL precision iwu * SIGL for all layers (includes Cole-Cole)
    !           NTX - number of transmitters
    !         NRXTX - number of receivers per transmitter (max = MRXTX)
    !          RXID - identifies type of receiver: 1 = mag dipole;  2 = electric dipole
    !           NRS - number of subnet receivers per receiver (max = MXRS)
    !      XRS, YRS - North, East coordinates of receiver subnet for plate JP
    !          WTRS - subnet receiver weights
    !         NRMGT - Dimension for MGT interpolations
    !        RHOTRP - horizontal interpolation array for MGT
    !    ZV3L(NZ3L) - vertical interpolatin array
    !
    !               OUTPUT
    !               ------
    !  HA(JAB,I,JR,JS) is the I-th component of the electric field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    strike direction in the centre of plate cell number JAB.

    !  HB(JAB,I,JR,JS) is the I-th component of the electric field of receiver JR of
    !                    transmitter JS produced by a unitary electric dipole in the
    !                    dip direction in the centre of plate cell number JAB.

    !                    I = 1   is the North component
    !                    I = 2   is the East component
    !                    I = 3   is the vertical component

    !  HA & HB are thus combinations of electric Green's tensor elements
    !  integrated over the area of individual cells.

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NAL,NBL,NZ3L,NINTG,NPLT,MXAB,NLYR,SXLYR,RXLYR,KFG,NTX,MRXTX,NRXTX(NTX),MXRS, &
         NRS(MRXTX,NTX),NRMGT,JA,JB,JP,JR,JZ,JR1,JS,JAB,J1,J2,I1,RXID(MRXTX,NTX)
    REAL DAL,DBL,RHOTRP(NRMGT),ZC3L(NZ3L),R32(3,2),SD,CD,CP,SP,CS,SS,XS,YS,ZS,XD,YD,ZD,RHO, &
         XBAR,YBAR,RXVRT,DELX,DELY,WMG
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP
    REAL, DIMENSION (MXAB,NPLT) :: XCELL,YCELL
    REAL, DIMENSION (MXRS,MRXTX,NTX) :: XRS,YRS,WTRS
    REAL, DIMENSION (MRXTX,NTX) :: ZRXTX
    REAL (KIND=QL) ZR,ZPRV,THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR)
    REAL, DIMENSION (4,NRMGT,NZ3L) :: G1R,G1I,G2R,G2I,G3R,G3I,G4R,G4I,G5R,G5I,G6R,G6I
    COMPLEX KB,EGT(3,3),EGTR(3,2),QQ(6),EXX,EXY,EXZ,EYY,EYZ,EZZ
    COMPLEX(KIND=QL) KSQL(NLYR), SIGL(NLYR)
    COMPLEX, DIMENSION (MXAB,3,MRXTX,NTX,NPLT) :: HA,HB

    KB = CMPLX (SQRT (KSQL(SXLYR)) )
    IF (REAL (KB) < 0.) KB = -KB
    CS = COS (PLAZM(JP))
    SS = SIN (PLAZM(JP))
    CD = COS (PLDIP(JP))
    SD = SIN (PLDIP(JP))
    CP = 1.0
    SP = 0.0
    CALL RPLT2XYZ (CS,SS,CD,SD,CP,SP,R32)  ! Rotation matrix

    DELX = DAL / 4.
    DELY = CD * DBL / 4.
    WMG = DAL * DBL / 9.     ! 9 point rule

    !  Step down dip cell row by cell row, and within each row, one integration
    !  line at a time.  Then step through receivers.  Set up the base integrals,
    !  G*j for each line - receiver height combination.
    !  If next receiver has the same height, retain base integrals.

    ZPRV = -9.D4
    DO JS = 1,NTX                        ! Loop over transmitters
       DO JR = 1, NRXTX(JS)               ! Loop over receivers
          IF (RXID(JR,JS) == 1) THEN
             CYCLE                          ! This SUBROUTINE is only used for electric fields
          ELSE IF (RXID(JR,JS) == 2) THEN  ! Horizontal electric dipole receiver
             NINTG = 4
          ELSE IF (RXID(JR,JS) == 3) THEN  ! 3 components of the electric field
             NINTG = 6
          END IF

          ZR = REAL (ZRXTX(JR,JS),QL)
          ZR = MAX (0.001D0,ZR)               ! Electrodes must be in contact with earth
          RXVRT = REAL (ABS (ZPRV - ZR))
          IF (RXVRT > .01_QL) THEN
             ZPRV = ZR
             RXLYR = 1
             DO J1 = NLYR,2,-1
                IF (ZR > DPTHL(J1)) THEN
                   RXLYR = J1
                   EXIT
                END IF
             END DO
             I1 = 2
             CALL SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)
             CALL EGTRX_CSPL (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZR,NZ3L, &
                  ZC3L,NINTG,G1R,G1I,G2R,G2I,G3R,G3I,G4R,G4I,G5R,G5I,G6R,G6I)
          END IF

          DO JB = 1,NBL
             DO JA = 1, NAL                    ! Loop over cell columns
                JAB = JA + (JB-1) * NAL
                EGT = ZERO
                DO J1 = -1,1                         ! Loop over horizontal cell integration points
                   JZ = 3*JB + J1 - 1
                   ZS = ZC3L(JZ)
                   YS = YCELL(JAB,JP) + J1 * DELY
                   ZD = REAL (ZR) - ZS
                   DO J2 = -1,1                     ! Loop over horizontal cell integration points
                      XS = XCELL(JAB,JP) + J2 * DELX
                      DO JR1 = 1, NRS(JR,JS)           ! Loop over receiver subnet
                         XD = XRS(JR1,JR,JS) - XS
                         YD = YRS(JR1,JR,JS) - YS

                         RHO = SQRT (XD**2 + YD**2)
                         RHO = MAX (RHO, RHOTRP(1))

                         CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G1R,G1I,RHO,JZ,QQ(1))
                         CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G2R,G2I,RHO,JZ,QQ(2))
                         CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G3R,G3I,RHO,JZ,QQ(3))
                         CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G4R,G4I,RHO,JZ,QQ(4))
                         QQ(1:4) = QQ(1:4) * WTRS(JR1,JR,JS)   !  weight receiver subnet points
                         XBAR = 0.
                         YBAR = 0.
                         IF (RHO > 1.E-6) THEN
                            XBAR = XD / RHO
                            YBAR = YD / RHO
                         END IF

                         EXX = ZERO; EYY = ZERO; EZZ = ZERO
                         EXY = ZERO; EXZ = ZERO; EYZ = ZERO
                         IF (RXLYR == SXLYR) CALL EGTRX_DIR (XD,YD,ZD,KB,EXX,EXY,EXZ,EYY,EYZ,EZZ)

                         EGT(1,1) = EGT(1,1) + QQ(1)* (1. - 2.*XBAR**2) + QQ(2) * XBAR**2 - QQ(3) + EXX
                         EGT(2,2) = EGT(2,2) + QQ(1)* (1. - 2.*YBAR**2) + QQ(2) * YBAR**2 - QQ(3) + EYY
                         EGT(1,2) = EGT(1,2) + XBAR * YBAR * (QQ(2) - 2.* QQ(1)) + EXY
                         EGT(1,3) = EGT(1,3) - XBAR * QQ(4) + EXZ
                         EGT(2,3) = EGT(2,3) - YBAR * QQ(4) + EYZ

                         IF (NINTG == 6) THEN       ! Compute vertical field components
                            CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G5R,G5I,RHO,JZ,QQ(5))
                            CALL CUBVALRZ (RHOTRP,NRMGT,NZ3L,G6R,G6I,RHO,JZ,QQ(6))
                            EGT(3,1) = EXZ - QQ(5) * XBAR
                            EGT(3,2) = EYZ - QQ(5) * YBAR
                            EGT(3,3) = EZZ + QQ(6)
                         END IF
                      END DO              ! End JR1 loop over receiver subnet
                   END DO                ! End J2 loop over horizontal integration points
                END DO                  ! End J1 loop over vertical integration points

                ! Rotate EGT from XYZ-XYZ TO XYZ-PLT system.  Apply plate weighting for each cell.

                EGT(2,1) = EGT(1,2)
                EGTR = MATMUL (EGT, R32) * WMG
                HA(JAB,1:3,JR,JS,JP) = HA(JAB,1:3,JR,JS,JP) + EGTR(1:3,1)
                HB(JAB,1:3,JR,JS,JP) = HB(JAB,1:3,JR,JS,JP) + EGTR(1:3,2)

             END DO                    ! End JA loop over columns
          END DO                      ! End JB loop over rows
       END DO                        ! End JR loop over receivers
    END DO                          ! End JS loop over transmitters

    !  HA(JAB,3,JR,JS,JP) = ZERO ;  HB(JAB,3,JR,JS,JP) = ZERO

  END SUBROUTINE EGTRX_BOSS_UL

  SUBROUTINE EGTRX_DIR (XD,YD,ZD,KB,EXX,EXY,EXZ,EYY,EYZ,EZZ)
    !-----------------------------------------------------------
    !
    !*** Called by EGTRX_BOSS

    !  Computes the whole space dipole electric fields for cases when the receiver
    !  and 'source are in the same layer.

    REAL XD,YD,ZD,XB,YB,ZB,R
    COMPLEX KB,EXX,EXY,EXZ,EYY,EYZ,EZZ,KR,R11,R12,KRX
    COMPLEX, PARAMETER :: ONE=(1.,0.), THREE=(3.,0.)

    R = SQRT (XD**2 + YD**2 + ZD**2)
    XB = XD / R
    YB = YD / R
    ZB = ZD / R
    IF (R < 1.E-10) THEN
       WRITE(*,'(/3X,A)') 'Grounded wire receiver cannot touch plate.  Computation aborted!'
       STOP
    END IF
    KR = KB * R

    R11 = ONE + KR + KR**2
    R12 = THREE + THREE * KR + KR**2
    KRX = EXP (-KR) / KR**3

    EXX = KRX * (XB**2 * R12 - R11)
    EYY = KRX * (YB**2 * R12 - R11)
    EZZ = KRX * (ZB**2 * R12 - R11)
    EXY = XB * YB * KRX * R12
    EXZ = XB * ZB * KRX * R12
    EYZ = YB * ZB * KRX * R12

  END SUBROUTINE EGTRX_DIR

  SUBROUTINE EGTRX_CSPL (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,ZR,NZ,ZV, &
       NINTG,QB1R,QB1I,QB2R,QB2I,QB3R,QB3I,QB4R,QB4I,QB5R,QB5I,QB6R,QB6I)
    !---------------------------------------------------------------------------------------------

    !  Computes QBjR, and QBjI (j = 1,4) the real and imaginary parts of the
    !  base Hankel transform integrals for specified ZS for the full
    !  range of horizontal distances between receivers and points in the plate.
    !  These are splined and used to compute electric Green's tensor elements.

    !                  INPUT
    !                  -----
    !         NRMGT - number of points in RHOTRP needed for EGTRX computation
    !        RHOTRP - abscissa array for interpolation in horizontal direction
    !          NLYR - number of layers including overburden.
    !          SIGL - complex conductivities of air, overburden and host
    !          KSQL - i * omega * mu * conductivity for each layer
    !          THKD - layer thicknesses
    !            ZS - depth of induced "source point" in plate
    !         NINTG - number of integrals for filter evaluation


    !***  Called by EGTRX_BOSS
    !***  Calls EGTRX_HNK, CUBSPL

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    INTEGER NRMGT,KFG,SXLYR,RXLYR,NLYR,JZ,NZ,NINTG
    REAL (KIND=QL) ZS,ZR,THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR)
    REAL RHOTRP(NRMGT),ZV(NZ)
    REAL, DIMENSION (4,NRMGT) :: QR,QI
    REAL, DIMENSION (4,NRMGT,NZ) :: QB1R,QB1I,QB2R,QB2I,QB3R,QB3I,QB4R,QB4I,QB5R,QB5I,QB6R,QB6I
    COMPLEX (KIND=QL) EHRI(NRMGT,6)
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL

    QB1R = 0.; QB2R = 0.; QB3R = 0.; QB4R = 0.; QB5R = 0.; QB6R = 0.
    QB1I = 0.; QB2I = 0.; QB3I = 0.; QB4I = 0.; QB5I = 0.; QB6I = 0.

    DO JZ = 1,NZ
       ZS = REAL(ZV(JZ),QL)
       CALL EGTRX_HNK (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,SIGL,KSQL,RMUD,ZR,ZS,NINTG,EHRI)

       QR(1,1:NRMGT) =        REAL (EHRI(1:NRMGT,1), 4)
       QI(1,1:NRMGT) = REAL (AIMAG (EHRI(1:NRMGT,1)), 4)
       CALL CUBSPL (RHOTRP,QR,NRMGT)
       CALL CUBSPL (RHOTRP,QI,NRMGT)
       QB1R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
       QB1I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

       QR(1,1:NRMGT) =        REAL (EHRI(1:NRMGT,2), 4)
       QI(1,1:NRMGT) = REAL (AIMAG (EHRI(1:NRMGT,2)), 4)
       CALL CUBSPL (RHOTRP,QR,NRMGT)
       CALL CUBSPL (RHOTRP,QI,NRMGT)
       QB2R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
       QB2I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

       QR(1,1:NRMGT) =        REAL (EHRI(1:NRMGT,3), 4)
       QI(1,1:NRMGT) = REAL (AIMAG (EHRI(1:NRMGT,3)), 4)
       CALL CUBSPL (RHOTRP,QR,NRMGT)
       CALL CUBSPL (RHOTRP,QI,NRMGT)
       QB3R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
       QB3I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

       QR(1,1:NRMGT) =        REAL (EHRI(1:NRMGT,4), 4)
       QI(1,1:NRMGT) = REAL (AIMAG (EHRI(1:NRMGT,4)), 4)
       CALL CUBSPL (RHOTRP,QR,NRMGT)
       CALL CUBSPL (RHOTRP,QI,NRMGT)
       QB4R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
       QB4I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)


       IF (NINTG == 6) THEN
          QR(1,1:NRMGT) =        REAL (EHRI(1:NRMGT,5), 4)
          QI(1,1:NRMGT) = REAL (AIMAG (EHRI(1:NRMGT,5)), 4)
          CALL CUBSPL (RHOTRP,QR,NRMGT)
          CALL CUBSPL (RHOTRP,QI,NRMGT)
          QB5R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
          QB5I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)

          QR(1,1:NRMGT) =        REAL (EHRI(1:NRMGT,6), 4)
          QI(1,1:NRMGT) = REAL (AIMAG (EHRI(1:NRMGT,6)), 4)
          CALL CUBSPL (RHOTRP,QR,NRMGT)
          CALL CUBSPL (RHOTRP,QI,NRMGT)
          QB6R(1:4,1:NRMGT,JZ) = QR(1:4,1:NRMGT)
          QB6I(1:4,1:NRMGT,JZ) = QI(1:4,1:NRMGT)
       END IF

    END DO

  END SUBROUTINE EGTRX_CSPL

  SUBROUTINE EGTRX_HNK (NRMGT,RHOTRP,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL,SIGL,KSQL,RMUD,ZR,ZS,NINTG,EHRI)
    !----------------------------------------------------------------------------------------------------

    !***  Called by EGTRX_CSPL
    !***  Calls EGTRX_KER

    !  Sets up the five integrals EHRI (JR,J1), J1 = 1,4, needed to compute the
    !  electric Green's tensor elements in EGTRX_BOSS.  It uses the flow through
    !  Hankel transform method to compute values at RHOTRP(JR), (15 point per decade
    !  spacing).  It uses a 15 point per decade filter coefficient set derived from
    !  Christensen's program, FLTGEN.

    !  This SUBROUTINE returns EHRI for a electric field in nT
    !  It uses VFAC = 1.e9 * mu0 / (4 Pi) = 1.e9 * 1.e-7 * 4*Pi / (4 Pi) = 100

    !              INPUT
    !              -----
    !    RHOTRP - interpolation array of rho values
    !     NRMGT - number of interpolation points needed for EGTRX
    !      NLYR - number of layers
    !      SIGL - complex conductivity of layers
    !      KSQL - propagation constants
    !      THKD - layer thicknesses
    !        ZS - depth of induced "source point" in plate
    !     NINTG - number of integrals for filter evaluation

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL(KIND=QL), PARAMETER :: FOURPI=12.56637_QL
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL, 0._QL)
    INTEGER NINTG,KFG,SXLYR,RXLYR,NLYR,NRMGT,L,JR,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,J
    REAL RHOTRP(NRMGT)
    REAL (KIND=QL) DELTA,Y1,Y,RD,LMBDA,ZR,ZS,THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR),RHOD
    COMPLEX (KIND=QL) KER(JNLO-NRMGT:JNHI,6),EHRI(NRMGT,6)
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    LOGICAL JUMP

    !  Initialise variables

    EHRI = ZERO
    KER = ZERO
    DELTA = LOG (10._QL)/ REAL (NDEC_JN,QL)

    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = REAL (RHOTRP(1),QL)
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - SHFTJN

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       CALL EGTRX_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
            SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,EHRI,JUMP)

       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL EGTRX_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
            SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,EHRI,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the renge of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRMGT)

    JR = NRMGT
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - SHFTJN
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.
       EHRI(JR,1) = EHRI(JR,1) + KER(K,1) * WJ1(L)
       EHRI(JR,2) = EHRI(JR,2) + KER(K,2) * WJ0(L)
       EHRI(JR,3) = EHRI(JR,3) + KER(K,3) * WJ0(L)
       DO J = 4,NINTG
          EHRI(JR,J) = EHRI(JR,J) + KER(K,J) * WJ1(L)
       END DO
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (Y)
          CALL EGTRX_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
               SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,EHRI,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRMGT-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          EHRI(JR,1) = EHRI(JR,1) + KER(K,1) * WJ1(L)
          EHRI(JR,2) = EHRI(JR,2) + KER(K,2) * WJ0(L)
          EHRI(JR,3) = EHRI(JR,3) + KER(K,3) * WJ0(L)
          DO J = 4,NINTG
             EHRI(JR,J) = EHRI(JR,J) + KER(K,J) * WJ1(L)
          END DO
       END DO
    END DO

    DO JR = 1,NRMGT
       RHOD = REAL (RHOTRP(JR),KIND=QL)
       EHRI(JR,1) = EHRI(JR,1) / RHOD
       EHRI(JR,1:NINTG) = EHRI(JR,1:NINTG) / (FOURPI * SIGL(RXLYR) * RHOD)
    END DO

  END SUBROUTINE EGTRX_HNK

  SUBROUTINE EGTRX_KER (NRMGT,K,JR,L,LMBDA,SXLYR,RXLYR,KFG,NLYR,THKD,DPTHL, &
       SIGL,KSQL,RMUD,ZR,ZS,NINTG,KER,EHRI,JUMP)
    ! --------------------------------------------------------------------------

    !***  Called by EGTRX_HNK

    !  Accumulates the integrals EHRI(J) (J=1,5) for 5 inverse Hankel transforms
    !  needed for evaluation of electric Green's tensor elements.

    !     NRMGT - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !      NLYR - number of layers
    !      SIGL - complex conductivity of layers
    !      KSQL - propagation constants
    !      THKD - layer thicknesses
    !        ZS - depth of induced "source point" in plate
    !     NINTG - number of integrals for filter evaluation
    !       KER - kernel holding filter computations
    !   EHRI(J) - accumulated integrals for real and imaginary parts
    !             of inverse Hankel transform (J = 1,5)
    !      JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL, 0._QL)
    INTEGER NINTG,NRMGT,K,JR,L,SXLYR,RXLYR,NLYR,KFG,J
    REAL (KIND=QL) RMUD(0:NLYR),LMBDA,LMBSQ,ZS,ZR,AR,AI,MHR,MHI
    REAL(KIND=QL), DIMENSION (NLYR) ::  THKD,DPTHL
    COMPLEX (KIND=QL) S(0:NLYR),SM,SL,XI_V,F_V,F_H,ETA_V,G_V,G_H,EU,ED,FACV,KF,KG,K4,K5,K6, &
         KER(JNLO-NRMGT:JNHI,6),EHRI(NRMGT,6),TMP(6)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    TMP = ZERO
    KER(K,1:6) = ZERO
    SXLYR = NLYR
    CALL EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)

    LMBSQ = LMBDA**2
    SM = S(SXLYR)
    SL = S(RXLYR)
    FACV = RMUD(SXLYR) * KSQL(RXLYR) / (RMUD(RXLYR) * SM)

    IF (RXLYR == NLYR) THEN                       ! Rx in Basement
       ED = EXP (SM * (DPTHL(NLYR) - ZR))
       ETA_V = ED * ETA_V
       G_V   = ED * G_V
       G_H   = ED * G_H
       KF = -SL * G_H
       KG = FACV * ETA_V
       K4 = -G_V
       K5 = G_H
       K6 = G_V

    ELSE                                           ! Rx in intermediate layer
       EU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
       ED = EXP (SL * (DPTHL(RXLYR) - ZR))
       XI_V  = EU * XI_V
       ETA_V = ED * ETA_V
       F_V   = EU * F_V
       G_V   = ED * G_V
       F_H   = EU * F_H
       G_H   = ED * G_H
       KG = FACV * (XI_V + ETA_V)
       KF = SL * (F_H - G_H)
       K4 = F_V - G_V
       K5 = F_H + G_H
       K6 = F_V + G_V

    END IF

    KER(K,1) = KG - KF
    KER(K,2) = KER(K,1) * LMBDA
    KER(K,3) = KG * LMBDA
    KER(K,4) = K4 * LMBSQ * SL / SM
    KER(K,5) = K5 * LMBSQ
    KER(K,6) = K6 * LMBDA**3 / SM

    TMP(1) =  KER(K,1) * WJ1(L)
    TMP(2) =  KER(K,2) * WJ0(L)
    TMP(3) =  KER(K,3) * WJ0(L)
    DO J = 4,NINTG
       TMP(J) =  KER(K,J) * WJ1(L)
    END DO

    ! Accumulate 4 integrals simultaneously until convergence of all.

    JUMP = .TRUE.
    DO J = 1, NINTG
       EHRI(JR,J) = EHRI(JR,J) + TMP(J)
       AR = ABS (REAL (TMP(J)))
       AI = ABS (AIMAG (TMP(J)))
       MHR = ABS (REAL (EHRI(JR,J)))
       MHI = ABS (AIMAG (EHRI(JR,J)))
       TOO_BIG = .FALSE.
       IF (AR > TOL* MHR) TOO_BIG = .TRUE.
       IF (AI > TOL* MHI) TOO_BIG = .TRUE.
       IF (TOO_BIG) JUMP = .FALSE.
    END DO

  END SUBROUTINE EGTRX_KER

  SUBROUTINE PRM_BOSS_LP (SOURCE_TYPE,NTX,MXVRTX,NVRTX,SXN,SXE,SXZ,NRPRM,RHOTRP,NLYR,  &
       THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB, &
       NB,NA,XCELL,YCELL,ZCELL,NZ1,ZV1,E_PRYM)
    ! ----------------------------------------------------------------------------------

    !***  Called by MAIN
    !***  Calls PRM_HNK_LP, PRM_HNK_FZ, CUBSPL, C2DINTRP, SETPRM

    !  This rutine is used for basement plates.  It is based on interpolated Green's
    !  that can be used for all plates in the basement simultaneously.
    !
    !  Computes the primary electric field, E_PRYM, due to a closed loop or grounded wire
    !  (open loop) source, in NPLT plates lying in the basement of a host with NLYR-1
    !  layers above basement.  The computation is modelled as an integrtion around the
    !  loop perimeter.  In this version, the loops must be horizontal but can be at any
    !  depth.  Open loops must have grounded electrodes.
    !
    !  The initial computations occur in a coordinate system whose X component lies in
    !  the direction of each loop segment in turn.  The coordinate system is rotated
    !  as each loop segment is considered.  For closed loop sources, the non-conservative
    !  part of the Gzx potential contributions are integrated around the loop.
    !  For grouned wire sources, the Fzx potential and thye conservative part of the Gxz
    !  potentials are path independent allowing evaluation across the open side instead
    !  of between all the wire segments.

    !  Each target (plate) is discretised along strike into NA cells of length DA
    !  and down dip into NB cells of width DB.
    !
    !  For a vertical plate along the X axis, the cells are numbered along strike
    !  from the South to the North, first along the top row and then in the same
    !  direction along lower rows.  The last cell would be in the bottom
    !  North corner.  In plan view, the X and Y components of E_PRYM are positive
    !  to the North and East respectively.
    !
    !          INPUT
    !          -----
    !
    !          NTX - number of source positions
    !       MXVRTX - maximum number of vertices for any transmitter
    !     NVRTX(J) - number of vertices for transmitter J
    !     SXE(I,J) = local east coordinate of vertex I for loop position J
    !     SXN(I,J) = local coordinate of vertex I for loop position J
    !      RHOTRP - horizontal interpolation array (15 points / decade) of dimension NRPRM
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        PLYR - layer containing plate
    !        THKD - layer thicknesses
    !        RMUD - relative magetic permeability
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        NPLT - number of plates
    !       PLAZM - strike angle in radians
    !       PLDIP - dip angle
    !       PLUNJ - plunge angle
    !        MXAB - maximum number of cells in one plate
    !      NA, NB - number of cells along strike & down dip respectively for each plate
    !  XCELL(k,*) - north coordinate of centre of cell k
    !  YCELL(k,*) - east coordinate of centre of cell k
    !  ZCELL(k,*) - depth of centre of cell k
    !
    !          OUTPUT
    !          ------
    !
    !  E_PRYM(1,*) - complex primary electric fields along strike.
    !  E_PRYM(2,*) - complex primary electric fields down-dip.
    !
    !    The first NAB components of E_PRYM are the fields along strike and
    !    the second group of NA*NB components are along dip.  Thus for a strike
    !    along the X axis, the first NA*NB components would be the X component
    !    of the primary electric field and the second NA*NB components
    !    would be the Y component multiplied by the cosine of the dip angle.
    ! -------------------------------------------------------------------------

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    INTEGER, PARAMETER :: NDIP0=5, MXDIP=100
    REAL, PARAMETER :: DIPL0 = 5.
    COMPLEX, PARAMETER :: ZERO = (0., 0.)
    INTEGER NTX,MXVRTX,NVRTX(NTX),NVRL,NVRLS,NRPRM,NLYR,NPLT,PLYR(NPLT),MXAB,NA(NPLT),NZ1,JZ, &
         NB(NPLT),JAB,JP,JS,JB,JA,JD,JV,JV1,SOURCE_TYPE,SXLYR,KFG,NDIP(MXVRTX,NTX),I1
    REAL, DIMENSION (MXVRTX,NTX) :: SXN,SXE,WYRL,DIPL,CPHI,SPHI
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ
    REAL SXZ(NTX),RHOTRP(NRPRM),CSTR,SSTR,CDIP,SDIP,CPLN,SPLN,ZV1(NZ1),XCELL(MXAB,NPLT), &
         YCELL(MXAB,NPLT),ZCELL(MXAB,NPLT),CPHI2,SPHI2,RHO1,RHO2,X1,X1D,X2D,YD,ZR,RSQ,R23(2,3)
    REAL, ALLOCATABLE, DIMENSION(:,:,:) :: G1R,G1I,G2R,G2I,G3R,G3I
    REAL(KIND=QL) THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR),ZS,ZPRV
    REAL, ALLOCATABLE :: QR(:,:),QI(:,:)
    REAL(KIND=QL), ALLOCATABLE :: ZV1Q(:)
    COMPLEX CCS1,CCS2,KBSQ,KBASE,EX0,EX1,EY1,EZ1,E_PRYM(2,MXAB,NTX,NPLT),EAB(2),EXYZ(3)
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    COMPLEX(KIND=QL), DIMENSION(:,:,:), ALLOCATABLE :: HLYRD

    !  Set depth array over which to interpolate Green's FUNCTION integrals

    ALLOCATE (G1R(4,NRPRM,NZ1),G1I(4,NRPRM,NZ1),G2R(4,NRPRM,NZ1),G2I(4,NRPRM,NZ1),G3R(4,NRPRM,NZ1), &
         G3I(4,NRPRM,NZ1),HLYRD(NRPRM,3,NZ1),QR(4,NRPRM),QI(4,NRPRM),ZV1Q(NZ1))

    ZV1Q(1:NZ1) = REAL (ZV1(1:NZ1),QL)
    HLYRD = (0._QL, 0._QL)
    E_PRYM = (0.,0.)
    ZPRV = -9.D4
    I1 = 2                    ! electric source

    KBSQ = CMPLX (KSQL(NLYR))
    KBASE = SQRT (KBSQ)
    IF (REAL (KBASE) < 0.) KBASE = -KBASE

    SOURCE_LOOP: DO JS = 1,NTX
       ZS = REAL (SXZ(JS),QL)
       IF (ABS (ZS - ZPRV) > 1.D-4) THEN
          ZPRV = ZS
          SXLYR = 0
          DO JZ = NLYR,1,-1
             IF (ZS > DPTHL(JZ)) THEN
                SXLYR = JZ
                EXIT
             END IF
          END DO
          CALL SET_KFG (I1,NLYR,SXLYR,NLYR,KFG)

          IF (SOURCE_TYPE == 1) THEN   ! Closed loop
             CALL PRM_HNK_CL (NRPRM,RHOTRP,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,KFG,SXLYR,HLYRD)
          ELSE                         ! Open loop
             CALL PRM_HNK_OL (NRPRM,RHOTRP,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,KFG,SXLYR,HLYRD)
          END IF

          DO JZ = 1,NZ1
             QR(1,1:NRPRM) =        REAL (HLYRD(1:NRPRM,1,JZ), 4)
             QI(1,1:NRPRM) = REAL (AIMAG (HLYRD(1:NRPRM,1,JZ)), 4)   ! HLYRD is in QL precision
             CALL CUBSPL (RHOTRP,QR,NRPRM)
             CALL CUBSPL (RHOTRP,QI,NRPRM)
             G1R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
             G1I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)

             IF (SOURCE_TYPE == 2) THEN
                QR(1,1:NRPRM) =        REAL (HLYRD(1:NRPRM,2,JZ), 4)
                QI(1,1:NRPRM) = REAL (AIMAG (HLYRD(1:NRPRM,2,JZ)), 4)
                CALL CUBSPL (RHOTRP,QR,NRPRM)
                CALL CUBSPL (RHOTRP,QI,NRPRM)
                G2R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
                G2I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)

                QR(1,1:NRPRM) =        REAL (HLYRD(1:NRPRM,3,JZ), 4)
                QI(1,1:NRPRM) = REAL (AIMAG (HLYRD(1:NRPRM,3,JZ)), 4)
                CALL CUBSPL (RHOTRP,QR,NRPRM)
                CALL CUBSPL (RHOTRP,QI,NRPRM)
                G3R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
                G3I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)
             END IF
          END DO
       END IF

       NVRL = NVRTX(JS)
       DO JV = 1, NVRL
          JV1 = JV + 1             ! Wire JV goes from vertex JV to vertex JV1
          IF (JV == NVRL) JV1 = 1

          ! Length & orientation of Wire JV between vertices JV & JV1

          WYRL(JV,JS) = SQRT ( (SXN(JV,JS) - SXN(JV1,JS))**2 + (SXE(JV,JS) - SXE(JV1,JS))**2)
          CPHI(JV,JS) = (SXN(JV1,JS) - SXN(JV,JS) ) / WYRL(JV,JS)
          SPHI(JV,JS) = (SXE(JV1,JS) - SXE(JV,JS) ) / WYRL(JV,JS)

          ! Divide each wire into segment lengths of 5 m with a minimum of 5 segments per wire.

          NDIP(JV,JS) = CEILING (WYRL(JV,JS) / DIPL0)  ! 5 m initial dipole length
          NDIP(JV,JS) = MAX (NDIP(JV,JS), NDIP0)       ! At least 5 dipoles per segment
          NDIP(JV,JS) = MIN (NDIP(JV,JS), MXDIP)
          DIPL(JV,JS) = WYRL(JV,JS) / REAL (NDIP(JV,JS))
       END DO
       IF (SOURCE_TYPE == 2) THEN
          CPHI(NVRL,JS) = (SXN(NVRL,JS) - SXN(1,JS) ) / WYRL(NVRL,JS)
          SPHI(NVRL,JS) = (SXE(NVRL,JS) - SXE(1,JS) ) / WYRL(NVRL,JS)
       END IF

       !  Step through depths.  Add up contributions for each dipole for each transmitter.

       PLATE_LOOP: DO JP = 1, NPLT
          IF (PLYR(JP) < NLYR) CYCLE
          CSTR = COS (PLAZM(JP) )
          SSTR = SIN (PLAZM(JP) )
          CDIP = COS (PLDIP(JP) )
          SDIP = SIN (PLDIP(JP) )
          CPLN = COS (PLUNJ(JP) )
          SPLN = SIN (PLUNJ(JP) )

          DEPTH_STEP: DO JB = 1, NB(JP)
             NVRL = NVRTX(JS)
             NVRLS = NVRL
             IF (SOURCE_TYPE == 2) NVRLS = NVRL -1
             STRYK_STEP: DO JA = 1, NA(JP)
                JAB = JA + (JB-1)*NA(JP)

                DO JV = 1,NVRLS
                   JV1 = JV + 1             ! Wire JV goes from vertex JV to vertex JV1
                   IF (JV == NVRL) JV1 = 1  ! Closed loop only

                   EX0 = ZERO
                   CPHI2 = CSTR * CPHI(JV,JS) + SSTR * SPHI(JV,JS)  !  strike angle wrt loop segment
                   SPHI2 = SSTR * CPHI(JV,JS) - CSTR * SPHI(JV,JS)
                   YD = (YCELL(JAB,JP) - SXE(JV,JS)) * CPHI(JV,JS) &
                        - (XCELL(JAB,JP) - SXN(JV,JS)) * SPHI(JV,JS)
                   X1D = (XCELL(JAB,JP) - SXN(JV,JS) ) * CPHI(JV,JS) &
                        + (YCELL(JAB,JP) - SXE(JV,JS) ) * SPHI(JV,JS)
                   ZR = ZCELL (JAB,JP)

                   DO JD = 1, NDIP(JV,JS)
                      X1 = X1D - (JD - 0.5) * DIPL(JV,JS)
                      RSQ = X1**2 + YD**2
                      RHO1 = SQRT (RSQ)
                      CCS1 = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G1R,G1I,RHO1,ZR)
                      EX0 = EX0 + CCS1
                   END DO
                   EX0 = DIPL(JV,JS) * EX0

                   CALL RXYZ2PLT (CPHI2,SPHI2,CDIP,SDIP,CPLN,SPLN,R23)
                   EXYZ = ZERO
                   EXYZ(1) = EX0
                   EAB = MATMUL (R23, EXYZ)

                   E_PRYM(1,JAB,JS,JP) = E_PRYM(1,JAB,JS,JP) + EAB(1)
                   E_PRYM(2,JAB,JS,JP) = E_PRYM(2,JAB,JS,JP) + EAB(2) !  No vertical field for closed loop

                END DO
                IF (SOURCE_TYPE == 2 ) THEN    ! Integrate over open side for GW source.
                   X1D = (XCELL(JAB,JP) - SXN(1,JS)   ) * CPHI(NVRL,JS) &
                        + (YCELL(JAB,JP) - SXE(1,JS)   ) * SPHI(NVRL,JS)
                   X2D = (XCELL(JAB,JP) - SXN(NVRL,JS)) * CPHI(NVRL,JS) &
                        + (YCELL(JAB,JP) - SXE(NVRL,JS)) * SPHI(NVRL,JS)
                   YD = (YCELL(JAB,JP) - SXE(1,JS))    * CPHI(NVRL,JS) &
                        - (XCELL(JAB,JP) - SXN(1,JS))    * SPHI(NVRL,JS)

                   RHO1 = SQRT (X1D**2 + YD**2)
                   RHO2 = SQRT (X2D**2 + YD**2)

                   CPHI2 = CSTR * CPHI(NVRL,JS) + SSTR * SPHI(NVRL,JS)  !  strike angle wrt loop segment
                   SPHI2 = SSTR * CPHI(NVRL,JS) - CSTR * SPHI(NVRL,JS)
                   CCS1 = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G2R,G2I,RHO1,ZR)
                   CCS2 = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G2R,G2I,RHO2,ZR)

                   EX1 = X2D * CCS2 - X1D * CCS1
                   EY1 = YD * (CCS2 - CCS1)
                   CCS1 = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G3R,G3I,RHO1,ZR)
                   CCS2 = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G3R,G3I,RHO2,ZR)
                   EZ1 = CCS2 - CCS1

                   CALL RXYZ2PLT (CPHI2,SPHI2,CDIP,SDIP,CPLN,SPLN,R23)
                   EXYZ(1) = EX1;   EXYZ(2) = EY1;  EXYZ(3) = EZ1
                   EAB = MATMUL (R23, EXYZ)

                   E_PRYM(1,JAB,JS,JP) = E_PRYM(1,JAB,JS,JP) + EAB(1)
                   E_PRYM(2,JAB,JS,JP) = E_PRYM(2,JAB,JS,JP) + EAB(2)
                END IF
             END DO STRYK_STEP
          END DO DEPTH_STEP
       END DO PLATE_LOOP
    END DO SOURCE_LOOP

    DEALLOCATE (HLYRD,QR,QI,ZV1Q,G1R,G1I,G2R,G2I,G3R,G3I)

  END SUBROUTINE PRM_BOSS_LP

  SUBROUTINE PRM_HNK_CL (NRPRM,RHOTRP,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,KFG,SXLYR,HLYRD)
    !-----------------------------------------------------------------------------------------------

    !***  Calls PRM_KER_CL
    !***  Called by PRM_BOSS_LP

    !  Computes integrals needed to evaluate the primary electric field in the
    !  basement due to a closed loop source at any depth or elevation.
    !  It uses the flow through Hankel transform method to evaluate the three Hankel
    !  integrals at discrete depths.  The Hankel transform integral uses a 15 point
    !  per decade filter coefficient set derived from Christensen's FLTGEN program.

    !       NRPRM - number of horizontal interpolation points
    !      RHOTRP - 15 points per decade interpolation array
    !         NZ1 - number of interpolation depths
    !        ZV1Q - array of interpolation depths
    !          ZS - transmitter depth
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !       DPTHL - depth to top of each layer including basement
    !         KFG - Case selector variable
    !
    !  HLYRD(JR,1,JB) - only component needed for both closed & open loop
    !  HLYRD(JR,2,JB) - integrands for grounded wire segment
    !

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL(KIND=QL), PARAMETER :: FOURPI = 12.56637061_QL
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER L,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,JR,NZ1,NLYR,KFG,SXLYR,JB,NRPRM
    REAL RHOTRP(NRPRM)
    REAL(KIND=QL) RMUD(0:NLYR),ZS,DELTA,Y1,Y,RD,LMBDA,ZV1Q(NZ1),RHOD
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) HLYRD(NRPRM,3,NZ1),KER(JNLO-NRPRM:JNHI,3,NZ1)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL JUMP

    KER = ZERO
    DELTA = LOG (10.D0)/ DBLE (NDEC_JN)

    ! Basic integral for open and closed loops.
    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = DBLE (RHOTRP(1) )
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       CALL PRM_KER_CL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL, &
            RMUD,SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL PRM_KER_CL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL, &
            RMUD,SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRPRM)

    JR = NRPRM
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.
       HLYRD(JR,1,1:NZ1) =  HLYRD(JR,1,1:NZ1) + KER(K,1,1:NZ1) * WJ0(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (SNGL(Y))
          CALL PRM_KER_CL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL, &
               RMUD,SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRPRM-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          HLYRD(JR,1,1:NZ1) =  HLYRD(JR,1,1:NZ1) + KER(K,1,1:NZ1) * WJ0(L)
       END DO
    END DO

    DO JB = 1,NZ1
       DO JR = 1, NRPRM
          RHOD = REAL (RHOTRP(JR),KIND=QL)
          HLYRD(JR,1,JB) = HLYRD(JR,1,JB) / (FOURPI * RHOD * SIGL(NLYR))
       END DO
    END DO

  END SUBROUTINE PRM_HNK_CL

  SUBROUTINE PRM_KER_CL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL, &
       RMUD,SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
    !----------------------------------------------------------------------

    !***  Called by PRM_HNK_LP

    ! Compute the kernels for closed loop integration.
    ! This involves only G potential terms.

    !     NRPRM - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !       NZ1 - number of interpolation depths
    !      ZV1Q - array of interpolation depths
    !        ZS - source location  (negative in air, positive in ground)
    !      NLYR - number of layers including basement. (1 or 2 only)
    !      SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !      KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !      RMUD - relative magetic permeability
    !      THKD - thickness of each layer above basement
    !     DPTHL - depth to top of each layer including basement
    !       KFG - Case selector variable
    !       KER - kernels for hankel integraion
    !
    !   HLYRD(*,1,*) - needed for both closed and open loops
    !   HLYRD(*,2,*) - used only for grounded wire segments
    !   HLYRD(*,3,*) - used only for grounded wire segments
    !
    !           JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER JR,L,K,NZ1,NLYR,SXLYR,RXLYR,KFG,JZ,NRPRM
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,ZS,AR,AI,HLYRDR,HLYRDI,ZV1Q(NZ1),ZDR
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX (KIND=QL) XI_V,F_V,F_H,ETA_V,G_V,G_H,XP,XPDIR,SL,KER(JNLO-NRPRM:JNHI,3,NZ1), &
         FACV,KV,S(0:NLYR),HLYRD(NRPRM,3,NZ1),TMP(NZ1)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    RXLYR = NLYR
    CALL EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)

    KER(K,1,1:NZ1) = ZERO
    TMP = ZERO
    SL = S(RXLYR)
    FACV = RMUD(SXLYR) * KSQL(RXLYR) / (RMUD(NLYR) * S(SXLYR))
    KV = FACV * ETA_V

    DO JZ = 1, NZ1
       XP = EXP (SL * (DPTHL(NLYR) - ZV1Q(JZ)))
       KER(K,1,JZ) = -XP * KV * LMBDA
    END DO

    IF (SXLYR == NLYR) THEN     !  Transmitter in basement
       DO JZ = 1, NZ1
          ZDR = ZS - ZV1Q(JZ)
          XPDIR = EXP (-SL * ABS (ZDR))
          KV = FACV * XPDIR
          KER(K,1,JZ) = KER(K,1,JZ) - KV * LMBDA
       END DO
    END IF

    JUMP = .TRUE.
    TMP(1:NZ1) = KER(K,1,1:NZ1) * WJ0(L)

    HLYRD(JR,1,1:NZ1) = HLYRD(JR,1,1:NZ1) + TMP(1:NZ1)
    DO JZ = 1, NZ1
       AR = ABS ( REAL (TMP(JZ)) )
       AI = ABS (AIMAG (TMP(JZ)) )
       TOO_BIG = .FALSE.
       HLYRDR = ABS ( REAL (HLYRD(JR,1,JZ)) )
       HLYRDI = ABS (AIMAG (HLYRD(JR,1,JZ)) )
       IF (AR > TOL* HLYRDR) TOO_BIG = .TRUE.
       IF (AI > TOL* HLYRDI) TOO_BIG = .TRUE.
       IF (TOO_BIG) JUMP = .FALSE.
    END DO

  END SUBROUTINE PRM_KER_CL

  SUBROUTINE PRM_HNK_OL (NRPRM,RHOTRP,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,KFG,SXLYR,HLYRD)
    !-----------------------------------------------------------------------------------------------

    !***  Calls PRM_KER_OL
    !***  Called by PRM_BOSS_LP

    !  Computes integrals needed to evaluate the primary electric field in the
    !  basement due to an open loop source at any depth or elevation.
    !  It uses the flow through Hankel transform method to evaluate the three Hankel
    !  integrals at discrete depths.  The Hankel transform integral uses a 15 point
    !  per decade filter coefficient set derived from Christensen's FLTGEN program.

    !       NRPRM - number of horizontal interpolation points
    !      RHOTRP - 15 points per decade interpolation array
    !         NZ1 - number of interpolation depths
    !        ZV1Q - array of interpolation depths
    !          ZS - transmitter depth
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !       DPTHL - depth to top of each layer including basement
    !         KFG - Case selector variable
    !
    !  HLYRD(JR,1,JB) - only component needed for both closed & open loop
    !  HLYRD(JR,2,JB) - integrands for grounded wire segment
    !

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL(KIND=QL), PARAMETER :: FOURPI = 12.56637061_QL
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER L,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,JR,NZ1,NLYR,KFG,SXLYR,JB,NRPRM
    REAL RHOTRP(NRPRM)
    REAL(KIND=QL) RMUD(0:NLYR),ZS,DELTA,Y1,Y,RD,LMBDA,ZV1Q(NZ1),RHOD
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) HLYRD(NRPRM,3,NZ1),KER(JNLO-NRPRM:JNHI,3,NZ1)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL JUMP

    KER = ZERO
    DELTA = LOG (10.D0)/ DBLE (NDEC_JN)

    ! Basic integral for open and closed loops.
    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = DBLE (RHOTRP(1) )
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       CALL PRM_KER_OL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL, &
            RMUD,SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL PRM_KER_OL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL, &
            RMUD,SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRPRM)

    JR = NRPRM
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.

       HLYRD(JR,1,1:NZ1) =  HLYRD(JR,1,1:NZ1) + KER(K,1,1:NZ1) * WJ0(L)
       HLYRD(JR,2,1:NZ1) =  HLYRD(JR,2,1:NZ1) + KER(K,2,1:NZ1) * WJ1(L)
       HLYRD(JR,3,1:NZ1) =  HLYRD(JR,3,1:NZ1) + KER(K,3,1:NZ1) * WJ0(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (SNGL(Y))
          CALL PRM_KER_OL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL, &
               RMUD,SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRPRM-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          HLYRD(JR,1,1:NZ1) =  HLYRD(JR,1,1:NZ1) + KER(K,1,1:NZ1) * WJ0(L)
          HLYRD(JR,2,1:NZ1) =  HLYRD(JR,2,1:NZ1) + KER(K,2,1:NZ1) * WJ1(L)
          HLYRD(JR,3,1:NZ1) =  HLYRD(JR,3,1:NZ1) + KER(K,3,1:NZ1) * WJ0(L)
       END DO
    END DO

    DO JB = 1,NZ1
       DO JR = 1, NRPRM
          RHOD = REAL (RHOTRP(JR),KIND=QL)
          HLYRD(JR,1:3,JB) = HLYRD(JR,1:3,JB) / (FOURPI * RHOD * SIGL(NLYR))
          HLYRD(JR,2,JB) = HLYRD(JR,2,JB) / RHOD
       END DO
    END DO

  END SUBROUTINE PRM_HNK_OL

  SUBROUTINE PRM_KER_OL (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD, &
       SIGL,KSQL,KFG,SXLYR,KER,HLYRD,JUMP)
    !---------------------------------------------------------------------------

    !***  Called by PRM_HNK_LP

    !  Compute the kernels for grounded wire sources.
    !  This is a mixture of G & F potential terms.

    !     NRPRM - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !       NZ1 - number of interpolation depths
    !      ZV1Q - array of interpolation depths
    !        ZS - source location  (negative in air, positive in ground)
    !      NLYR - number of layers including basement. (1 or 2 only)
    !      SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !      KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !      RMUD - relative magetic permeability
    !      THKD - thickness of each layer above basement
    !     DPTHL - depth to top of each layer including basement
    !       KFG - Case selector variable
    !       KER - kernels for hankel integraion
    !
    !   HLYRD(*,1,*) - needed for both closed and open loops
    !   HLYRD(*,2,*) - used only for grounded wire segments
    !   HLYRD(*,3,*) - used only for grounded wire segments
    !
    !           JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER JR,L,K,NZ1,NLYR,RXLYR,SXLYR,KFG,JZ,NRPRM,JI
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,ZS,AR,AI,HLYRDR,HLYRDI,ZV1Q(NZ1),GAM,ZDR
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX (KIND=QL) XI_V,F_V,F_H,ETA_V,G_V,G_H,XP,XPDIR,KER(JNLO-NRPRM:JNHI,3,NZ1), &
         S(0:NLYR),SL,FACV,KV,KVS,HLYRD(NRPRM,3,NZ1),TMP(3,NZ1)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    ! Compute layered-earth coefficients.  RXLYR = NLYR

    RXLYR = NLYR
    CALL EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)
    KER(K,1:3,1:NZ1) = ZERO
    TMP = ZERO
    SL = S(RXLYR)

    FACV = RMUD(SXLYR) * KSQL(RXLYR) / (RMUD(NLYR) * S(SXLYR))
    KV = FACV * ETA_V
    KVS = KV + G_H * SL

    DO JZ = 1, NZ1
       XP = EXP (SL * (DPTHL(NLYR) - ZV1Q(JZ)))
       KER(K,1,JZ) = -XP * KV * LMBDA
       KER(K,2,JZ) = -XP * KVS
       KER(K,3,JZ) = -XP * G_H * LMBDA
    END DO

    IF (SXLYR == NLYR) THEN     !  Transmitter in basement
       DO JZ = 1, NZ1
          ZDR = ZS - ZV1Q(JZ)
          GAM = SIGN (1.0_QL, ZDR)
          XPDIR = EXP (-SL * ABS (ZDR))
          KV = FACV * XPDIR
          KVS = KV - XPDIR * SL

          KER(K,1,JZ) = KER(K,1,JZ) - KV * LMBDA
          KER(K,2,JZ) = KER(K,2,JZ) - KVS
          KER(K,3,JZ) = KER(K,3,JZ) - GAM * XPDIR * LMBDA
       END DO
    END IF

    JUMP = .TRUE.
    TMP(1,1:NZ1) = KER(K,1,1:NZ1) * WJ0(L)
    TMP(2,1:NZ1) = KER(K,2,1:NZ1) * WJ1(L)
    TMP(3,1:NZ1) = KER(K,3,1:NZ1) * WJ0(L)

    HLYRD(JR,1:3,1:NZ1) = HLYRD(JR,1:3,1:NZ1) + TMP(1:3,1:NZ1)
    DO JZ = 1, NZ1
       DO JI = 1,3
          AR = ABS ( REAL (TMP(JI,JZ)) )
          AI = ABS (AIMAG (TMP(JI,JZ)) )
          TOO_BIG = .FALSE.
          HLYRDR = ABS ( REAL (HLYRD(JR,JI,JZ)) )
          HLYRDI = ABS (AIMAG (HLYRD(JR,JI,JZ)) )
          IF (AR > TOL* HLYRDR) TOO_BIG = .TRUE.
          IF (AI > TOL* HLYRDI) TOO_BIG = .TRUE.
          IF (TOO_BIG) JUMP = .FALSE.
       END DO
    END DO
  END SUBROUTINE PRM_KER_OL

  SUBROUTINE PRM_BOSS_UL_LP (JP,SOURCE_TYPE,NTX,MXVRTX,NVRTX,SXN,SXE,SXZ,NRPRM,RHOTRP,NLYR, &
       THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB,    &
       MXB,NB,NA,XCELL,YCELL,ZC1L,E_PRYM)
    ! ---------------------------------------------------------------------------------------

    !***  Called by MAIN
    !***  Calls PRM_HNK1_LP, PRM_HNK1_FZ, CUBSPL, SETPRM

    !  This rutine is used for plates above basement.  It deals with one plate at a time.
    !
    !  Computes the primary electric field, E_PRYM, due to a closed loop or grounded wire
    !  (open loop) source for a plate lying above thebasement of a host with NLYR-1
    !  layers above basement.  The computation is modelled as an integrtion around the
    !  loop perimeter.  In this version, the loops must be horizontal but can be at any
    !  depth.  Open loops must have grounded electrodes.
    !
    !  The initial computations occur in a coordinate system whose X component lies in
    !  the direction of each loop segment in turn.  The coordinate system is rotated
    !  as each loop segment is considered.  For closed loop sources, the non-conservative
    !  part of the Gzx potential contributions are integrated around the loop.
    !  For grouned wire sources, the Fzx potential and thye conservative part of the Gxz
    !  potentials are path independent allowing evaluation across the open side instead
    !  of between all the wire segments.

    !  Each target (plate) is discretised along strike into NA cells of length DA
    !  and down dip into NB cells of width DB.
    !
    !  For a vertical plate along the X axis, the cells are numbered along strike
    !  from the South to the North, first along the top row and then in the same
    !  direction along lower rows.  The last cell would be in the bottom
    !  North corner.  In plan view, the X and Y components of E_PRYM are positive
    !  to the North and East respectively.
    !
    !          INPUT
    !          -----
    !
    !          NTX - number of source positions
    !       MXVRTX - maximum number of vertices for any transmitter
    !     NVRTX(J) - number of vertices for transmitter J
    !     SXE(I,J) = local east coordinate of vertex I for loop position J
    !     SXN(I,J) = local coordinate of vertex I for loop position J
    !      RHOTRP - horizontal interpolation array (15 points / decade) of dimension NRPRM
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        THKD - layer thicknesses
    !        RMUD - relative magetic permeability
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        NPLT - number of plates
    !       PLAZM - strike angle in radians
    !       PLDIP - dip angle
    !       PLUNJ - plunge angle
    !        MXAB - maximum number of cells in one plate
    !         MXB - maximum number of cell rows of any plate above basement
    !      NA, NB - number of cells along strike & down dip respectively for each plate
    !  XCELL(k,*) - north coordinate of centre of cell k
    !  YCELL(k,*) - east coordinate of centre of cell k
    !        ZC1L - depth of row centres in Plate JP
    !
    !          OUTPUT
    !          ------
    !
    !  E_PRYM(1,*) - complex primary electric fields along strike.
    !  E_PRYM(2,*) - complex primary electric fields down-dip.
    !
    !    The first NAB components of E_PRYM are the fields along strike and
    !    the second group of NA*NB components are along dip.  Thus for a strike
    !    along the X axis, the first NA*NB components would be the X component
    !    of the primary electric field and the second NA*NB components
    !    would be the Y component multiplied by the cosine of the dip angle.
    ! -------------------------------------------------------------------------

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    INTEGER, PARAMETER :: NDIP0=5, MXDIP=100
    REAL, PARAMETER :: DIPL0 = 5.
    COMPLEX, PARAMETER :: ZERO = (0., 0.)
    INTEGER NTX,MXVRTX,NVRTX(NTX),NVRL,NVRLS,NRPRM,NLYR,NPLT,PLYR(NPLT),MXAB,MXB,NA(NPLT),NB(NPLT), &
         NROW,JZ,JAB,JP,JS,JB,JA,JD,JV,JV1,SOURCE_TYPE,SXLYR,RXLYR,KFG,NDIP(MXVRTX,NTX),I1
    REAL, DIMENSION (MXVRTX,NTX) :: SXN,SXE,WYRL,DIPL,CPHI,SPHI
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ
    REAL SXZ(NTX),RHOTRP(NRPRM),CSTR,SSTR,CDIP,SDIP,CPLN,SPLN,XCELL(MXAB,NPLT), &
         YCELL(MXAB,NPLT),ZC1L(MXB),CPHI2,SPHI2,RHO1,RHO2,X1,X1D,X2D,YD,RSQ,R23(2,3)
    REAL, ALLOCATABLE, DIMENSION(:,:) :: G1R,G1I,G2R,G2I,G3R,G3I
    REAL(KIND=QL) THKD(NLYR),DPTHL(NLYR),RMUD(0:NLYR),ZS,ZPRV
    COMPLEX CCS1,CCS2,EX0,EX1,EY1,EZ1,E_PRYM(2,MXAB,NTX,NPLT),EAB(2),EXYZ(3)
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    COMPLEX(KIND=QL), DIMENSION(:,:,:), ALLOCATABLE :: HLYRD

    !  Set depth array over which to interpolate Green's FUNCTION integrals

    NROW = NB(JP)
    RXLYR = PLYR(JP)
    IF (RXLYR == NLYR) THEN
       WRITE(4,1); WRITE(*,1)
       STOP
    END IF

    ALLOCATE (HLYRD(NRPRM,3,NROW),G1R(4,NRPRM),G1I(4,NRPRM),G2R(4,NRPRM), &
         G2I(4,NRPRM),G3R(4,NRPRM),G3I(4,NRPRM))

    I1 = 2                    ! electric source
    HLYRD = (0._QL, 0._QL)
    E_PRYM(1:2,1:MXAB,1:NTX,JP) = (0.,0.)
    ZPRV = -9.D4

    SOURCE_LOOP: DO JS = 1,NTX
       ZS = REAL (SXZ(JS),QL)
       IF (ABS (ZS - ZPRV) > 1.D-4) THEN
          ZPRV = ZS
          SXLYR = 0
          DO JZ = NLYR,1,-1
             IF (ZS > DPTHL(JZ)) THEN
                SXLYR = JZ
                EXIT
             END IF
          END DO
          CALL SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)

          IF (SOURCE_TYPE == 1 .OR. SOURCE_TYPE == 4) THEN   ! Closed loop
             CALL PRM_HNK1_CL (NRPRM,RHOTRP,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,SXLYR,RXLYR,KFG,HLYRD)
          ELSE IF (SOURCE_TYPE == 2) THEN                     ! Open loop
             CALL PRM_HNK1_OL (NRPRM,RHOTRP,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,SXLYR,RXLYR,KFG,HLYRD)
          END IF
       END IF

       NVRL = NVRTX(JS)
       DO JV = 1, NVRL
          JV1 = JV + 1             ! Wire JV goes from vertex JV to vertex JV1
          IF (JV == NVRL) JV1 = 1

          ! Length & orientation of Wire JV between vertices JV & JV1

          WYRL(JV,JS) = SQRT ( (SXN(JV,JS) - SXN(JV1,JS))**2 + (SXE(JV,JS) - SXE(JV1,JS))**2)
          CPHI(JV,JS) = (SXN(JV1,JS) - SXN(JV,JS) ) / WYRL(JV,JS)
          SPHI(JV,JS) = (SXE(JV1,JS) - SXE(JV,JS) ) / WYRL(JV,JS)

          ! Divide each wire into segment lengths of 5 m with a minimum of 5 segments per wire.

          NDIP(JV,JS) = CEILING (WYRL(JV,JS) / DIPL0)  ! 5 m initial dipole length
          NDIP(JV,JS) = MAX (NDIP(JV,JS), NDIP0)       ! At least 5 dipoles per segment
          NDIP(JV,JS) = MIN (NDIP(JV,JS), MXDIP)
          DIPL(JV,JS) = WYRL(JV,JS) / REAL (NDIP(JV,JS))
       END DO
       IF (SOURCE_TYPE == 2) THEN
          CPHI(NVRL,JS) = (SXN(NVRL,JS) - SXN(1,JS) ) / WYRL(NVRL,JS)
          SPHI(NVRL,JS) = (SXE(NVRL,JS) - SXE(1,JS) ) / WYRL(NVRL,JS)
       END IF

       !  Step through depths.  Add up contributions for each dipole for each transmitter.

       CSTR = COS (PLAZM(JP) )
       SSTR = SIN (PLAZM(JP) )
       CDIP = COS (PLDIP(JP) )
       SDIP = SIN (PLDIP(JP) )
       CPLN = COS (PLUNJ(JP) )
       SPLN = SIN (PLUNJ(JP) )

       DEPTH_STEP: DO JB = 1, NROW
          G1R(1,1:NRPRM) = REAL (HLYRD(1:NRPRM,1,JB), 4)
          G1I(1,1:NRPRM) = REAL (AIMAG (HLYRD(1:NRPRM,1,JB)), 4)   ! HLYRD is in QL precision
          CALL CUBSPL (RHOTRP,G1R,NRPRM)
          CALL CUBSPL (RHOTRP,G1I,NRPRM)
          NVRL = NVRTX(JS)
          NVRLS = NVRL

          IF (SOURCE_TYPE == 2) THEN
             G2R(1,1:NRPRM) =        REAL (HLYRD(1:NRPRM,2,JB), 4)
             G2I(1,1:NRPRM) = REAL (AIMAG (HLYRD(1:NRPRM,2,JB)), 4)
             G3R(1,1:NRPRM) =        REAL (HLYRD(1:NRPRM,3,JB), 4)
             G3I(1,1:NRPRM) = REAL (AIMAG (HLYRD(1:NRPRM,3,JB)), 4)
             CALL CUBSPL (RHOTRP,G2R,NRPRM)
             CALL CUBSPL (RHOTRP,G2I,NRPRM)
             CALL CUBSPL (RHOTRP,G3R,NRPRM)
             CALL CUBSPL (RHOTRP,G3I,NRPRM)
             NVRLS = NVRL -1
          END IF

          STRYK_STEP: DO JA = 1, NA(JP)
             JAB = JA + (JB-1)*NA(JP)

             DO JV = 1,NVRLS
                JV1 = JV + 1             ! Wire JV goes from vertex JV to vertex JV1
                IF (JV == NVRL) JV1 = 1  ! Closed loop only

                EX0 = ZERO
                CPHI2 = CSTR * CPHI(JV,JS) + SSTR * SPHI(JV,JS)  !  strike angle wrt loop segment
                SPHI2 = SSTR * CPHI(JV,JS) - CSTR * SPHI(JV,JS)
                YD = (YCELL(JAB,JP) - SXE(JV,JS)) * CPHI(JV,JS) &
                     - (XCELL(JAB,JP) - SXN(JV,JS)) * SPHI(JV,JS)
                X1D = (XCELL(JAB,JP) - SXN(JV,JS) ) * CPHI(JV,JS) &
                     + (YCELL(JAB,JP) - SXE(JV,JS) ) * SPHI(JV,JS)

                DO JD = 1, NDIP(JV,JS)
                   X1 = X1D - (JD - 0.5) * DIPL(JV,JS)
                   RSQ = X1**2 + YD**2
                   RHO1 = SQRT (RSQ)
                   CALL CCUBVAL(RHOTRP,NRPRM,G1R,G1I,RHO1,CCS1)
                   EX0 = EX0 + CCS1
                END DO
                EX0 = DIPL(JV,JS) * EX0

                CALL RXYZ2PLT (CPHI2,SPHI2,CDIP,SDIP,CPLN,SPLN,R23)
                EXYZ = ZERO
                EXYZ(1) = EX0
                EAB = MATMUL (R23, EXYZ)

                E_PRYM(1,JAB,JS,JP) = E_PRYM(1,JAB,JS,JP) + EAB(1)
                E_PRYM(2,JAB,JS,JP) = E_PRYM(2,JAB,JS,JP) + EAB(2) !  No vertical field for closed loop

             END DO
             IF (SOURCE_TYPE == 2 ) THEN    ! Integrate over open side for GW source.
                X1D = (XCELL(JAB,JP) - SXN(1,JS)   ) * CPHI(NVRL,JS) &
                     + (YCELL(JAB,JP) - SXE(1,JS)   ) * SPHI(NVRL,JS)
                X2D = (XCELL(JAB,JP) - SXN(NVRL,JS)) * CPHI(NVRL,JS) &
                     + (YCELL(JAB,JP) - SXE(NVRL,JS)) * SPHI(NVRL,JS)
                YD = (YCELL(JAB,JP) - SXE(1,JS))    * CPHI(NVRL,JS) &
                     - (XCELL(JAB,JP) - SXN(1,JS))    * SPHI(NVRL,JS)

                RHO1 = SQRT (X1D**2 + YD**2)
                RHO2 = SQRT (X2D**2 + YD**2)

                CPHI2 = CSTR * CPHI(NVRL,JS) + SSTR * SPHI(NVRL,JS)  !  strike angle wrt loop segment
                SPHI2 = SSTR * CPHI(NVRL,JS) - CSTR * SPHI(NVRL,JS)
                CALL CCUBVAL(RHOTRP,NRPRM,G2R,G2I,RHO1,CCS1)
                CALL CCUBVAL(RHOTRP,NRPRM,G2R,G2I,RHO2,CCS2)
                EX1 = X2D * CCS2 - X1D * CCS1
                EY1 = YD * (CCS2 - CCS1)

                CALL CCUBVAL(RHOTRP,NRPRM,G3R,G3I,RHO1,CCS1)
                CALL CCUBVAL(RHOTRP,NRPRM,G3R,G3I,RHO2,CCS2)
                EZ1 = CCS2 - CCS1

                CALL RXYZ2PLT (CPHI2,SPHI2,CDIP,SDIP,CPLN,SPLN,R23)
                EXYZ(1) = EX1;   EXYZ(2) = EY1;  EXYZ(3) = EZ1
                EAB = MATMUL (R23, EXYZ)

                E_PRYM(1,JAB,JS,JP) = E_PRYM(1,JAB,JS,JP) + EAB(1)
                E_PRYM(2,JAB,JS,JP) = E_PRYM(2,JAB,JS,JP) + EAB(2)
             END IF
          END DO STRYK_STEP
       END DO DEPTH_STEP
    END DO SOURCE_LOOP
    DEALLOCATE (HLYRD,G1R,G1I,G2R,G2I,G3R,G3I)

1   FORMAT (T3,' An evil spirit has entered PRM_BOSS_UL_LP.  Seek help !')

  END SUBROUTINE PRM_BOSS_UL_LP

  SUBROUTINE PRM_HNK1_CL (NRPRM,RHOTRP,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
       SXLYR,RXLYR,KFG,HLYRD)
    !-------------------------------------------------------------------------------

    !***  Calls PRM_KER1_CL
    !***  Called by PRM_BOSS_LP

    !  Computes integrals needed to evaluate the primary electric field in one of the
    !  layers above basement due to a closed loop source at any depth or elevation.
    !  It uses the flow through Hankel transform method to evaluate the three Hankel
    !  integrals at discrete depths.  The Hankel transform integral uses a 15 point
    !  per decade filter coefficient set derived from Christensen's FLTGEN program.

    !       NRPRM - number of horizontal interpolation points
    !      RHOTRP - 15 points per decade interpolation array
    !        NROW - number of rows
    !        ZC1L - depth of row centres in Plate JP
    !          ZS - transmitter depth
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !       DPTHL - depth to top of each layer including basement
    !         KFG - Case selector variable

    !             KER - kernel FUNCTION s
    !  HLYRD(JR,1,JB) - only component needed for both closed & open loop
    !  HLYRD(JR,2,JB) - integrands for grounded wire segment
    !

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL(KIND=QL), PARAMETER :: FOURPI = 12.56637061_QL
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER L,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,JR,NROW,NLYR,SXLYR,RXLYR,KFG,JB,NRPRM
    REAL RHOTRP(NRPRM),ZC1L(NROW)
    REAL(KIND=QL) RMUD(0:NLYR),ZS,DELTA,Y1,Y,RD,LMBDA,RHOD
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) HLYRD(NRPRM,3,NROW),KER(JNLO-NRPRM:JNHI,3,NROW)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL JUMP

    KER = ZERO
    DELTA = LOG (10.D0)/ DBLE (NDEC_JN)

    ! Basic integral for open and closed loops.
    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = DBLE (RHOTRP(1) )
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       CALL PRM_KER1_CL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
            SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL PRM_KER1_CL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
            SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRPRM)

    JR = NRPRM
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.
       HLYRD(JR,1,1:NROW) =  HLYRD(JR,1,1:NROW) + KER(K,1,1:NROW) * WJ0(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (SNGL(Y))
          CALL PRM_KER1_CL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
               SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRPRM-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          HLYRD(JR,1,1:NROW) =  HLYRD(JR,1,1:NROW) + KER(K,1,1:NROW) * WJ0(L)
       END DO
    END DO

    DO JB = 1,NROW
       DO JR = 1, NRPRM
          RHOD = REAL (RHOTRP(JR),KIND=QL)
          HLYRD(JR,1,JB) = HLYRD(JR,1,JB) / (FOURPI * RHOD * SIGL(NLYR))
       END DO
    END DO

  END SUBROUTINE PRM_HNK1_CL

  SUBROUTINE PRM_KER1_CL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
       SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
    !---------------------------------------------------------------------------

    !***  Called by PRM_HNK1_LP

    ! Compute the kernels for closed loop integration for layers above basement.
    ! This involves only G potential terms.

    !     NRPRM - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !      ZC1L - depth of row centres in Plate JP
    !        ZS - source location  (negative in air, positive in ground)
    !      NLYR - number of layers including basement. (1 or 2 only)
    !      THKD - thickness of each layer above basement
    !     DPTHL - depth to top of each layer including basement
    !      SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !      KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !      RMUD - relative magetic permeability
    !       KFG - Case selector variable for cells above basewment
    !     SXLYR - Source layer
    !
    !
    !   KER          - kernels for Hankel integraion
    !   HLYRD(*,1,*) - needed for both closed and open loops
    !   HLYRD(*,2,*) - used only for grounded wire segments
    !   HLYRD(*,3,*) - used only for grounded wire segments
    !
    !           JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER JR,L,K,NROW,NLYR,SXLYR,RXLYR,KFG,JZ,NRPRM
    REAL ZC1L(NROW)
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,ZS,ZR,AR,AI,HLYRDR,HLYRDI,ZDR
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX (KIND=QL) XI_V,F_V,F_H,ETA_V,G_V,G_H,XPU,XPD,XPDIR,SL,KER(JNLO-NRPRM:JNHI,3,NROW), &
         FACV,KV,S(0:NLYR),HLYRD(NRPRM,3,NROW),TMP(NROW)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    CALL EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)

    KER(K,1,1:NROW) = ZERO
    TMP = ZERO
    SL = S(RXLYR)
    FACV = RMUD(SXLYR) * KSQL(RXLYR) / (RMUD(RXLYR) * S(SXLYR))

    DO JZ = 1, NROW
       ZR = REAL (ZC1L(JZ),QL)
       XPU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
       XPD = EXP (SL * (DPTHL(RXLYR) - ZR))
       KV = FACV * (XI_V * XPU + ETA_V * XPD)
       KER(K,1,JZ) = -KV * LMBDA
    END DO

    IF (SXLYR == RXLYR) THEN     !  Transmitter in receiver layer
       DO JZ = 1, NROW
          ZDR = ABS (ZS - ZR)
          XPDIR = EXP (-SL * ZDR)
          KV = FACV * XPDIR
          KER(K,1,JZ) = KER(K,1,JZ) - KV * LMBDA
       END DO
    END IF

    JUMP = .TRUE.
    TMP(1:NROW) = KER(K,1,1:NROW) * WJ0(L)

    HLYRD(JR,1,1:NROW) = HLYRD(JR,1,1:NROW) + TMP(1:NROW)
    DO JZ = 1, NROW
       AR = ABS ( REAL (TMP(JZ)) )
       AI = ABS (AIMAG (TMP(JZ)) )
       TOO_BIG = .FALSE.
       HLYRDR = ABS ( REAL (HLYRD(JR,1,JZ)) )
       HLYRDI = ABS (AIMAG (HLYRD(JR,1,JZ)) )
       IF (AR > TOL* HLYRDR) TOO_BIG = .TRUE.
       IF (AI > TOL* HLYRDI) TOO_BIG = .TRUE.
       IF (TOO_BIG) JUMP = .FALSE.
    END DO

  END SUBROUTINE PRM_KER1_CL

  SUBROUTINE PRM_HNK1_OL (NRPRM,RHOTRP,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
       SXLYR,RXLYR,KFG,HLYRD)
    !------------------------------------------------------------------------------

    !***  Calls PRM_KER_OL
    !***  Called by PRM_BOSS_LP

    !  Computes integrals needed to evaluate the primary electric field in one of the
    !  layers above basement due to an open loop source at any depth or elevation.
    !  It uses the flow through Hankel transform method to evaluate the three Hankel
    !  integrals at discrete depths.  The Hankel transform integral uses a 15 point
    !  per decade filter coefficient set derived from Christensen's FLTGEN program.

    !       NRPRM - number of horizontal interpolation points
    !      RHOTRP - 15 points per decade interpolation array
    !        NROW - number of rows
    !        ZC1L - depth of rows in Plate JP
    !          ZS - transmitter depth
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !       DPTHL - depth to top of each layer including basement
    !         KFG - Case selector variable
    !
    !             KER - kernel FUNCTION s
    !  HLYRD(JR,1,JB) - only component needed for both closed & open loop
    !  HLYRD(JR,2,JB) - integrands for grounded wire segment
    !

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    REAL(KIND=QL), PARAMETER :: FOURPI = 12.56637061_QL
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER L,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,JR,NROW,NLYR,SXLYR,RXLYR,KFG,JB,NRPRM
    REAL RHOTRP(NRPRM),ZC1L(NROW)
    REAL(KIND=QL) RMUD(0:NLYR),ZS,DELTA,Y1,Y,RD,LMBDA,RHOD
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) HLYRD(NRPRM,3,NROW),KER(JNLO-NRPRM:JNHI,3,NROW)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL JUMP

    KER = ZERO
    DELTA = LOG (10.D0)/ DBLE (NDEC_JN)

    ! Basic integral for open and closed loops.
    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = DBLE (RHOTRP(1) )
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       CALL PRM_KER1_OL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
            SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (Y)
       K = L + 1 - JR             ! Compute the kernel index.
       CALL PRM_KER1_OL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
            SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRPRM)

    JR = NRPRM
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.

       HLYRD(JR,1,1:NROW) =  HLYRD(JR,1,1:NROW) + KER(K,1,1:NROW) * WJ0(L)
       HLYRD(JR,2,1:NROW) =  HLYRD(JR,2,1:NROW) + KER(K,2,1:NROW) * WJ1(L)
       HLYRD(JR,3,1:NROW) =  HLYRD(JR,3,1:NROW) + KER(K,3,1:NROW) * WJ0(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (SNGL(Y))
          CALL PRM_KER1_OL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
               SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRPRM-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          HLYRD(JR,1,1:NROW) =  HLYRD(JR,1,1:NROW) + KER(K,1,1:NROW) * WJ0(L)
          HLYRD(JR,2,1:NROW) =  HLYRD(JR,2,1:NROW) + KER(K,2,1:NROW) * WJ1(L)
          HLYRD(JR,3,1:NROW) =  HLYRD(JR,3,1:NROW) + KER(K,3,1:NROW) * WJ0(L)
       END DO
    END DO

    DO JB = 1,NROW
       DO JR = 1, NRPRM
          RHOD = REAL (RHOTRP(JR),KIND=QL)
          HLYRD(JR,1:3,JB) = HLYRD(JR,1:3,JB) / (FOURPI * RHOD * SIGL(NLYR))
          HLYRD(JR,2,JB) = HLYRD(JR,2,JB) / RHOD
       END DO
    END DO

  END SUBROUTINE PRM_HNK1_OL

  SUBROUTINE PRM_KER1_OL (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
       SIGL,KSQL,SXLYR,RXLYR,KFG,KER,HLYRD,JUMP)
    !---------------------------------------------------------------------------

    !***  Called by PRM_HNK1_LP

    !  Compute the kernels for grounded wire sources.
    !  This is a mixture of G & F potential terms.

    !     NRPRM - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !      ZC1L - depth of rows in Plate JP
    !        ZS - source location  (negative in air, positive in ground)
    !      NLYR - number of layers including basement. (1 or 2 only)
    !      THKD - thickness of each layer above basement
    !     DPTHL - depth to top of each layer including basement
    !      SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !      KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !      RMUD - relative magetic permeability
    !       KFG - Case selector variable
    !     SXLYR - layer containing source
    !
    !   KER          - kernels for Hankel integraion
    !   HLYRD(*,1,*) - needed for both closed and open loops
    !   HLYRD(*,2,*) - used only for grounded wire segments
    !   HLYRD(*,3,*) - used only for grounded wire segments
    !
    !           JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER JR,L,K,NROW,NLYR,SXLYR,RXLYR,KFG,JZ,NRPRM,JI
    REAL ZC1L(NROW)
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,ZS,ZR,AR,AI,HLYRDR,HLYRDI,GAM,ZDR
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX (KIND=QL) XI_V,F_V,F_H,ETA_V,G_V,G_H,XPU,XPD,XPDIR,KER(JNLO-NRPRM:JNHI,3,NROW), &
         S(0:NLYR),SL,FACV,KV,KS,HLYRD(NRPRM,3,NROW),TMP(3,NROW)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    CALL EDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,F_V,F_H,ETA_V,G_V,G_H)
    KER(K,1:3,1:NROW) = ZERO
    TMP = ZERO
    SL = S(RXLYR)
    FACV = RMUD(SXLYR) * KSQL(RXLYR) / (RMUD(RXLYR) * S(SXLYR))

    DO JZ = 1, NROW
       ZR = REAL (ZC1L(JZ),QL)
       XPU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
       XPD = EXP (SL * (DPTHL(RXLYR) - ZR))
       KV = FACV * (XI_V * XPU + ETA_V * XPD)
       KS = SL * (F_H * XPU - G_H * XPD)
       KER(K,1,JZ) = -KV * LMBDA
       KER(K,2,JZ) = -(KV - KS)
       KER(K,3,JZ) = -(F_H * XPU + G_H * XPD)  * LMBDA
    END DO

    IF (SXLYR == RXLYR) THEN     !  Transmitter in receiver layer
       DO JZ = 1, NROW
          ZDR = ZS - ZR
          GAM = SIGN (1.0_QL, ZDR)
          XPDIR = EXP (-SL * ABS (ZDR))
          KV = FACV * XPDIR
          KS = SL * XPDIR

          KER(K,1,JZ) = KER(K,1,JZ) - KV * LMBDA
          KER(K,2,JZ) = KER(K,2,JZ) - (KV - KS)
          KER(K,3,JZ) = KER(K,3,JZ) - GAM * XPDIR * LMBDA
       END DO
    END IF

    JUMP = .TRUE.
    TMP(1,1:NROW) = KER(K,1,1:NROW) * WJ0(L)
    TMP(2,1:NROW) = KER(K,2,1:NROW) * WJ1(L)
    TMP(3,1:NROW) = KER(K,3,1:NROW) * WJ0(L)

    HLYRD(JR,1:3,1:NROW) = HLYRD(JR,1:3,1:NROW) + TMP(1:3,1:NROW)
    DO JZ = 1, NROW
       DO JI = 1,3
          AR = ABS ( REAL (TMP(JI,JZ)) )
          AI = ABS (AIMAG (TMP(JI,JZ)) )
          TOO_BIG = .FALSE.
          HLYRDR = ABS ( REAL (HLYRD(JR,JI,JZ)) )
          HLYRDI = ABS (AIMAG (HLYRD(JR,JI,JZ)) )
          IF (AR > TOL* HLYRDR) TOO_BIG = .TRUE.
          IF (AI > TOL* HLYRDI) TOO_BIG = .TRUE.
          IF (TOO_BIG) JUMP = .FALSE.
       END DO
    END DO
  END SUBROUTINE PRM_KER1_OL

  SUBROUTINE PRM_BOSS_MD (FRQ,NTX,SXN,SXE,SXZ,SXDIP,SXAZM,NRPRM,RHOTRP,NLYR,THKD,DPTHL, &
       RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB,NB,NA,XCELL,  &
       YCELL,ZCELL,NZ1,ZV1,E_PRYM)
    ! -----------------------------------------------------------------------------------

    !***  Called by LEROI
    !***  Calls PRM_HNK_MD, CUBSPL, C2DINTRP, SETPRM

    !  Computes the primary electric field, E_PRYM, due to a magnetic unit dipole
    !  source, in NPLT plates lying in the basement of a host with NLYR-1 layers
    !  above basement.  R23 is used to rotate the fields into the components
    !  tangential to each plate.
    !
    !  Exy, Eyy and Ezy, Exz are not computed because E_PRM is computed in a
    !  coordinate system where the source lies in the X-Z plane; ie, the source
    !  has is no Y component in this system.
    !
    !  The target (plate) is discretised along strike into NAL cells of length DA
    !  and down dip into NBL cells of width DB.
    !
    !  For a vertical plate along the X axis, the cells are numbered along strike
    !  from the South to the North, first along the top row and then in the same
    !  direction along lower rows.  The last cell would be in the bottom
    !  North corner.  In plan view, the X and Y components of E_PRYM are positive
    !  to the North and East respectively.
    !
    !          INPUT
    !          -----
    !         FRQ - frequency
    !         NTX - number of source positions
    !     SXN,SXE - North, East coordinate of each source position
    !         SXZ - depth of each source position.  (SXZ < 0 in air; SXZ > 0 below surface)
    !       SXDIP - TX inclination of magnetic dipole sources in the vertical plane.
    !       SXAZM - azimuths of magnetic dipole sources in radians. (north = 0; east = PI/2)
    !      RHOTRP - horizontal interpolation array (15 points / decade) of dimension NRPRM
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        PLYR - layer containing plate
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !      DEPTHL - depth to top of each layer including basement
    !        NPLT - number of plates
    !       PLAZM - strike angle in radians
    !       PLDIP - dip angle
    !       PLUNJ - plunge angles
    !        MXAB - maximum number of cells in one plate
    !      NA, NB - number of cells along strike & down dip respectively for each plate
    !  XCELL(k,*) - north coordinate of centre of cell k
    !  YCELL(k,*) - east coordinate of centre of cell k
    !  ZCELL(k,*) - depth of centre of cell k
    !
    !          OUTPUT
    !          ------
    !
    !  E_PRYM(1,*) - complex primary electric fields along strike.
    !  E_PRYM(2,*) - complex primary electric fields down-dip.
    !
    !    The first NAB components of E_PRYM are the fields along strike and
    !    the second group of NA*NB components are along dip.  Thus for a strike
    !    along the X axis, the first NA*NB components would be the X component
    !    of the primary electric field and the second NA*NB components
    !    would be the Y component multiplied by the cosine of the dip angle.
    ! -------------------------------------------------------------------------

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    COMPLEX(KIND=QL), PARAMETER :: ZERO = (0._QL, 0._QL)
    REAL, PARAMETER :: MU0=12.56637E-7, TOL0=1.E-3
    COMPLEX, PARAMETER :: ONE=(1.,0.)
    INTEGER NTX,NRPRM,NLYR,NPLT,PLYR(NPLT),MXAB,NA(NPLT),NB(NPLT),NBL,NAL,JAB,NINTG, &
         JP,JS,JB,JA,JZ,NZ1,I1,KFG,SXLYR,RXLYR
    REAL, DIMENSION(NTX) :: SXN,SXE,SXZ,SXAZM,SXDIP
    REAL, DIMENSION(4,NRPRM) :: QR,QI
    REAL FRQ,RHOTRP(NRPRM),CSDP,SNDP,CSAZ,SNAZ,SAZM,CAZM,CDIP,SDIP,CPLN,SPLN, &
         XCELL(MXAB,NPLT),YCELL(MXAB,NPLT),ZCELL(MXAB,NPLT),RHO,RHOSQ,XBAR0,XBAR, &
         YBAR0,YBAR,XB2,YB2,RAD,XRAD,YRAD,ZRAD,ZTR,ZV1(NZ1),R23(2,3)
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ
    REAL(KIND=QL) RMUD(0:NLYR),ZS
    REAL(KIND=QL), DIMENSION(NLYR) :: THKD,DPTHL
    REAL, ALLOCATABLE, DIMENSION(:,:,:) :: G1R,G2R,G3R,G4R,G5R,G1I,G2I,G3I,G4I,G5I
    REAL(KIND=QL), ALLOCATABLE :: ZV1Q(:)
    COMPLEX EFAC,EFAC0,A0,KR,EX,EY,EZ,EXX,EYX,EZX,EXZ,EYZ,EYXP,EZXP,EXZP,EYZP, &
         E_PRYM(2,MXAB,NTX,NPLT),QQ(5),EXYZ(3),EAB(2)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    COMPLEX(KIND=QL), DIMENSION(:,:,:), ALLOCATABLE :: FXX
    LOGICAL TILT

    EFAC0 = (0.,1.) * FRQ * MU0  / 2.  ! iwu0 / 4 PI
    E_PRYM = (0.,0.)
    I1 = 1            ! magnetic source

    !  Set depth array over which to interpolate Green's FUNCTION integrals

    ALLOCATE (G1R(4,NRPRM,NZ1),G1I(4,NRPRM,NZ1),G2R(4,NRPRM,NZ1),G2I(4,NRPRM,NZ1),G3R(4,NRPRM,NZ1), &
         G3I(4,NRPRM,NZ1),G4R(4,NRPRM,NZ1),G4I(4,NRPRM,NZ1),G5R(4,NRPRM,NZ1),G5I(4,NRPRM,NZ1), &
         FXX(NRPRM,5,NZ1),ZV1Q(NZ1))

    ZV1Q(1:NZ1) = REAL (ZV1(1:NZ1),QL)

    !  Set up array FXX which contains values of the F-potential as a FUNCTION of
    !  of horizontal distance and depth.  Step through different altitude levels.

    RXLYR = NLYR     !  This version restricts the target to be contained in the basement.

    SOURCE_LOOP: DO JS = 1,NTX
       ZS = REAL (SXZ(JS), KIND=QL)
       SXLYR = 0
       DO JZ = NLYR,1,-1
          IF (ZS > DPTHL(JZ)) THEN
             SXLYR = JZ
             EXIT
          END IF
       END DO

       !print *,JZ,SXLYR,ZS
       CALL SET_KFG (I1,NLYR,SXLYR,NLYR,KFG)
       EFAC = EFAC0 * REAL (RMUD(SXLYR))

       NINTG = 1
       SNDP = 0.
       CSDP = 1.
       SNAZ = 0.
       CSAZ = 1.
       TILT = .FALSE.
       IF (ABS (SXDIP(JS)) > TOL0) THEN
          TILT = .TRUE.
          SNDP = SIN (SXDIP(JS))
          CSDP = COS (SXDIP(JS))
          NINTG = 3
          IF (SXLYR > 0) NINTG = 5
       END IF
       IF (ABS (SXAZM(JS)) > TOL0) THEN
          SNAZ = SIN (SXAZM(JS))
          CSAZ = COS (SXAZM(JS))
       END IF

       FXX = ZERO
       CALL PRM_HNK_MD (NRPRM,RHOTRP,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,KFG,RXLYR,SXLYR,NINTG,FXX)

       G1R = 0. ; G2R = 0. ; G3R = 0. ; G4R = 0. ; G5R = 0.
       G1I = 0. ; G2I = 0. ; G3I = 0. ; G4I = 0. ; G5I = 0.

       DO JZ = 1,NZ1
          QR(1,1:NRPRM) =        REAL (FXX(1:NRPRM,1,JZ), 4)
          QI(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,1,JZ)), 4)   ! FXX is in QL precision
          CALL CUBSPL (RHOTRP,QR,NRPRM)
          CALL CUBSPL (RHOTRP,QI,NRPRM)
          G1R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
          G1I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)

          IF (NINTG > 1) THEN                                ! set up horizontal transmitter components
             QR(1,1:NRPRM) =        REAL (FXX(1:NRPRM,2,JZ), 4)
             QI(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,2,JZ)), 4)
             CALL CUBSPL (RHOTRP,QR,NRPRM)
             CALL CUBSPL (RHOTRP,QI,NRPRM)
             G2R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
             G2I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)

             QR(1,1:NRPRM) =        REAL (FXX(1:NRPRM,3,JZ), 4)
             QI(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,3,JZ)), 4)
             CALL CUBSPL (RHOTRP,QR,NRPRM)
             CALL CUBSPL (RHOTRP,QI,NRPRM)
             G3R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
             G3I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)

             IF (NINTG > 3) THEN                                ! set up F potential induced current contribution
                QR(1,1:NRPRM) =        REAL (FXX(1:NRPRM,4,JZ), 4)
                QI(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,4,JZ)), 4)
                CALL CUBSPL (RHOTRP,QR,NRPRM)
                CALL CUBSPL (RHOTRP,QI,NRPRM)
                G4R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
                G4I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)

                QR(1,1:NRPRM) =        REAL (FXX(1:NRPRM,5,JZ), 4)
                QI(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,5,JZ)), 4)
                CALL CUBSPL (RHOTRP,QR,NRPRM)
                CALL CUBSPL (RHOTRP,QI,NRPRM)
                G5R(1:4,1:NRPRM,JZ) = QR(1:4,1:NRPRM)
                G5I(1:4,1:NRPRM,JZ) = QI(1:4,1:NRPRM)
             END IF
          END IF
       END DO

       PLATE_LOOP: DO JP = 1, NPLT
          IF (PLYR(JP) < NLYR) CYCLE
          NAL = NA(JP)
          NBL = NB(JP)
          CAZM = COS (PLAZM(JP) - SXAZM(JS))
          SAZM = SIN (PLAZM(JP) - SXAZM(JS))
          CDIP = COS (PLDIP(JP))
          SDIP = SIN (PLDIP(JP))
          CPLN =  COS (PLUNJ(JP))
          SPLN =  SIN (PLUNJ(JP))
          CALL RXYZ2PLT (CAZM,SAZM,CDIP,SDIP,CPLN,SPLN,R23)

          !  Step through depths, splining FXX for each depth as a FUNCTION of RHO, the
          !  horizontal distance.  Add up contributions for each dipole for each
          !  transmitter.

          DEPTH_STEP: DO JB = 1, NBL
             STRYK_STEP: DO JA = 1, NAL
                JAB = JA + (JB-1)*NAL
                ZTR = ZCELL (JAB,JP)
                EX = (0.,0.) ; EXX = (0.,0.) ; EXZ = (0.,0.)
                EY = (0.,0.) ; EYX = (0.,0.) ; EYZ = (0.,0.)
                EZ = (0.,0.) ; EZX = (0.,0.)
                QQ = (0.,0.)
                RHOSQ = (XCELL(JAB,JP) - SXN(JS) )**2 + (YCELL(JAB,JP) - SXE(JS) )**2
                RHO = SQRT (RHOSQ)
                RHO = MAX (0.1, RHO)

                !  Compute components in system with X along source azimuth at source position.

                XBAR0 = (XCELL(JAB,JP) - SXN(JS)) / RHO
                YBAR0 = (YCELL(JAB,JP) - SXE(JS)) / RHO
                XBAR = XBAR0 * CSAZ + YBAR0 * SNAZ
                YBAR = YBAR0 * CSAZ - XBAR0 * SNAZ
                XB2 = XBAR**2
                YB2 = YBAR**2

                !  Compute direct primary fields if source and receiver are in the same layer.
                !  RXLYR > 0 since target cannot be in air.
                ! print *,sxlyr,rxlyr
                EYXP = (0.,0.); EZXP = (0.,0.); EXZP = (0.,0.); EYZP = (0.,0.)
                IF (SXLYR == RXLYR) THEN
                   RAD = SQRT (RHOSQ + (ZCELL(JAB,JP) - SXZ(JS))**2)
                   RAD = MAX (0.1, RAD)
                   XRAD = XBAR * RHO / RAD
                   YRAD = YBAR * RHO / RAD
                   ZRAD = (ZCELL(JAB,JP) - SXZ(JS) ) / RAD
                   KR = CMPLX (SQRT (KSQL(NLYR))) * RAD
                   A0 = (ONE + KR) * EXP (-KR) / RAD**2
                   EXZP = YRAD * A0;  EZXP = -EXZP
                   EYXP = ZRAD * A0
                   EYZP = -XRAD * A0
                END IF

                QQ(1) = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G1R,G1I,RHO,ZTR)
                EXZ =  QQ(1) * YBAR + EXZP
                EYZ = -QQ(1) * XBAR + EYZP

                IF (TILT) THEN                          ! set up horizontal transmitter components
                   QQ(2) = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G2R,G2I,RHO,ZTR)
                   QQ(3) = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G3R,G3I,RHO,ZTR)
                   EXX =  XBAR * YBAR * (QQ(2) - 2.*QQ(3))

                   IF (SXLYR > 0) THEN                           ! Source is subsurface
                      QQ(4) = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G4R,G4I,RHO,ZTR)
                      QQ(5) = C2DINTRP (RHOTRP,NRPRM,ZV1,NZ1,G5R,G5I,RHO,ZTR)
                      EYX = (1. - 2.*YB2) * QQ(3) + YB2 * QQ(2) - QQ(4) + EYXP
                      EZX = -YBAR * QQ(5) + EZXP
                   ELSE
                      EYX = -( (1. - 2.*XB2) * QQ(3) + XB2 * QQ(2) )    ! KS = 0
                   END IF
                END IF

                EX = EXX * SNDP + EXZ * CSDP
                EY = EYX * SNDP + EYZ * CSDP
                EZ = EZX * SNDP

                EXYZ(1) = EX;  EXYZ(2) = EY;  EXYZ(3) = EZ
                EAB = EFAC * MATMUL (R23, EXYZ)
                E_PRYM(1,JAB,JS,JP) = EAB(1)
                E_PRYM(2,JAB,JS,JP) = EAB(2)
             END DO STRYK_STEP
          END DO DEPTH_STEP
       END DO PLATE_LOOP
    END DO SOURCE_LOOP

    DEALLOCATE (FXX,ZV1Q,G1R,G2R,G3R,G4R,G5R,G1I,G2I,G3I,G4I,G5I)

  END SUBROUTINE PRM_BOSS_MD

  SUBROUTINE PRM_HNK_MD (NRPRM,RHOTRP,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,KFG,RXLYR,SXLYR,NINTG,FXX)
    !---------------------------------------------------------------------------------------------------------

    !***  Calls PRM_KER_MD
    !***  Called by PRM_BOSS

    !  Sets up values of G & F potentials for VMD and HMD sources as a FUNCTION of
    !  horizontal distance at discrete depths.  Using the flow through Hankel
    !  transform method, it evaluates the Hankel transform integral using a 15 point
    !  per decade filter coefficient set derived from Christensen's FLTGEN program.
    !  See PRM_BOSS for variable definitions not appearing below.

    !       NRPRM - number of horizontal interpolation points
    !      RHOTRP - 15 points per decade interpolation array
    !         NZ1 - number of interpolation depths
    !        ZV1Q - array of interpolation depths
    !          ZS - transmitter depth
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !       DPTHL - depth to top of each layer including basement
    !         KFG - Case selector variable
    !       NINTG - number of integrals needed.
    !
    !         KER - kernels for Hankel integraion
    !  FXX(*,1,*) - integrals for EXZ: horizontal electric field from VMD potential
    !               sufficient for VMD source
    !
    !  FXX(*,2,*) - integrals for EXX the inline and EYX the transverse
    !  FXX(*,3,*) - horizontal electric field from HMD potential
    !
    !  FXX(*,4,*) - integrals for EYX from the VED potential
    !  FXX(*,5,*) - integrals for EXZ: horizontal electric field from VED potential
    !               (The VED potential is due only from a subsurfact non-vertical HMD source

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER L,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,JR,NZ1,NLYR,KFG,RXLYR,SXLYR,JB,NRPRM,NINTG
    REAL RHOTRP(NRPRM)
    REAL(KIND=QL) RMUD(0:NLYR),ZS,DELTA,Y1,Y,RD,LMBDA,ZV1Q(NZ1)
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) FSG,FXX(NRPRM,5,NZ1),KER(JNLO-NRPRM:JNHI,5,NZ1)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL JUMP

    KER = ZERO
    FXX = ZERO
    FSG = ZERO
    IF (SXLYR > 0) FSG = SIGL(SXLYR) / SIGL(RXLYR)

    DELTA = LOG (10.D0)/ DBLE (NDEC_JN)

    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = DBLE (RHOTRP(1) )
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       CALL PRM_KER_MD (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD, &
            FSG,SIGL,KSQL,KFG,RXLYR,SXLYR,NINTG,KER,FXX,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       K = L + 1 - JR             ! Compute the kernel index.
       CALL PRM_KER_MD (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD, &
            FSG,SIGL,KSQL,KFG,RXLYR,SXLYR,NINTG,KER,FXX,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRPRM)

    JR = NRPRM
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.

       FXX(JR,1,1:NZ1) =  FXX(JR,1,1:NZ1) + KER(K,1,1:NZ1) * WJ1(L)
       FXX(JR,2,1:NZ1) =  FXX(JR,2,1:NZ1) + KER(K,2,1:NZ1) * WJ0(L)
       FXX(JR,3,1:NZ1) =  FXX(JR,3,1:NZ1) + KER(K,3,1:NZ1) * WJ1(L)
       FXX(JR,4,1:NZ1) =  FXX(JR,4,1:NZ1) + KER(K,4,1:NZ1) * WJ0(L)
       FXX(JR,5,1:NZ1) =  FXX(JR,5,1:NZ1) + KER(K,5,1:NZ1) * WJ1(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (SNGL(Y))
          CALL PRM_KER_MD (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD, &
               FSG,SIGL,KSQL,KFG,RXLYR,SXLYR,NINTG,KER,FXX,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRPRM-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          FXX(JR,1,1:NZ1) =  FXX(JR,1,1:NZ1) + KER(K,1,1:NZ1) * WJ1(L)
          FXX(JR,2,1:NZ1) =  FXX(JR,2,1:NZ1) + KER(K,2,1:NZ1) * WJ0(L)
          FXX(JR,3,1:NZ1) =  FXX(JR,3,1:NZ1) + KER(K,3,1:NZ1) * WJ1(L)
          FXX(JR,4,1:NZ1) =  FXX(JR,4,1:NZ1) + KER(K,4,1:NZ1) * WJ0(L)
          FXX(JR,5,1:NZ1) =  FXX(JR,5,1:NZ1) + KER(K,5,1:NZ1) * WJ1(L)
       END DO
    END DO

    DO JB = 1,NZ1
       DO L = 1,NINTG
          FXX(1:NRPRM,L,JB) = FXX(1:NRPRM,L,JB) / RHOTRP(1:NRPRM)
       END DO
       IF (NINTG > 1) FXX(1:NRPRM,3,JB) = FXX(1:NRPRM,3,JB) / RHOTRP(1:NRPRM)
    END DO

  END SUBROUTINE PRM_HNK_MD

  SUBROUTINE PRM_KER_MD (NRPRM,K,JR,L,LMBDA,NZ1,ZV1Q,ZS,NLYR,THKD,DPTHL,RMUD, &
       FSG,SIGL,KSQL,KFG,RXLYR,SXLYR,NINTG,KER,FXX,JUMP)
    !---------------------------------------------------------------------------

    !***  Called by PRM_HNK_MD
    !***  Calls MDSX_COEF   (RXLYR = NLYR)

    !  Accumulates the integrals at each depth point for array FXX due to magnetic dipole.

    !     NRPRM - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !       NZ1 - number of interpolation depths
    !      ZV1Q - array of interpolation depths
    !        ZS - source location  (negative in air, positive in ground)
    !      NLYR - number of layers including basement. (1 or 2 only)
    !       FSG = SIGL(SXLYR) / SIGL(RXLYR)
    !      SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !      KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !      RMUD - relative magetic permeability
    !      THKD - thickness of each layer above basement
    !     DPTHL - depth to top of each layer including basement
    !       KFG - Case selector variable
    !     NINTG = number of required integrals = 1 for vertical source.  Otherwise NINTG
    !           = 3 for source in air layer and 5 for subsurface source
    !
    !       KER - kernels for Hankel integraion
    !   FXX(*,1,*) - integrals for EXZ: horizontal electric field from VMD potential
    !                sufficient for VMD source
    !
    !          FXX - accumulated potential array
    !   FXX(*,2,*) - integrals for EXX the inline and EYX the transverse
    !   FXX(*,3,*) - horizontal electric field from HMD potential
    !
    !   FXX(*,4,*) - integrals for EYX from the VED potential
    !   FXX(*,5,*) - integrals for EXZ: horizontal electric field from VED potential
    !                (The VED potential is due only from a subsurfact non-vertical HMD source
    !
    !      JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER JR,L,K,NZ1,NLYR,RXLYR,SXLYR,KFG,JZ,NRPRM,NINTG,JINT
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,LMBDA2,ZS,AR,AI,FXXR,FXXI,ZV1Q(NZ1)
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX (KIND=QL) XI_V,XI_H,F_V,ETA_V,ETA_H,G_V,XP1,FSG,SL,SM,K0,K1,KER(JNLO-NRPRM:JNHI,5,NZ1), &
         S(0:NLYR),FXX(NRPRM,5,NZ1),TMP(5,NZ1)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    ! Compute the kernels for the J0, J1 integrations.  Eliminate underflows
    ! due to exponentials.

    TMP = ZERO
    KER(K,1:5,1:NZ1) = ZERO

    CALL MDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,XI_H,F_V,ETA_V,ETA_H,G_V)
    SL = S(RXLYR)
    SM = S(SXLYR)
    LMBDA2 = LMBDA**2

    SELECT CASE (NINTG)
    CASE(1)
       DO JZ = 1, NZ1
          XP1 = EXP (SL * (DPTHL(RXLYR) - ZV1Q(JZ)))
          ETA_V = ETA_V
          KER(K,1,JZ) = XP1 * ETA_V * LMBDA2 / SM
       END DO

    CASE(3)
       DO JZ = 1, NZ1
          XP1 = EXP (SL * (DPTHL(RXLYR) - ZV1Q(JZ)))
          KER(K,1,JZ) = XP1 * ETA_V * LMBDA2 / SM
          KER(K,2,JZ) = XP1 * ETA_H * LMBDA
          KER(K,3,JZ) = XP1 * ETA_H
       END DO

    CASE(5)
       K0 = -G_V * FSG * SL / SM
       K1 = ETA_H - K0
       DO JZ = 1, NZ1
          XP1 = EXP (SL * (DPTHL(RXLYR) - ZV1Q(JZ)))

          KER(K,1,JZ) = XP1 * ETA_V * LMBDA2 / SM
          KER(K,2,JZ) = XP1 * K1 * LMBDA
          KER(K,3,JZ) = XP1 * K1
          KER(K,4,JZ) = XP1 * ETA_H * LMBDA
          KER(K,5,JZ) = XP1 * G_V * FSG * LMBDA2 / SM
       END DO
    END SELECT

    JUMP = .TRUE.
    TMP(1,1:NZ1) = KER(K,1,1:NZ1) * WJ1(L)
    TMP(2,1:NZ1) = KER(K,2,1:NZ1) * WJ0(L)
    TMP(3,1:NZ1) = KER(K,3,1:NZ1) * WJ1(L)
    TMP(4,1:NZ1) = KER(K,4,1:NZ1) * WJ0(L)
    TMP(5,1:NZ1) = KER(K,5,1:NZ1) * WJ1(L)

    FXX(JR,1:NINTG,1:NZ1) = FXX(JR,1:NINTG,1:NZ1) + TMP(1:NINTG,1:NZ1)
    DO JZ = 1, NZ1
       DO JINT = 1,NINTG
          AR = ABS ( REAL (TMP(JINT,JZ)) )
          AI = ABS (AIMAG (TMP(JINT,JZ)) )
          TOO_BIG = .FALSE.
          FXXR = ABS ( REAL (FXX(JR,JINT,JZ)) )
          FXXI = ABS (AIMAG (FXX(JR,JINT,JZ)) )
          IF (AR > TOL* FXXR) TOO_BIG = .TRUE.
          IF (AI > TOL* FXXI) TOO_BIG = .TRUE.
          IF (TOO_BIG) JUMP = .FALSE.
       END DO
    END DO

  END SUBROUTINE PRM_KER_MD

  SUBROUTINE PRM_BOSS_UL_MD (JP,FRQ,NTX,SXN,SXE,SXZ,SXDIP,SXAZM,NRPRM,RHOTRP,NLYR,THKD, &
       DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,PLAZM,PLDIP,PLUNJ,MXAB,MXB, &
       NB,NA,XCELL,YCELL,ZC1L,E_PRYM)
    ! ---------------------------------------------------------------------------------

    !***  Called by LEROI
    !***  Calls PRM_HNK_MD, CUBSPL, SETPRM

    !  This rutine is used for plates above basement.  It deals with one plate at a time.
    !
    !  Computes the primary electric field, E_PRYM, due to a magnetic unit dipole
    !  source, in NPLT plates lying above basement of a host with NLYR-1 layers
    !  above basement.  R23 is used to rotate the fields into the components
    !  tangential to each plate.
    !
    !  Exy, Eyy and Ezy, Exz are not computed because E_PRM is computed in a
    !  coordinate system where the source lies in the X-Z plane; ie, the source
    !  has is no Y component in this system.
    !
    !  The target (plate) is discretised along strike into NAL cells of length DA
    !  and down dip into NBL cells of width DB.
    !
    !  For a vertical plate along the X axis, the cells are numbered along strike
    !  from the South to the North, first along the top row and then in the same
    !  direction along lower rows.  The last cell would be in the bottom
    !  North corner.  In plan view, the X and Y components of E_PRYM are positive
    !  to the North and East respectively.
    !
    !          INPUT
    !          -----
    !          JP - Plate ID
    !         FRQ - frequency
    !         NTX - number of source positions
    !     SXN,SXE - North, East coordinate of each source position
    !         SXZ - depth of each source position.  (SXZ < 0 in air; SXZ > 0 below surface)
    !       SXDIP - TX inclination of magnetic dipole sources in the vertical plane.
    !       SXAZM - azimuths of magnetic dipole sources in radians. (north = 0; east = PI/2)
    !      RHOTRP - horizontal interpolation array (15 points / decade) of dimension NRPRM
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !      DEPTHL - depth to top of each layer including basement
    !        NPLT - number of plates
    !       PLAZM - strike angle in radians
    !       PLDIP - dip angle
    !       PLUNJ - plunge angles
    !        MXAB - maximum number of cells in one plate
    !      NA, NB - number of cells along strike & down dip respectively for each plate
    !  XCELL(k,*) - north coordinate of centre of cell k
    !  YCELL(k,*) - east coordinate of centre of cell k
    !     ZC1L(k) - depth of centre of cell row k
    !
    !          OUTPUT
    !          ------
    !
    !  E_PRYM(1,*) - complex primary electric fields along strike.
    !  E_PRYM(2,*) - complex primary electric fields down-dip.
    !
    !    The first NAB components of E_PRYM are the fields along strike and
    !    the second group of NA*NB components are along dip.  Thus for a strike
    !    along the X axis, the first NA*NB components would be the X component
    !    of the primary electric field and the second NA*NB components
    !    would be the Y component multiplied by the cosine of the dip angle.
    ! -------------------------------------------------------------------------

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    COMPLEX(KIND=QL), PARAMETER :: ZERO = (0._QL, 0._QL)
    REAL, PARAMETER :: MU0=12.56637E-7, TOL0=1.E-3
    COMPLEX, PARAMETER :: ONE=(1.,0.)
    INTEGER NTX,NRPRM,NLYR,NPLT,MXAB,MXB,NROW,NA(NPLT),NB(NPLT),NAL,JAB,NINTG, &
         JP,JS,JB,JA,JL,I1,KFG,SXLYR,RXLYR,PLYR(NPLT)
    REAL, DIMENSION(NTX) :: SXN,SXE,SXZ,SXAZM,SXDIP
    REAL FRQ,RHOTRP(NRPRM),CSDP,SNDP,CSAZ,SNAZ,SAZM,CAZM,CDIP,SDIP,CPLN,SPLN, &
         XCELL(MXAB,NPLT),YCELL(MXAB,NPLT),RHO,RHOSQ,XBAR0,XBAR,YBAR0,YBAR,   &
         XB2,YB2,RAD,XRAD,YRAD,ZRAD,ZR,R23(2,3),ZC1L(MXB)
    REAL, DIMENSION (NPLT) :: PLAZM,PLDIP,PLUNJ
    REAL(KIND=QL) RMUD(0:NLYR),ZS
    REAL(KIND=QL), DIMENSION(NLYR) :: THKD,DPTHL
    REAL, ALLOCATABLE, DIMENSION(:,:) :: G1R,G2R,G3R,G4R,G5R,G1I,G2I,G3I,G4I,G5I
    COMPLEX EFAC,EFAC0,A0,KR,EX,EY,EZ,EXX,EYX,EZX,EXZ,EYZ,EYXP,EZXP,EXZP,EYZP, &
         E_PRYM(2,MXAB,NTX,NPLT),Q1,Q2,Q3,Q4,Q5,EXYZ(3),EAB(2)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    COMPLEX(KIND=QL), DIMENSION(:,:,:), ALLOCATABLE :: FXX
    LOGICAL TILT

    EFAC0 = (0.,1.) * FRQ * MU0  / 2.  ! iwu0 / 4 PI
    E_PRYM(1:2,1:MXAB,1:NTX,JP) = (0.,0.)
    I1 = 1            ! magnetic source

    NROW = NB(JP)
    RXLYR = PLYR(JP)
    IF (RXLYR == NLYR) THEN
       WRITE(4,1); WRITE(*,1)
       STOP
    END IF

    !  Set depth array over which to interpolate Green's FUNCTION integrals

    ALLOCATE (G1R(4,NRPRM),G1I(4,NRPRM),G2R(4,NRPRM),G2I(4,NRPRM),G3R(4,NRPRM),G3I(4,NRPRM), &
         G4R(4,NRPRM),G4I(4,NRPRM),G5R(4,NRPRM),G5I(4,NRPRM),FXX(NRPRM,5,MXB))

    !  Set up array FXX which contains values of the F-potential as a FUNCTION of
    !  of horizontal distance and depth.  Step through different altitude levels.

    SOURCE_LOOP: DO JS = 1,NTX
       ZS = REAL (SXZ(JS), KIND=QL)
       SXLYR = 0
       DO JL = NLYR,1,-1
          IF (ZS > DPTHL(JL)) THEN
             SXLYR = JL
             EXIT
          END IF
       END DO
       EFAC = EFAC0 * REAL (RMUD(SXLYR))

       NINTG = 1
       SNDP = 0.
       CSDP = 1.
       SNAZ = 0.
       CSAZ = 1.
       TILT = .FALSE.
       IF (ABS (SXDIP(JS)) > TOL0) THEN
          TILT = .TRUE.
          SNDP = SIN (SXDIP(JS))
          CSDP = COS (SXDIP(JS))
          NINTG = 3
          IF (SXLYR > 0) NINTG = 5
       END IF
       IF (ABS (SXAZM(JS)) > TOL0) THEN
          SNAZ = SIN (SXAZM(JS))
          CSAZ = COS (SXAZM(JS))
       END IF

       FXX = ZERO
       CALL SET_KFG (I1,NLYR,SXLYR,RXLYR,KFG)
       CALL PRM_HNK1_MD (NRPRM,RHOTRP,NROW,ZC1L,ZS,NLYR,THKD,DPTHL, &
            RMUD,SIGL,KSQL,SXLYR,RXLYR,KFG,NINTG,FXX)
       G1R = 0. ; G2R = 0. ; G3R = 0. ; G4R = 0. ; G5R = 0.
       G1I = 0. ; G2I = 0. ; G3I = 0. ; G4I = 0. ; G5I = 0.

       DO JB = 1,NROW
          G1R(1,1:NRPRM) =        REAL (FXX(1:NRPRM,1,JB), 4)
          G1I(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,1,JB)), 4)   ! FXX is in QL precision
          CALL CUBSPL (RHOTRP,G1R,NRPRM)
          CALL CUBSPL (RHOTRP,G1I,NRPRM)

          IF (NINTG > 1) THEN                                ! set up horizontal transmitter components
             G2R(1,1:NRPRM) =        REAL (FXX(1:NRPRM,2,JB), 4)
             G2I(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,2,JB)), 4)
             G3R(1,1:NRPRM) =        REAL (FXX(1:NRPRM,3,JB), 4)
             G3I(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,3,JB)), 4)
             CALL CUBSPL (RHOTRP,G2R,NRPRM)
             CALL CUBSPL (RHOTRP,G2I,NRPRM)
             CALL CUBSPL (RHOTRP,G3R,NRPRM)
             CALL CUBSPL (RHOTRP,G3I,NRPRM)

             IF (NINTG > 3) THEN                                ! set up F potential induced current contribution
                G4R(1,1:NRPRM) =        REAL (FXX(1:NRPRM,4,JB), 4)
                G4I(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,4,JB)), 4)
                G5R(1,1:NRPRM) =        REAL (FXX(1:NRPRM,5,JB), 4)
                G5I(1,1:NRPRM) = REAL (AIMAG (FXX(1:NRPRM,5,JB)), 4)
                CALL CUBSPL (RHOTRP,G4R,NRPRM)
                CALL CUBSPL (RHOTRP,G4I,NRPRM)
                CALL CUBSPL (RHOTRP,G5R,NRPRM)
                CALL CUBSPL (RHOTRP,G5I,NRPRM)
             END IF
          END IF

          NAL = NA(JP)
          CAZM = COS (PLAZM(JP) - SXAZM(JS))
          SAZM = SIN (PLAZM(JP) - SXAZM(JS))
          CDIP = COS (PLDIP(JP))
          SDIP = SIN (PLDIP(JP))
          CPLN =  COS (PLUNJ(JP))
          SPLN =  SIN (PLUNJ(JP))
          CALL RXYZ2PLT (CAZM,SAZM,CDIP,SDIP,CPLN,SPLN,R23)

          STRYK_STEP: DO JA = 1, NAL
             JAB = JA + (JB-1)*NAL
             EX = (0.,0.) ; EXX = (0.,0.) ; EXZ = (0.,0.)
             EY = (0.,0.) ; EYX = (0.,0.) ; EYZ = (0.,0.)
             EZ = (0.,0.) ; EZX = (0.,0.)
             RHOSQ = (XCELL(JAB,JP) - SXN(JS) )**2 + (YCELL(JAB,JP) - SXE(JS) )**2
             RHO = SQRT (RHOSQ)
             RHO = MAX (0.1, RHO)

             !  Compute components in system with X along source azimuth at source position.

             XBAR0 = (XCELL(JAB,JP) - SXN(JS)) / RHO
             YBAR0 = (YCELL(JAB,JP) - SXE(JS)) / RHO
             XBAR = XBAR0 * CSAZ + YBAR0 * SNAZ
             YBAR = YBAR0 * CSAZ - XBAR0 * SNAZ
             XB2 = XBAR**2
             YB2 = YBAR**2

             !  Compute direct primary fields if source and receiver are in the same layer.
             !  RXLYR > 0 since target cannot be in air.

             EYXP = (0.,0.); EZXP = (0.,0.); EXZP = (0.,0.); EYZP = (0.,0.)
             IF (SXLYR == RXLYR) THEN
                ZR = ZC1L(JB)
                RAD = SQRT (RHOSQ + (ZR - SXZ(JS))**2)
                RAD = MAX (0.1, RAD)
                XRAD = XBAR * RHO / RAD
                YRAD = YBAR * RHO / RAD
                ZRAD = (ZR - SXZ(JS) ) / RAD
                KR = CMPLX (SQRT (KSQL(NLYR))) * RAD
                A0 = (ONE + KR) * EXP (-KR) / RAD**2
                EXZP = YRAD * A0;  EZXP = -EXZP
                EYXP = ZRAD * A0
                EYZP = -XRAD * A0
             END IF

             CALL CCUBVAL(RHOTRP,NRPRM,G1R,G1I,RHO,Q1)
             EXZ =  Q1 * YBAR + EXZP
             EYZ = -Q1 * XBAR + EYZP

             IF (TILT) THEN                          ! set up horizontal transmitter components
                CALL CCUBVAL(RHOTRP,NRPRM,G2R,G2I,RHO,Q2)
                CALL CCUBVAL(RHOTRP,NRPRM,G3R,G3I,RHO,Q3)
                EXX =  XBAR * YBAR * (Q2 - 2.*Q3)

                IF (SXLYR > 0) THEN                           ! Source is subsurface
                   CALL CCUBVAL(RHOTRP,NRPRM,G4R,G5I,RHO,Q4)
                   CALL CCUBVAL(RHOTRP,NRPRM,G5R,G5I,RHO,Q5)
                   EYX = (1. - 2.*YB2) * Q3 + YB2 * Q2 - Q4 + EYXP
                   EZX = -YBAR * Q5 + EZXP
                ELSE
                   EYX = -( (1. - 2.*XB2) * Q3 + XB2 * Q2 )    ! KS = 0
                END IF
             END IF

             EX = EXX * SNDP + EXZ * CSDP
             EY = EYX * SNDP + EYZ * CSDP
             EZ = EZX * SNDP

             EXYZ(1) = EX;  EXYZ(2) = EY;  EXYZ(3) = EZ
             EAB = EFAC * MATMUL (R23, EXYZ)
             E_PRYM(1,JAB,JS,JP) = EAB(1)
             E_PRYM(2,JAB,JS,JP) = EAB(2)
          END DO STRYK_STEP
       END DO

    END DO SOURCE_LOOP
    DEALLOCATE (FXX,G1R,G2R,G3R,G4R,G5R,G1I,G2I,G3I,G4I,G5I)

1   FORMAT (T3,' An evil spirit has entered PRM_BOSS_UL_MD.  Seek help !')

  END SUBROUTINE PRM_BOSS_UL_MD

  SUBROUTINE PRM_HNK1_MD (NRPRM,RHOTRP,NROW,ZC1L,ZS,NLYR,THKD,DPTHL, &
       RMUD,SIGL,KSQL,SXLYR,RXLYR,KFG,NINTG,FXX)
    !-----------------------------------------------------------------

    !***  Calls PRM_KER_MD
    !***  Called by PRM_BOSS

    !  Sets up values of G & F potentials for VMD and HMD sources as a FUNCTION of
    !  horizontal distance at discrete depths.  Using the flow through Hankel
    !  transform method, it evaluates the Hankel transform integral using a 15 point
    !  per decade filter coefficient set derived from Christensen's FLTGEN program.
    !  See PRM_BOSS for variable definitions not appearing below.

    !       NRPRM - number of horizontal interpolation points
    !      RHOTRP - 15 points per decade interpolation array
    !        NROW - number of cell rows in Plate JP
    !        ZC1L - depth of row centres in Plate JP
    !          ZS - transmitter depth
    !        NLYR - number of layers including basement. (1 or 2 only)
    !        SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !        RMUD - relative magetic permeability
    !        THKD - thickness of each layer above basement
    !       DPTHL - depth to top of each layer including basement
    !         KFG - Case selector variable
    !       NINTG - number of integrals needed.
    !         KER - kernels for Hankel integraion
    !
    !  FXX(*,1,*) - integrals for EXZ: horizontal electric field from VMD potential
    !               sufficient for VMD source
    !
    !  FXX(*,2,*) - integrals for EXX the inline and EYX the transverse
    !  FXX(*,3,*) - horizontal electric field from HMD potential
    !
    !  FXX(*,4,*) - integrals for EYX from the VED potential
    !  FXX(*,5,*) - integrals for EXZ: horizontal electric field from VED potential
    !               (The VED potential is due only from a subsurfact non-vertical HMD source

    USE FRANKEN_FILTER_COEFFICIENTS

    IMPLICIT NONE
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER L,LMAX,LMIN,K,KMAX,KMIN,KBOT,K1,JR,NROW,NLYR,SXLYR,RXLYR,KFG,JB,NRPRM,NINTG
    REAL RHOTRP(NRPRM),ZC1L(NROW)
    REAL(KIND=QL) RMUD(0:NLYR),ZS,DELTA,Y1,Y,RD,LMBDA
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX(KIND=QL) FXX(NRPRM,5,NROW),KER(JNLO-NRPRM:JNHI,5,NROW)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL JUMP

    KER = ZERO
    FXX = ZERO

    DELTA = LOG (10.D0)/ DBLE (NDEC_JN)

    ! Set up KER for JR = 1 corresponding to minimum value of RHO.  This will
    ! compute most of the needed kernel range from the high end.  Note that
    ! the filter is defined between JNLO < L < JNHI

    JR = 1
    RD = DBLE (RHOTRP(1) )
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)

    DO L = -50, JNHI             ! Start at L = -50 to pick up low values.
       LMAX = L                   ! Maximum filter index used
       K = L + 1 - JR             ! K is the kernel index.
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       CALL PRM_KER1_MD (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
            SIGL,KSQL,SXLYR,RXLYR,KFG,NINTG,KER,FXX,JUMP)
       IF (JUMP) EXIT
    END DO

    Y = Y1                       ! Finish off the low end for RHOTRP(1)
    DO L = -51, JNLO, -1
       LMIN = L                   ! Minimum filter index used
       Y = Y1 + DBLE (L) * DELTA
       LMBDA = EXP (SNGL(Y))
       K = L + 1 - JR             ! Compute the kernel index.
       CALL PRM_KER1_MD (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
            SIGL,KSQL,SXLYR,RXLYR,KFG,NINTG,KER,FXX,JUMP)
       IF (JUMP) EXIT
    END DO

    KMIN = LMIN + 1 - JR  !  Define the range of kernel values
    KMAX = LMAX + 1 - JR  !  used for RHOTRP(1)

    ! Complete definition of kernel values by evaluating transform of
    ! maximum RHO = RHOTRP (NRPRM)

    JR = NRPRM
    Y1 = -LOG (RD) - DBLE (JR-1) * DELTA - DBLE (SHFTJN)
    KBOT = JNLO + 1 - JR
    K1 = MAX (KBOT,KMIN)

    DO K = K1, KMAX          ! Compute EHR for maximum RHO using previously
       L = K - 1 + JR         ! computed kernel values.

       FXX(JR,1,1:NROW) =  FXX(JR,1,1:NROW) + KER(K,1,1:NROW) * WJ1(L)
       FXX(JR,2,1:NROW) =  FXX(JR,2,1:NROW) + KER(K,2,1:NROW) * WJ0(L)
       FXX(JR,3,1:NROW) =  FXX(JR,3,1:NROW) + KER(K,3,1:NROW) * WJ1(L)
       FXX(JR,4,1:NROW) =  FXX(JR,4,1:NROW) + KER(K,4,1:NROW) * WJ0(L)
       FXX(JR,5,1:NROW) =  FXX(JR,5,1:NROW) + KER(K,5,1:NROW) * WJ1(L)
    END DO

    IF (K1 > KBOT) THEN    !  Add low end kernel values until convergence.
       DO K = K1-1, KBOT, -1
          KMIN = K
          L = K - 1 + JR
          Y = Y1 + DBLE (L) * DELTA
          LMBDA = EXP (SNGL(Y))
          CALL PRM_KER1_MD (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
               SIGL,KSQL,SXLYR,RXLYR,KFG,NINTG,KER,FXX,JUMP)
          IF (JUMP) EXIT
       END DO
    END IF

    DO JR = 2, NRPRM-1          !  Compute transforms for all other RHO values
       DO K = KMIN, KMAX         !  using previously computed kernel values.
          L = K - 1 + JR
          FXX(JR,1,1:NROW) =  FXX(JR,1,1:NROW) + KER(K,1,1:NROW) * WJ1(L)
          FXX(JR,2,1:NROW) =  FXX(JR,2,1:NROW) + KER(K,2,1:NROW) * WJ0(L)
          FXX(JR,3,1:NROW) =  FXX(JR,3,1:NROW) + KER(K,3,1:NROW) * WJ1(L)
          FXX(JR,4,1:NROW) =  FXX(JR,4,1:NROW) + KER(K,4,1:NROW) * WJ0(L)
          FXX(JR,5,1:NROW) =  FXX(JR,5,1:NROW) + KER(K,5,1:NROW) * WJ1(L)
       END DO
    END DO

    DO JB = 1,NROW
       DO L = 1,NINTG
          FXX(1:NRPRM,L,JB) = FXX(1:NRPRM,L,JB) / RHOTRP(1:NRPRM)
       END DO
       IF (NINTG > 1) FXX(1:NRPRM,3,JB) = FXX(1:NRPRM,3,JB) / RHOTRP(1:NRPRM)
    END DO

  END SUBROUTINE PRM_HNK1_MD

  SUBROUTINE PRM_KER1_MD (NRPRM,K,JR,L,LMBDA,NROW,ZC1L,ZS,NLYR,THKD,DPTHL,RMUD, &
       SIGL,KSQL,SXLYR,RXLYR,KFG,NINTG,KER,FXX,JUMP)
    !---------------------------------------------------------------------------

    !***  Called by PRM_HNK_MD
    !***  Calls MDSX_COEF   (RXLYR = NLYR -1 )

    !  Accumulates the integrals for primary E-field in at each depth point in the layer
    !  above basement for array FXX due to magnetic dipole.

    !     NRPRM - number of points in 15 point / decade array
    !         K - filter kernel index
    !        JR - RHO interpolation index
    !         L - filter point index
    !     LMBDA - Hankel transform variable
    !      NROW - number of cell rows in Plate JP
    !      ZC1L - depth of row centres in Plate JP
    !        ZS - source location  (negative in air, positive in ground)
    !      NLYR - number of layers including basement.
    !      SIGL - complex xconductivity for all layers including Cole-Cole & dielectric
    !      KSQL - iwu * SIGL for all layers (includes Cole-Cole)
    !      RMUD - relative magetic permeability
    !      THKD - thickness of each layer above basement
    !     DPTHL - depth to top of each layer including basement
    !       KFG - Case selector variable
    !     NINTG = number of required integrals = 1 for vertical source.  Otherwise NINTG
    !           = 3 for source in air layer and 5 for subsurface source
    !
    !       KER - kernels for Hankel integraion
    !   FXX(*,1,*) - integrals for EXZ: horizontal electric field from VMD potential
    !                sufficient for VMD source
    !
    !          FXX - accumulated potential array
    !   FXX(*,2,*) - integrals for EXX the inline and EYX the transverse
    !   FXX(*,3,*) - horizontal electric field from HMD potential
    !
    !   FXX(*,4,*) - integrals for EYX from the VED potential
    !   FXX(*,5,*) - integrals for EXZ: horizontal electric field from VED potential
    !                (The VED potential is due only from a subsurfact non-vertical HMD source
    !
    !      JUMP - keep integrating if false.

    USE FRANKEN_FILTER_COEFFICIENTS
    IMPLICIT NONE
    REAL, PARAMETER :: TOL=1.E-5
    COMPLEX(KIND=QL), PARAMETER :: ZERO=(0._QL,0._QL)
    INTEGER JR,L,K,NROW,NLYR,RXLYR,SXLYR,KFG,JB,NRPRM,NINTG,JINT
    REAL ZC1L(NROW)
    REAL(KIND=QL) RMUD(0:NLYR),LMBDA,LMBDA2,ZS,ZR,AR,AI,FXXR,FXXI
    REAL(KIND=QL), DIMENSION (NLYR) :: THKD,DPTHL
    COMPLEX (KIND=QL) XI_V,XI_H,F_V,ETA_V,ETA_H,G_V,XPU,XPD,FV1,FV2,KV,KS,SL,SM,S(0:NLYR), &
         KER(JNLO-NRPRM:JNHI,5,NROW),FXX(NRPRM,5,NROW),TMP(5,NROW)
    COMPLEX(KIND=QL), DIMENSION (NLYR) :: SIGL,KSQL
    LOGICAL TOO_BIG,JUMP

    ! Compute the kernels for layer above basement for the J0, J1 integrations.
    ! Eliminate underflows due to exponentials.

    TMP = ZERO
    KER(K,1:5,1:NROW) = ZERO

    CALL MDSX_COEF (SXLYR,RXLYR,KFG,LMBDA,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL, &
         ZS,S,XI_V,XI_H,F_V,ETA_V,ETA_H,G_V)
    SL = S(RXLYR)
    SM = S(SXLYR)
    LMBDA2 = LMBDA**2

    SELECT CASE (NINTG)
    CASE(1)
       DO JB = 1, NROW
          ZR = REAL (ZC1L(JB),QL)
          XPU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
          XPD = EXP (SL * (DPTHL(RXLYR) - ZR))
          KER(K,1,JB) = (XI_V * XPU + ETA_V * XPD) * LMBDA2 / SM
       END DO

    CASE(3)
       DO JB = 1, NROW
          ZR = REAL (ZC1L(JB),QL)
          XPU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
          XPD = EXP (SL * (DPTHL(RXLYR) - ZR))
          KV = XI_H * XPU + ETA_H * XPD

          KER(K,1,JB) = (XI_V * XPU + ETA_V * XPD) * LMBDA2 / SM
          KER(K,2,JB) = KV * LMBDA
          KER(K,3,JB) = KV
       END DO

    CASE(5)
       FV1 = SIGL(SXLYR) / SIGL(RXLYR)
       FV2 = FV1 * S(RXLYR) / S(SXLYR)
       DO JB = 1, NROW
          ZR = REAL (ZC1L(JB),QL)
          XPU = EXP (SL * (ZR - DPTHL(RXLYR+1)))
          XPD = EXP (SL * (DPTHL(RXLYR) - ZR))
          KV = XI_H * XPU + ETA_H * XPD
          KS = FV2 * (F_V * XPU - G_V * XPD)

          KER(K,1,JB) = (XI_V * XPU + ETA_V * XPD) * LMBDA2 / SM
          KER(K,3,JB) = (KV - KS)
          KER(K,2,JB) = KER(K,3,JB) * LMBDA
          KER(K,4,JB) = KV * LMBDA
          KER(K,5,JB) = (F_V* XPU + G_V * XPD) * FV1 * LMBDA2 / SM
       END DO
    END SELECT

    JUMP = .TRUE.
    TMP(1,1:NROW) = KER(K,1,1:NROW) * WJ1(L)
    TMP(2,1:NROW) = KER(K,2,1:NROW) * WJ0(L)
    TMP(3,1:NROW) = KER(K,3,1:NROW) * WJ1(L)
    TMP(4,1:NROW) = KER(K,4,1:NROW) * WJ0(L)
    TMP(5,1:NROW) = KER(K,5,1:NROW) * WJ1(L)

    FXX(JR,1:NINTG,1:NROW) = FXX(JR,1:NINTG,1:NROW) + TMP(1:NINTG,1:NROW)
    DO JB = 1, NROW
       DO JINT = 1,NINTG
          AR = ABS ( REAL (TMP(JINT,JB)) )
          AI = ABS (AIMAG (TMP(JINT,JB)) )
          TOO_BIG = .FALSE.
          FXXR = ABS ( REAL (FXX(JR,JINT,JB)) )
          FXXI = ABS (AIMAG (FXX(JR,JINT,JB)) )
          IF (AR > TOL* FXXR) TOO_BIG = .TRUE.
          IF (AI > TOL* FXXI) TOO_BIG = .TRUE.
          IF (TOO_BIG) JUMP = .FALSE.
       END DO
    END DO

  END SUBROUTINE PRM_KER1_MD

  SUBROUTINE RPLT2XYZ (CA,SA,CD,SD,CP,SP,R32)
    !-------------------------------------------

    ! Builds rotation matrix R32 to transform plate XI, ETA, coordinates or
    ! components to global X,Y,Z representation.  These rotations are based on the
    ! original Leroi convention where the plate azimuthal angle is the user-
    ! specified azimuth - PI/2.  This convention is used to preserve the strong
    ! nexus between the structure of the electric and magnetic Green's tensor
    ! development and the initial XI = north convention for the pre-rotated pate.

    ! All rotations are about axes passing through X0, Y0, Z0 at the midpoint of the
    ! westernern edge of a flat plate whose initial XI coordinate points north and
    ! whose initial ETA coordinate points east.  Plate orientation begins with an
    ! azimuth rotation (positive clockwise) about the Z axis (positive down,
    ! north = 0) followed by a dip rotation, positive clockwise about the rotated XI
    ! axis followed by a plunge rotation about the plate normal.
    !
    ! In practice a mathematical equivalent is used which consists of rotations
    ! about fixed axes in reverse order.  The PLUNGE rotation is performed about the
    ! Z axis followed by a DIP rotation about the X axis followed by the azimuth
    ! rotation PHI about the Z axis
    !
    !  CA, SA - cosine and sine of the redefined plate azimuth
    !  CD, SD - cosine and sine of plate dip
    !  CP, SP - cosine and sine of plate plunge

    IMPLICIT NONE
    REAL CA,SA,CP,SP,CD,SD,R32(3,2),A1(3,3),D1(3,2),P1(2,2),S1(3,2)

    P1 = RESHAPE ((/CP, SP,      -SP, CP               /),  (/2,2/))
    D1 = RESHAPE ((/1., 0., 0.,   0., CD, SD           /),  (/3,2/))
    A1 = RESHAPE ((/CA, SA, 0.,  -SA, CA, 0.,  0.,0.,1./),  (/3,3/))

    S1 =  MATMUL (D1,P1)
    R32 = MATMUL (A1,S1)

  END SUBROUTINE RPLT2XYZ

  SUBROUTINE RXYZ2PLT (CA,SA,CD,SD,CP,SP,R23)
    !-------------------------------------------

    !***  Called by SET_CELLS

    ! Builds rotation matrix R23 to transform global X,Y,Z coordinates or components
    ! to plate XI, ETA representation.  Following the convention described in
    ! SUBROUTINE RPLT2XYZ, this is done by reversing the rotations described in
    ! RPLT2XYZ.
    !
    !  CA, SA - cosine and sine of plate azimuth
    !  CD, SD - cosine and sine of plate dip
    !  CP, SP - cosine and sine of plate rotation


    REAL CA,SA,CP,SP,CD,SD,R23(2,3),P2(2,2),D2(2,3),A2(3,3),S2(2,3)

    A2 = RESHAPE ((/CA, -SA, 0.,  SA, CA, 0.,  0., 0., 1./), (/3,3/))
    D2 = RESHAPE ((/1., 0.,  0., CD,  0., SD             /), (/2,3/))
    P2 = RESHAPE ((/CP, -SP,      SP, CP                 /), (/2,2/))

    S2 =  MATMUL (D2,A2)
    R23 = MATMUL (P2,S2)

  END SUBROUTINE RXYZ2PLT

  SUBROUTINE SET_CELLS_1 (IPR,DPTHB,NLYR,NPLT,PLYR,CELLW,PLNGTH,PLWDTH,PLTOP,PLAZM, &
       PLDIP,PLUNJ,NA,NB,DA,DB,MXCL2,MXAB,NCELL2,ZMIN,ZMAX)
    !-------------------------------------------------------------------------------------

    !***  Called by LEROI
    !***  Calls RPLT2XYZ

    !  This routine sets up the dimensions for the plate cells, establishes vertical
    !  boundaries for interpolation within the basement and shifts basement plates
    !  downwards if plunge would cause a corner to protrude above basement.
    !
    !  Initially, Leroi was set up assuming that prior to rotation the initial
    !  plate strike direction, XI pointed north and ETA pointed east.  After
    !  rotation, the plate azimuth was defined by XI, the direction of the top edge
    !  of the plate.  In order to comply with the way that surfaces are specified
    !  mathematically and geologically, this was changed so that plate azimuth was
    !  defined by the normal to plate, thus implying that the initial direction of
    !  XI was west.
    !
    !  This is accomplished by the simple kludge of letting the user specify azimuth
    !  by the plate normal and then converting this to the original azimuth
    !  (designated by XI) by subtracting PI/2.  This allows the preservation of the
    !  strong nexus between XI & X and between ETA & Y in the electric and magnetic
    !  Green's tensor computations.
    !  Y axis.
    !
    !  Thus the plates will be defined by the user in a coordinate system where XI
    !  points west, ETA points north and Z points down.  All rotations are about
    !  axes that pass through (X0, Y0, Z0).  They are positive clockwise looking
    !  along the positive axis direction.
    !
    !
    !           INPUT AZIMUTH = PHI                       TRANSFORMED AZIMUTH = PHI - 90
    !
    !                                                                    N
    !                    N
    !                                                                    ^
    !                    ^                                               |
    !                    |                                               |
    !                    |
    !                                                           2 _______________ 3
    !        3 _____________________ 4                           |               |
    !         |                     |                            |   ETA -- >    |
    !         |                     |                            |               |
    !         |                     |                            |               |
    !     ^   |                     |                            |               |
    !     |   |                     |                            |  ^            |
    !     |   |                     |  --> E                     |  |            |
    !         |                     |                  X0,Y0,Z0  *  |            |   --> E
    !    ETA  |                     |                            |  XI           |
    !         |                     |                            |               |
    !         |                     |                            |               |
    !         |__________*__________|                            |               |
    !        2                       1                           |               |
    !                 X0,Y0,Z0                                   |               |
    !                                                            |_______________|
    !               <-- XI                                      1                  4
    !
    !
    !  The plate position can be described by an azimuthal rotation (PLAZM) about
    !  the vertical axis, (positive clockwise) a dip rotation (PLDIP) about the new
    !  XI axis, (positive clockwise looking along the XI axis) followed by a
    !  clockwise plunge rotation (PLUNJ) about the new Z axis.  PLAZM is the user-
    !  specified azimuth (in radians) - PI/2.
    !
    !  Mathematically, this is equivalent to rotations about the fixed Z and X axes.
    !  Thus in this routine the plate position is described by an initial plunge
    !  (PLUNJ) rotation about the Z axis followed by PLDIP about the X axis followed
    !  by PLAZM about the Z axis.
    !
    !  -90 <= PLUNJ  <=  90  is applied about the Z axis followed by
    !    0 <= PLDIP  <= 180  applied about the X axis followed by
    !    0 <= PLAZM  <= 180  applied about the spatial Z axis
    !
    !        Input variables
    !        ---------------
    !
    !   IPR       = output unit number for Leroi.out if pRINTout is enabled
    !             = 0 if pRINTout is suppressed
    !   DPTHB     - depth to basement
    !   NLYR      - Number of Layers
    !   NPLT      - Number of plates
    !   PLYR      - Layer number for each plate
    !   CELLW     - nominal cell dimension
    !   PLNGTH    - strike length for each plate
    !   PLWDTH    - dip width for each plate
    !   PLTOP     - depth to plate reference & pivot point
    !   PLAZM     - plate azimuths
    !   PLDIP     - plate dip angles
    !   PLUNJ     - plunge angles
    !
    !          Output variables
    !          ----------------
    !
    !   NA, NB      - number of cells along strike and down dip respectively
    !   DA, DB      - dimension of cells along strike and down dip respectively
    !   MXAB        - Number of cells in biggest plate
    !   NCELL2(J)   - 2 * the number of cells in plates 1 to J
    !   MXCL2       - 2 * total number of cells in all plates = NCELL2(NPLT)
    !   ZMIN, ZMAX  - minimum and maximum levels for Green's FUNCTION interpolation
    !                 in vertical direction for basement plates.

    IMPLICIT NONE
    INTEGER IPR,NW,MXAB,MXCL2,NLYR,NPLT,PLYR(NPLT),NCELL2(0:NPLT),JP,JB,KMPL
    INTEGER, DIMENSION(NPLT) :: NA,NB
    REAL CELLW,P(2),XYZ(3),R32(3,2),DPTHB,CA,SA,CP,SP,CD,SD,ZMINP,ZMIN,ZMAX,TMPL
    REAL, DIMENSION(4) :: XCNR,YCNR,ZCNR
    REAL, DIMENSION(NPLT) :: PLNGTH, PLWDTH,PLTOP,SHIFT,PLAZM,PLUNJ,PLDIP,DA,DB
    LOGICAL PRT

    NCELL2 = 0 ; MXAB = 0

    IF (MAXVAL (PLYR) < NLYR) THEN
       ZMIN = 1.0
       ZMAX = 2.0
    ELSE
       ZMIN = 1.E6 ;  ZMAX = -1.E6
    END IF

    IF (IPR == 0) THEN
       NW = -9
       PRT = .FALSE.
    ELSE
       NW = IPR
       PRT = .TRUE.
    END IF

    SHIFT = 0.
    DO JP = 1, NPLT      !  Sum over plates
       TMPL = MIN (PLNGTH(JP), PLWDTH(JP)) / 2.   ! Cell numbers and sizes
       TMPL = MIN (TMPL, CELLW) + .01
       NA(JP) = CEILING (PLNGTH(JP) / TMPL)
       NA(JP) = MAX (2,NA(JP))
       DA(JP) = PLNGTH(JP) / REAL (NA(JP))


       NB(JP) = CEILING (PLWDTH(JP) / TMPL)
       NB(JP) = MAX (2,NB(JP))                  ! Number of rows
       DB(JP) = PLWDTH(JP) / REAL (NB(JP))      ! Width of rows
       KMPL = NA(JP) * NB(JP)
       MXAB = MAX (MXAB,KMPL)
       NCELL2(JP) = NCELL2(JP-1) + 2* KMPL

       IF (PLYR(JP) == NLYR) THEN               ! Restrict basement plates to basement

          CA = COS (PLAZM(JP));   SA = SIN (PLAZM(JP))
          CD = COS (PLDIP(JP));   SD = SIN (PLDIP(JP))
          CP = COS (PLUNJ(JP));   SP = SIN (PLUNJ(JP))

          CALL RPLT2XYZ (CA,SA,CD,SD,CP,SP,R32)  ! Rotation matrix

          XCNR(2:3) = PLNGTH(JP) / 2.
          XCNR(1) = -XCNR(2);  XCNR(4) = XCNR(1)
          YCNR(1:2) = 0.
          YCNR(3:4) = PLWDTH(JP)

          DO JB = 1,4
             P(1) = XCNR(JB)
             P(2) = YCNR(JB)
             XYZ = MATMUL (R32,P)
             ZCNR(JB) = XYZ(3) + PLTOP(JP)
          END DO
          ZMINP = MINVAL (ZCNR)

          IF (ZMINP < DPTHB) THEN
             SHIFT(JP) = DPTHB - ZMINP
             ZCNR(1:4) = ZCNR(1:4) + SHIFT(JP)
             PLTOP(JP) = PLTOP(JP) + SHIFT(JP)
          END IF

          IF (PRT .AND. SHIFT(JP) > 0.01) THEN
             WRITE(*,1)   JP,SHIFT(JP)
             WRITE(NW,1)   JP,SHIFT(JP)
          END IF
          ZMIN = MIN (ZMIN, MINVAL (ZCNR))
          ZMAX = MAX (ZMAX, MAXVAL (ZCNR))
       END IF
    END DO
    ZMIN = MAX (ZMIN, DPTHB + 0.01)
    MXCL2 = NCELL2(NPLT)

1   FORMAT (//T3,'********************************************************'     &
         /T3,'Plate',I3,' has been shifted down by',F7.2,' m to prevent it' &
         /T3,'from extending above basement.'                               &
         /T3,'********************************************************')

  END SUBROUTINE SET_CELLS_1

  SUBROUTINE SET_CELLS_2 (IPR,NPLT,MXAB,XCNTR,YCNTR,PLTOP,PLAZM,PLDIP, &
       PLUNJ,NA,NB,DA,DB,XCELL,YCELL,ZCELL)
    !-------------------------------------------------------------------

    !***  Called by LEROI
    !***  Calls RPLT2XYZ

    !        Input variables
    !        ---------------
    !
    !   IPR       = output unit number for Leroi.out if pRINTout is enabled
    !             = 0 if pRINTout is suppressed
    !   NPLT      - Number of plates
    !   MXAB      - Number of cells in biggest plate
    !   XCNTR     - north coordinates of plate reference & pivot point
    !   YCNTR     - east coordinates of plate reference & pivot point
    !   PLTOP     - depth to plate reference & pivot point
    !   PLAZM     - plate azimuths
    !   PLDIP     - plate dip angles
    !   PLUNJ     - plunge angles
    !   NA, NB    - number of cells along strike and down dip respectively
    !   DA, DB    - dimension of cells along strike and down dip respectively
    !
    !          Output variables
    !          ----------------
    !
    !   XCELL(k,JP) - X (north) coordinate of centre of cell k of plate JP.
    !   YCELL(k,JP) - Y (east) coordinate of centre of cell k of plate JP.
    !   ZCELL(i,JP) - depth of cell centre in row i of plate nrelative to surface.

    IMPLICIT NONE
    REAL, PARAMETER :: TOL=0.001
    INTEGER IPR,NW,MXAB,NPLT,JP,JA,JB,JAB,NBL
    INTEGER, DIMENSION(NPLT) :: NA,NB
    REAL XI0,ETA0,P(2),XYZ(3),R32(3,2),CA,SA,CP,SP,CD,SD
    REAL, DIMENSION(NPLT) :: XCNTR,YCNTR,PLTOP,PLAZM,PLUNJ,PLDIP,DA,DB
    REAL, DIMENSION(MXAB,NPLT) :: XCELL,YCELL,ZCELL
    LOGICAL PRT

    !print *,plunj
    !  Lay out initial cell pattern in coordinate system centred 1t (XCNTR, YCNTR, PLTOP)
    !  Compute corner coordinates as well.

    XCELL = 0. ; YCELL = 0. ; ZCELL = 0.

    IF (IPR == 0) THEN
       NW = -9
       PRT = .FALSE.
    ELSE
       NW = IPR
       PRT = .TRUE.
    END IF

    DO JP = 1, NPLT      !  Sum over plates

       CA = COS (PLAZM(JP));   SA = SIN (PLAZM(JP))
       CD = COS (PLDIP(JP));   SD = SIN (PLDIP(JP))
       CP = COS (PLUNJ(JP));   SP = SIN (PLUNJ(JP))

       CALL RPLT2XYZ (CA,SA,CD,SD,CP,SP,R32)  ! Rotation matrix

       JAB = 0
       XI0 =  -(NA(JP) + 1) * DA(JP) / 2.
       ETA0 = -DB(JP) /2.
       NBL = NB(JP)

       DO JB = 1, NBL
          DO JA = 1, NA(JP)
             JAB = JAB + 1
             P(1) = XI0 + JA* DA(JP)
             P(2) = ETA0 + JB* DB(JP)
             XYZ = MATMUL (R32,P)

             XCELL(JAB,JP) = XYZ(1) + XCNTR(JP)
             YCELL(JAB,JP) = XYZ(2) + YCNTR(JP)
             ZCELL(JAB,JP) = XYZ(3) + PLTOP(JP)
             IF (ABS (XCELL(JAB,JP)) < TOL) XCELL(JAB,JP) = 0.
             IF (ABS (YCELL(JAB,JP)) < TOL) YCELL(JAB,JP) = 0.
          END DO
       END DO
    END DO

    IF (PRT) THEN
       DO JP = 1,NPLT
          WRITE(NW,4) JP,NA(JP),DA(JP),NB(JP),DB(JP)
          WRITE(NW,5) JP
          DO JB = 1, NB(JP)
             DO JA = 1, NA(JP)
                JAB = JA + ((JB-1) * NA(JP))
                IF (ABS (XCELL(JAB,JP)) < TOL) XCELL(JAB,JP) = 0.
                IF (ABS (YCELL(JAB,JP)) < TOL) YCELL(JAB,JP) = 0.
                IF (JA == 1) THEN
                   IF (JB > 1) WRITE(NW,'(A)') '  '
                   WRITE(NW,'(I5,I7,6X,3G13.4)') JB,JA,YCELL(JAB,JP),XCELL(JAB,JP),ZCELL(JAB,JP)
                ELSE
                   WRITE(NW,'(5X,I7,6X,3G13.4)')    JA,YCELL(JAB,JP),XCELL(JAB,JP),ZCELL(JAB,JP)
                END IF
             END DO
          END DO
       END DO
    END IF

4   FORMAT(/T3,'Plate',I3,' is discretised into:', &
         /T6,I3,' columns of cells of length',F7.2,' metres along strike and' &
         /T6,I3,' rows of cells of length',F7.2,' metres down dip.')
5   FORMAT (//11X,'Target Cell Centre Locations for Plate',I2         &
         /11X,'----------------------------------------'          &
         //'   Dip   Strike                      '                 &
         /'  Index  Index        (East)      (North)       Depth' &
         /'  -----  ------       ------      -------       -----')
  END SUBROUTINE SET_CELLS_2

  SUBROUTINE SCAT_MTRX_BOSS (NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,NTPL,IDPL,PLYR,MXB,MXAB,NCELL2, &
       MXCL2,NA,NB,DA,DB,SIGT,KSQT,PLTOP,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,    &
       ZCELL,NZ2,ZV2,ZC1,NREGT,RHOTRP,NTX,E_PRYM,J_SCAT,DCMP_FAIL)
    !----------------------------------------------------------------------------------------------
    !  Sets up the global multi-plate system matrix SCAT_MTRX from the Green's
    !  tensor elements.  Using Weidelt's formalism to construct the system matrix,
    !  SCAT_MTRX_LU_DCMP is called to replace SCAT_MTRX by its LU decomposition.
    !  Finally, SCAT_CRNT is called to yield the scattering currents on each plate.

    !***  Called by MAIN
    !***  Calls EGT_BOSS, INTER_EGT_BOSS, SCAT_MTRX_LU_DCMP, SCAT_CRNT

    !  In what follows, the GTE have the units of electric field divided by a
    !  factor (-iwu) because this factor is explicitly included as a multiplier
    !  outside the integral over area when solving the integral equation.
    !
    !  These modified integrated Green's FUNCTION s are initially computed in the form:
    !
    !  GAA = SAA + VAA /KSQN;  GAB = SAB + VAB /KSQN;
    !                             GBA = SAB + VBA /KSQN  &
    !  GBB = SBB + VBB /KSQN   where  KSQN :=  i * omega * mu / RES(NLYR).
    !
    !  SAA, SAB=SBA, & SBB are the induced (divergence free) part of the GTE,
    !  corresponding to currents enclosed within the plate.
    !  VAA, VAB, VBA, & VBB were originally the curl-free or current channelling
    !  part of the GTE.
    !
    !  SAA(KS,KR,IR) is the electric field in the XI (strike) direction, integrated
    !  over receiver cell (IR,KR) due to a XI-oriented electric dipole at cell (1,KS).
    !  Similarly, SAB(KS,KR,IR) is the electric field in the ETA direction caused
    !  by the same dipole.  SBB is the ETA electric field caused by an
    !  ETA-oriented electric dipole.  Similarly for VAA, VAB, VBA, & VBB.
    !
    !  The solution vector is expressed as the curl and gradient of two
    !  potential FUNCTION s in the form CURL (*C* PSI) + KSQN * GRAD (PHI) where
    !  *C* is a unit vector perpendicular to the plate surface.  The actual form of
    !  the solution vector consists of the values of the PSI and PHI potentials on
    !  the corners of the plate cells.  Thus in building the global matrix,
    !  SCAT_MTRX_BUILD has to account for the curl and grad operations as well as
    !  including the Green's tensor elements/
    !
    !  The big advantage of Weidelt's formulation is that the 1 / KSQ_LYR term can be
    !  removed since the surface integrals of HIJ * CURL (*C* PSI) are identically
    !  zero.  SUBROUTINE SCAT_MTRX_BUILD thus uses the redefined
    !  HIJ - HIJ + SIJ* KSQN input from EGT_BOSS.
    !
    !  For E := either E_PRYM or J_SCAT -
    !
    !  E (1,JCELL,JS,JP) is the field (current) in the strike direction in the
    !                       centre of plate cell number JCELL of plate JP due
    !                       to transmitter JS
    !  E (2,JCELL,JS,JP) is the field (current) in the down-dip direction in the
    !                       centre of plate cell number JCELL of plate JP due
    !                       to transmitter JS
    !
    !         OUTPUT: J_SCAT
    !
    !         INPUT
    !         -----
    !
    !           NPLT - number of plates in basement
    !           NLYR - number of layers (1 or 2)
    !  NA(J) & NB(J) - number of cells along strike and down dip for each plate
    !  DA(J) & DB(J) - dimension of cells along strike and down dip for each plate
    !           MXAB - maximum number of cells in a single plate
    !      NCELL2(J) - 2 * the number of cells in plates 1 to J
    !          MXCL2 - 2 * total number of cells in al plates = NCELL2(NPLT)
    !        SIGT(J) - complex conductivity thickness product of plate J
    !        KSQT(J) - iwu * SIGT
    !        SIGL(J) - complex conductivity thickness product of layer J
    !        KSQL(J) - iwu * SIGL
    !          DPTHB - depth to basement
    !          PLDIP - dip angle for each plate
    !          PLUNJ - plunge angles
    !         RHOTRP - interpolation array for electric Green's FUNCTION s
    !          NREGT - maximum index for RHOTRP
    !           NTX - number of transmitter locations
    !         E_PRYM - primary electric field incident of each plate.
    !
    !         INTERNAL COMPUTATIONS
    !         ---------------------
    !  SAA, SBA, SBB - complex Green's kernels from EGT_BOSS for vortex currents
    !                  (closed in the plate)
    !  VAA, VAB, VBA - complex Green's kernels from EGT_BOSS for current gathering
    !          & VBB   (currents closed outside the plate) + the SIJ * BAS
    !      SCAT_MTRX - LU decomposed form of system matrix
    !           INDX - pivoting vector information

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER NTX,NLYR,RXLYR,NPLT,NTPL,NAL,NBL,NAB,MXCL2,MCELL2,NCELL2(0:NPLT),MXAB,MXA,MXB,IPHI(4),IPSI(4), &
         KB,JB,KA,JA,JZ,L,IDX(4),INDX(MXCL2),NREGT,JP,JPS,JPR,JSX,JRX,JSXRX,KAB,KABG,JAB,NZ2
    INTEGER, DIMENSION(NPLT) :: NA,NB,PLYR,IDPL
    REAL AD(4),BD(4),GA,GB,DAL,DBL,DPTHB,PTOPL,CAZM,SAZM,CDP,SDP,CPL,SPL, &
         RHOTRP(NREGT),ZTR,ZV2(NZ2),ZC1(MXB,NTPL),ZC1L(MXB)
    REAL(KIND=QL) RMUD(0:NLYR),THKD(NLYR),DPTHL(NLYR)
    REAL, DIMENSION (NPLT) :: DA,DB,PLTOP,PLAZM,PLDIP,PLUNJ
    REAL, DIMENSION (MXAB,NPLT) :: XCELL,YCELL,ZCELL,AREA
    REAL, DIMENSION(4,NREGT) :: GR1,GI1,GR2,GI2,GR3,GI3,GR4,GI4,GR5,GI5,GR6,GI6
    REAL, DIMENSION(4,NREGT,NZ2) :: GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,GI5Z,GR6Z,GI6Z
    REAL, ALLOCATABLE, DIMENSION(:) :: XCEL1,YCEL1,ZCEL1
    COMPLEX KSQN,SCAT_MTRX(MXCL2,MXCL2),E_PRYM(2,MXAB,NTX,NPLT),J_SCAT(2,MXAB,NTX,NPLT), &
         AAS,ABSS,BAS,BBS,AAV,ABV,BAV,BBV,APSI(4),BPSI(4),APHI(4),BPHI(4)
    COMPLEX,DIMENSION(NPLT) :: KSQT, SIGT
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: KSQL, SIGL
    COMPLEX,DIMENSION(:,:,:,:),ALLOCATABLE :: SAA,SBA,SBB,VAA,VAB,VBA,VBB
    COMPLEX,DIMENSION(:,:),ALLOCATABLE :: VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI
    LOGICAL DCMP_FAIL

    KSQN = CMPLX (KSQL(NLYR))
    DPTHB = REAL (DPTHL(NLYR))              ! Depth to basement

    SCAT_MTRX = ZERO

    !  Set depth array over which to interpolate Green's FUNCTION integrals

    GR1Z = 0; GR2Z = 0; GR3Z = 0; GR4Z = 0; GR5Z = 0; GR6Z = 0
    GI1Z = 0; GI2Z = 0; GI3Z = 0; GI4Z = 0; GI5Z = 0; GI6Z = 0

    DO JZ = 1,NZ2
       ZTR = ZV2(JZ)
       CALL EGT_CSPL (NREGT,RHOTRP,NLYR,THKD,RMUD,SIGL,KSQL,ZTR,GR1,GI1, &
            GR2,GI2,GR3,GI3,GR4,GI4,GR5,GI5,GR6,GI6)

       GR1Z(1:4,1:NREGT,JZ) = GR1(1:4,1:NREGT)
       GR2Z(1:4,1:NREGT,JZ) = GR2(1:4,1:NREGT)
       GR3Z(1:4,1:NREGT,JZ) = GR3(1:4,1:NREGT)
       GR4Z(1:4,1:NREGT,JZ) = GR4(1:4,1:NREGT)
       GR5Z(1:4,1:NREGT,JZ) = GR5(1:4,1:NREGT)
       GR6Z(1:4,1:NREGT,JZ) = GR6(1:4,1:NREGT)
       GI1Z(1:4,1:NREGT,JZ) = GI1(1:4,1:NREGT)
       GI2Z(1:4,1:NREGT,JZ) = GI2(1:4,1:NREGT)
       GI3Z(1:4,1:NREGT,JZ) = GI3(1:4,1:NREGT)
       GI4Z(1:4,1:NREGT,JZ) = GI4(1:4,1:NREGT)
       GI5Z(1:4,1:NREGT,JZ) = GI5(1:4,1:NREGT)
       GI6Z(1:4,1:NREGT,JZ) = GI6(1:4,1:NREGT)
    END DO

    ! Set up the single plate - host interactions ; ie the block diagonal
    ! part of the scattering matrix.

    PLATE_LOOP: DO JP = 1,NPLT
       PTOPL = PLTOP(JP)
       NAL = NA(JP)  ! Set up local dimensions for single plate operations
       NBL = NB(JP)
       NAB = NAL * NBL
       DAL = DA(JP)
       DBL = DB(JP)
       DO JAB = 1,NAB
          AREA(JAB,JP) = DAL * DBL
       END DO
       CAZM = COS (PLAZM(JP))
       SAZM = SIN (PLAZM(JP))
       CDP = COS (PLDIP(JP))
       SDP = SIN (PLDIP(JP))
       CPL = COS (PLUNJ(JP))
       SPL = SIN (PLUNJ(JP))
       MCELL2 = NCELL2(JP-1)    ! Index to start each plate

       ! Compute electric Green's tensor integrals,

       ALLOCATE (SAA(NBL,NBL,NAL,NAL),SBA(NBL,NBL,NAL,NAL),SBB(NBL,NBL,NAL,NAL), &
            VAA(NBL,NBL,NAL,NAL),VAB(NBL,NBL,NAL,NAL),VBA(NBL,NBL,NAL,NAL), &
            VBB(NBL,NBL,NAL,NAL),XCEL1(NAB),YCEL1(NAB),ZCEL1(NAB))


       IF (ABS (SPL) > 0.01) THEN    ! Plunge must be taken into account
          CALL EGT_PL_BOSS (NAL,NBL,NAB,DAL,DBL,KSQN,DPTHB,PTOPL,CDP,SDP,CPL,SPL,NZ2,ZV2, &
               NREGT,RHOTRP,GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,    &
               GI5Z,GR6Z,GI6Z,SAA,SBA,SBB,VAA,VAB,VBA,VBB)

       ELSE

          !  Use XI symmetry.  Azimuth is irrelevant for single plate EGT
          !  Define local cell separations along strike!

          DO JAB = 1,NAB
             XCEL1(JAB) = XCELL(JAB,JP) * CAZM + YCELL(JAB,JP) * SAZM
             YCEL1(JAB) = YCELL(JAB,JP) * CAZM - XCELL(JAB,JP) * SAZM
             ZCEL1(JAB) = ZCELL(JAB,JP)
          END DO

          IF (PLYR(JP) == NLYR) THEN

             CALL EGT_BOSS (NAL,NBL,NAB,DAL,DBL,KSQN,DPTHB,XCEL1,YCEL1,ZCEL1,CDP,SDP,CPL, &
                  SPL,NZ2,ZV2,NREGT,RHOTRP,GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,  &
                  GI4Z,GR5Z,GI5Z,GR6Z,GI6Z,SAA,SBA,SBB,VAA,VAB,VBA,VBB)
          ELSE
             RXLYR = PLYR(JP)
             JPS = IDPL(JP)
             ZC1L(1:NBL) = ZC1(1:NBL,JPS)
             CALL EGT_UL_BOSS (NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NAL,NBL,NAB,DAL,DBL,XCEL1,YCEL1, &
                  ZC1L,RXLYR,CDP,SDP,NREGT,RHOTRP,SAA,SBA,SBB,VAA,VAB,VBA,VBB)
          END IF
       END IF

       GA = .5 / DAL   ! part of the CURL and GRAD
       GB = .5 / DBL   ! numerical differentiations

       AD(1) = -GA    !  This is the stencil corresponding to the identity
       AD(2) = +GA    !  matrix acting on the psi and phi values keeping in
       AD(3) = -GA    !  mind that we are inverting
       AD(4) = +GA    !                                     [PHI]
       BD(1) = -GB    !                             {I + G} [   ] = Ep
       BD(2) = -GB    !                                     [PSI}
       BD(3) = +GB    !
       BD(4) = +GB    !

       ! Construction of the system of equations.  JB and JA are the row and column
       ! indices of the "receiver" cells

       LOOP_JB_NBL: DO JB = 1,NBL                   !  each cell has local numbers
          LOOP_JA_NAL: DO JA = 1,NAL
             IDX = 1                                  !   1  2
             IF ( JB==1 .OR. JA==1 ) IDX(1) = 0       !   3  4
             IF ( JB==1 .OR. JA==NAL ) IDX(2) = 0     !         IDX is a stencil used
             IF ( JB==NBL .OR. JA==1 ) IDX(3) = 0     ! to set PSI values to zero on
             IF ( JB==NBL .OR. JA==NAL ) IDX(4) = 0   ! all edge nodes of plate

             ! For each cell, assign global node numbers for PHI and PSI values
             ! at cell corners: 1, 2, 3, & 4.  PSI values take up the first
             ! (NA-1) * (NB-1) solution vector places since PSI = 0 on all plate edges.
             ! PHI values take up the next (NA+1) * (NB + 1) - 2 places for a total
             ! length of 2 * NA * NB.

             IPSI(1) = MCELL2 + (JB - 2) * (NAL - 1) + JA - 1
             IPSI(2) = IPSI(1) + 1
             IPSI(3) = IPSI(1) + NAL - 1
             IPSI(4) = IPSI(3) + 1
             IPHI(1) = MCELL2 + (NAL - 1) * (NBL - 1) + (JB - 1) * (NAL + 1) + JA
             IPHI(2) = IPHI(1) + 1
             IPHI(3) = IPHI(2) + NAL
             IPHI(4) = IPHI(3) + 1

             ! Sum Green's tensor "source" contributions.  KB and KA are the
             ! row and column indices of the "source" cells

             LOOP_KA_NAL: DO KA = 1,NAL
                LOOP_KB_NBL: DO KB = 1,NBL
                   KAB = MCELL2   + 2* ((KB-1) *NAL + KA)

                   ! SAB, VAB, & VBA change sign if the XI (source cell) > XI (receiver cell);
                   ! ie, EGT_BOSS assumes the source to the left of the receiver.

                   AAS = SAA(KB,JB,KA,JA)
                   BAS = SBA(KB,JB,KA,JA)
                   BBS = SBB(KB,JB,KA,JA)
                   AAV = VAA(KB,JB,KA,JA)
                   ABV = VAB(KB,JB,KA,JA)
                   BAV = VBA(KB,JB,KA,JA)
                   BBV = VBB(KB,JB,KA,JA)

                   APSI(1) = KSQT(JP) * (- GB*AAS + GA*BAS)   ! cell corner PSI contribution
                   APSI(2) = KSQT(JP) * (- GB*AAS - GA*BAS)   ! to along strike field
                   APSI(3) = -APSI(2)
                   APSI(4) = -APSI(1)
                   BPSI(1) = KSQT(JP) * (-GB*BAS + GA*BBS)    ! cell corner PSI contribution
                   BPSI(2) = KSQT(JP) * (-GB*BAS - GA*BBS)    ! to down dip field
                   BPSI(3) = -BPSI(2)
                   BPSI(4) = -BPSI(1)
                   APHI(1) = KSQT(JP) * (-GA*AAV - GB*ABV)    ! cell corner PHI contribution
                   APHI(2) = KSQT(JP) * (+GA*AAV - GB*ABV)    ! to along strike field
                   APHI(3) = -APHI(2)
                   APHI(4) = -APHI(1)
                   BPHI(1) = KSQT(JP) * (-GA*BAV - GB*BBV)    ! cell corner PHI contribution
                   BPHI(2) = KSQT(JP) * (+GA*BAV - GB*BBV)    ! to down dip field
                   BPHI(3) = -BPHI(2)
                   BPHI(4) = -BPHI(1)
                   DO L = 1,4
                      IF (IPHI(L) <= NCELL2(JP) ) THEN
                         SCAT_MTRX(KAB-1, IPHI(L)) = SCAT_MTRX(KAB-1, IPHI(L)) + APHI(L)
                         SCAT_MTRX(KAB,   IPHI(L)) = SCAT_MTRX(KAB,   IPHI(L)) + BPHI(L)
                      END IF
                      IF (IDX(L) /= 0) THEN
                         SCAT_MTRX(KAB-1, IPSI(L)) = SCAT_MTRX(KAB-1, IPSI(L)) + APSI(L)
                         SCAT_MTRX(KAB,   IPSI(L)) = SCAT_MTRX(KAB,   IPSI(L)) + BPSI(L)
                      END IF
                   END DO
                   IF ((JB == KB) .AND. (JA == KA) ) THEN   ! add in identity matrix
                      DO L = 1,4
                         IF (IPHI(L) <= NCELL2(JP) ) THEN
                            SCAT_MTRX(KAB-1,IPHI(L)) = SCAT_MTRX(KAB-1,IPHI(L)) + CMPLX (AD(L), 0.) * KSQN
                            SCAT_MTRX(KAB,  IPHI(L)) = SCAT_MTRX(KAB,  IPHI(L)) + CMPLX (BD(L), 0.) * KSQN
                         END IF
                         IF ( IDX(L) /= 0 ) THEN
                            SCAT_MTRX(KAB-1,IPSI(L)) = SCAT_MTRX(KAB-1,IPSI(L)) + CMPLX (BD(L), 0.)
                            SCAT_MTRX(KAB,  IPSI(L)) = SCAT_MTRX(KAB,  IPSI(L)) - CMPLX (AD(L), 0.)
                         END IF
                      END DO
                   END IF
                END DO LOOP_KB_NBL
             END DO LOOP_KA_NAL
          END DO LOOP_JA_NAL
       END DO LOOP_JB_NBL
       DEALLOCATE (SAA,SBA,SBB,VAA,VAB,VBA,VBB,XCEL1,YCEL1,ZCEL1)

    END DO PLATE_LOOP

    ! Set up the plate-plate interactions; ie. the off diagonal part of the
    ! scattering matrix.

    MULTI_SHT: IF (NPLT > 1) THEN
       ALLOCATE (VAAI(MXAB,MXAB),VABI(MXAB,MXAB),VBAI(MXAB,MXAB),VBBI(MXAB,MXAB), &
            SAAI(MXAB,MXAB),SABI(MXAB,MXAB),SBAI(MXAB,MXAB),SBBI(MXAB,MXAB))

       VAAI=ZERO; VABI=ZERO; VBAI=ZERO; VBBI=ZERO; SAAI=ZERO; SABI=ZERO; SBAI=ZERO; SBBI=ZERO

       TX_SHT: DO JPS = 1, NPLT-1
          RX_SHT: DO JPR = JPS+1, NPLT

             IF (JPS == NLYR .AND. JPR == NLYR) THEN

                CALL INTER_EGT_BOSS (JPS,JPR,MXAB,NPLT,NA,NB,DPTHB,KSQN,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL, &
                     NZ2,ZV2,NREGT,RHOTRP,GR1Z,GI1Z,GR2Z,GI2Z,GR3Z,GI3Z,GR4Z,GI4Z,GR5Z,GI5Z, &
                     GR6Z,GI6Z,VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI)
             ELSE
                CALL INTER_EGT_BOSS_UL (JPS,JPR,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NPLT,PLYR,MXAB,  &
                     NA,NB,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL,NREGT,RHOTRP, &
                     VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI)
             END IF

             ! Set up matrix for dipoles on plate JPS producing fields on plate JPR.
             ! Then use symmetry to set the adjoint block.

             JSXRX_L: DO JSXRX = 1,2
                IF (JSXRX ==1) THEN
                   JRX = JPR
                   JSX = JPS
                ELSE
                   JRX = JPS
                   JSX = JPR
                END IF
                MCELL2 = NCELL2(JRX-1)
                NBL = NB(JRX)
                NAL = NA(JRX)
                GA = .5 / DA(JRX)
                GB = .5 / DB(JRX)
                AREA = DA(JSX) * DB(JSX)

                JB_L: DO JB = 1,NBL      ! Step over rows and columns of receiver plate
                   JA_L: DO JA = 1,NAL
                      IDX = 1                                      !   1  2
                      IF ( JB==1 .OR. JA==1 )     IDX(1) = 0       !   3  4
                      IF ( JB==1 .OR. JA==NAL )   IDX(2) = 0       !         IDX is a stencil used
                      IF ( JB==NBL .OR. JA==1 )   IDX(3) = 0       ! to set PSI values to zero on
                      IF ( JB==NBL .OR. JA==NAL ) IDX(4) = 0       ! all edge nodes of plate

                      IPSI(1) = MCELL2 + (JB - 2) * (NAL - 1) + JA - 1
                      IPSI(2) = IPSI(1) + 1
                      IPSI(3) = IPSI(1) + NAL - 1
                      IPSI(4) = IPSI(3) + 1
                      IPHI(1) = MCELL2 + (NAL - 1) * (NBL - 1) + (JB - 1) * (NAL + 1) + JA
                      IPHI(2) = IPHI(1) + 1
                      IPHI(3) = IPHI(2) + NAL
                      IPHI(4) = IPHI(3) + 1

                      ! Sum Green's tensor "source" contributions.  KB and KA are the
                      ! row and column indices of the "source" cells

                      JAB = JA + (JB-1) * NAL          !  "receiver" cell index
                      KAB_L: DO KAB = 1, NA(JSX) * NB(JSX)    !  "source" cell index
                         KABG = NCELL2(JSX-1) + 2* KAB
                         IF (JSXRX == 1) THEN
                            AAS  = SAAI(JAB,KAB) * AREA(KAB,JSX)
                            ABSS = SABI(JAB,KAB) * AREA(KAB,JSX)
                            BAS  = SBAI(JAB,KAB) * AREA(KAB,JSX)
                            BBS  = SBBI(JAB,KAB) * AREA(KAB,JSX)
                            AAV  = VAAI(JAB,KAB) * AREA(KAB,JSX)
                            ABV  = VABI(JAB,KAB) * AREA(KAB,JSX)
                            BAV  = VBAI(JAB,KAB) * AREA(KAB,JSX)
                            BBV  = VBBI(JAB,KAB) * AREA(KAB,JSX)
                         ELSE
                            AAS  = SAAI(KAB,JAB) * AREA(KAB,JSX)
                            ABSS = SBAI(KAB,JAB) * AREA(KAB,JSX)
                            BAS  = SABI(KAB,JAB) * AREA(KAB,JSX)
                            BBS  = SBBI(KAB,JAB) * AREA(KAB,JSX)
                            AAV  = VAAI(KAB,JAB) * AREA(KAB,JSX)
                            ABV  = VBAI(KAB,JAB) * AREA(KAB,JSX)
                            BAV  = VABI(KAB,JAB) * AREA(KAB,JSX)
                            BBV  = VBBI(KAB,JAB) * AREA(KAB,JSX)
                         END IF

                         APSI(1) = KSQT(JRX) * (- GB*AAS + GA*ABSS)   ! cell corner PSI contribution
                         APSI(2) = KSQT(JRX) * (- GB*AAS - GA*ABSS)   ! to along strike field
                         APSI(3) = -APSI(2)
                         APSI(4) = -APSI(1)
                         BPSI(1) = KSQT(JRX) * (-GB*BAS + GA*BBS)    ! cell corner PSI contribution
                         BPSI(2) = KSQT(JRX) * (-GB*BAS - GA*BBS)    ! to down dip field
                         BPSI(3) = -BPSI(2)
                         BPSI(4) = -BPSI(1)
                         APHI(1) = KSQT(JRX) * (-GA*AAV - GB*ABV)    ! cell corner PHI contribution
                         APHI(2) = KSQT(JRX) * (+GA*AAV - GB*ABV)    ! to along strike field
                         APHI(3) = -APHI(2)
                         APHI(4) = -APHI(1)
                         BPHI(1) = KSQT(JRX) * (-GA*BAV - GB*BBV)    ! cell corner PHI contribution
                         BPHI(2) = KSQT(JRX) * (+GA*BAV - GB*BBV)    ! to down dip field
                         BPHI(3) = -BPHI(2)
                         BPHI(4) = -BPHI(1)

                         DO L = 1,4
                            IF (IPHI(L) <= NCELL2(JRX) ) THEN
                               SCAT_MTRX(KABG-1, IPHI(L)) = SCAT_MTRX(KABG-1, IPHI(L)) + APHI(L)
                               SCAT_MTRX(KABG,   IPHI(L)) = SCAT_MTRX(KABG,   IPHI(L)) + BPHI(L)
                            END IF
                            IF (IDX(L) /= 0) THEN
                               SCAT_MTRX(KABG-1, IPSI(L)) = SCAT_MTRX(KABG-1, IPSI(L)) + APSI(L)
                               SCAT_MTRX(KABG,   IPSI(L)) = SCAT_MTRX(KABG,   IPSI(L)) + BPSI(L)
                            END IF
                         END DO

                      END DO KAB_L
                   END DO JA_L
                END DO JB_L
             END DO JSXRX_L
          END DO RX_SHT
       END DO TX_SHT
       DEALLOCATE (VAAI,VABI,VBAI,VBBI,SAAI,SABI,SBAI,SBBI)
    END IF MULTI_SHT

    ! Do LU decomposition and then compute scattering currents, J_SCAT
    ! for all transmitter positions

    CALL SCAT_MTRX_LU_DCMP (MXCL2,SCAT_MTRX,INDX,DCMP_FAIL)

    MXA = MAXVAL (NA);  MXB = MAXVAL (NB)
    CALL SCAT_CRNT (NPLT,NTX,MXAB,NCELL2,MXCL2,MXA,MXB,NA,NB,DA,DB, &
         KSQN,SIGT,INDX,SCAT_MTRX,E_PRYM,J_SCAT)

  END SUBROUTINE SCAT_MTRX_BOSS

  SUBROUTINE SCAT_MTRX_LU_DCMP (MXCL2,SCAT_MTRX,INDX,DCMP_FAIL)
    !-------------------------------------------------------------

    !***  Called by: SCAT_MTRX_BOSS

    !  LU decomposition of a complex matrix SCAT_MTRX.  On exit, SCAT_MTRX is
    !  overwritten by its LU decomposition,  The 1's on the diagonal are assumed by
    !  the solution SUBROUTINE SCAT_CRNT.  MXCL2 is the dimension of the
    !  matrix, SCAT_MTRX.  SCAT_MTRX_LU_DCMP uses partial pivoting to
    !  improve the conditioning.  The pivoting information is stored in INDX.

    IMPLICIT NONE
    INTEGER MXCL2,INDX(MXCL2),ILL,I,J,IDXPIV,KP,K
    REAL SCALE(MXCL2),ROWNRM,BIG,SIZE
    COMPLEX SCAT_MTRX(MXCL2,MXCL2),EM
    LOGICAL DCMP_FAIL

    INTENT (IN) MXCL2
    INTENT (OUT) INDX
    INTENT (INOUT) SCAT_MTRX

    ! Initialisation of INDX and SCALE

    DCMP_FAIL = .FALSE.
    ILL = 0
    DO I = 1,MXCL2
       INDX(I) = I
       ROWNRM = 0.
       DO J = 1,MXCL2
          IF (ROWNRM < ABS (SCAT_MTRX(I,J)) ) ROWNRM = ABS (SCAT_MTRX(I,J))
       END DO
       IF (ROWNRM > 0.) THEN
          SCALE(I) = 1. / ROWNRM
       ELSE
          ILL = 1
          SCALE(I) = 0.
       END IF
    END DO

    ! Gauss elimination with partial pivoting

    LOOP_K_MXCL2: DO K = 1, MXCL2 - 1
       BIG = 0.
       DO I = K,MXCL2
          SIZE = ABS (SCAT_MTRX(INDX(I),K)) * SCALE(INDX(I))
          IF (SIZE > BIG) THEN
             BIG = SIZE
             IDXPIV = I
          END IF
       END DO
       IF (ABS (BIG) > 0.) THEN
          IF (IDXPIV /= K) THEN
             J = INDX(K)
             INDX(K) = INDX(IDXPIV)
             INDX(IDXPIV) = J
          END IF
          KP = INDX(K)
          DO I = K + 1,MXCL2
             EM = -SCAT_MTRX(INDX(I),K) / SCAT_MTRX(KP,K)
             SCAT_MTRX(INDX(I),K) = -EM
             DO J = K + 1,MXCL2
                SCAT_MTRX(INDX(I),J) = SCAT_MTRX(INDX(I),J) + EM*SCAT_MTRX(KP,J)
             END DO
          END DO
       ELSE
          ILL = 2
       END IF
    END DO LOOP_K_MXCL2

    IF (ABS ( SCAT_MTRX(INDX(MXCL2),MXCL2) ) < 1.E-34) ILL = 2
    IF (ILL /= 0) DCMP_FAIL = .TRUE.

  END SUBROUTINE SCAT_MTRX_LU_DCMP

  SUBROUTINE SCAT_CRNT (NPLT,NTX,MXAB,NCELL2,MXCL2,MXA,MXB,NA,NB,DA,DB, &
       KSQN,SIGT,INDX,SCAT_MTRX,E_PRYM,J_SCAT)
    !------------------------------------------------------------------------
    !
    !  Computes the scattering currents, J_SCAT for all
    !  transmitter positions, by applying the LU decomposed matrix SCAT_MTRX
    !  to the incident layered earth primary electric fields, E_PRYM.

    !***  Called by SCAT_MTRX_BOSS

    !  For E := either E_PRYM or J_SCAT -

    !  E (1,JCELL,JS,JP) is the field (current) in the strike direction in the
    !                       centre of plate cell number JCELL of plate JP due
    !                       to transmitter JS
    !  E (2,JCELL,JS,JP) is the field (current) in the down-dip direction in the
    !                       centre of plate cell number JCELL of plate JP due
    !                       to transmitter JS
    !
    !        NPLT - number of plates
    !         NTX - number of transmitter positions on profile line.
    !         MXA - number of cells along strike of longest plate
    !         MXB - maximum number of cells down dip of widest plate
    !        MXAB - the number of cells in the biggest plate (not necessarily MXA * MXB)
    !   NCELL2(J) - 2 * the number of cells in plates 1 to J
    !       MXCL2 - 2 * total number of cells for all plates
    !     NA & NB - number of cells along strike and down dip for plate
    !     DA & DB - cell dimensions along strike and down dip respectively
    !     SIGT(J) - complex conductivity thickness product of plate J
    !     KSQT(J) - iwu * SIGT
    !        INDX - pivoting vector information from SCAT_MTRX_LU_DCMP

    IMPLICIT NONE
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER JP,NPLT,JS,NTX,JA,JB,JAB,J,J1,J2,MXAB,MXA,MXB,NAL,NA(NPLT), &
         NBL,NB(NPLT),IBACK,I,MXCL2,INDX(MXCL2),NCELL2(0:NPLT),MCELL2
    REAL GA,GB,DA(NPLT),DB(NPLT)
    COMPLEX SCAT_MTRX(MXCL2,MXCL2),E_PRYM(2,MXAB,NTX,NPLT),J_SCAT(2,MXAB,NTX,NPLT), &
         X(MXCL2),B(MXCL2),PHI(MXB+1,MXA+1),PSI(MXB+1,MXA+1),KSQN, &
         SIGT(NPLT),ES_TMP,SUM

    INTENT (IN) NPLT,NTX,MXAB,NCELL2,MXCL2,MXA,MXB,NA,NB,DA,DB,KSQN, &
         SIGT,INDX,SCAT_MTRX,E_PRYM
    INTENT (OUT) J_SCAT

    TX_LOOP: DO JS = 1,NTX
       DO JP = 1,NPLT
          MCELL2 = NCELL2(JP-1)
          DO JAB = 1, NA(JP) * NB(JP)
             B(MCELL2 + 2*JAB -1) = E_PRYM(1,JAB,JS,JP)
             B(MCELL2 + 2*JAB) =    E_PRYM(2,JAB,JS,JP)
          END DO
       END DO

       X(1) = B(INDX(1))
       DO J1 = 2,MXCL2
          SUM = ZERO
          DO J2 = 1, J1-1
             SUM = SUM + SCAT_MTRX(INDX(J1),J2)*X(J2)
          END DO
          X(J1) = B(INDX(J1)) - SUM
       END DO

       X(MXCL2) = X(MXCL2)/SCAT_MTRX(INDX(MXCL2),MXCL2)
       DO IBACK = 2,MXCL2
          I = MXCL2 + 1 - IBACK
          SUM = ZERO
          DO J = I + 1,MXCL2
             SUM = SUM + SCAT_MTRX(INDX(I),J)*X(J)
          END DO
          X(I) = (X(I) - SUM)/SCAT_MTRX(INDX(I),I)
       END DO

       PLATE_LOOP: DO JP = 1,NPLT
          GA = .5 / DA(JP)
          GB = .5 / DB(JP)
          NAL = NA(JP)
          NBL = NB(JP)
          MCELL2 = NCELL2(JP-1)

          PSI = ZERO
          PHI = ZERO

          DO JB = 2,NBL
             DO JA = 2,NAL
                JAB = (JB-2)* (NAL-1) + JA - 1
                PSI(JB,JA) = X(MCELL2 + JAB)
             END DO
          END DO

          DO JB = 1, NBL+1
             DO JA = 1, NAL+1
                JAB = (JB-1) * (NAL+1) + JA + (NAL-1) * (NBL-1)
                IF (JAB <= (2*NAL*NBL) ) PHI(JB,JA) = X(MCELL2 + JAB)
             END DO
          END DO

          PHI(NBL+1,NAL) = ZERO
          PHI(NBL+1,NAL + 1) = ZERO
          DO JB = 1,NBL
             DO JA = 1,NAL
                JAB = (JB - 1)*NAL + JA
                ES_TMP = KSQN * (PHI(JB,JA+1) + PHI(JB+1,JA+1) - PHI(JB,JA) - PHI(JB+1,JA)) *GA &
                     + (PSI(JB+1,JA) + PSI(JB+1,JA+1) - PSI(JB,JA) - PSI(JB,JA+1)) *GB

                J_SCAT(1,JAB,JS,JP) = SIGT(JP) * ES_TMP

                ES_TMP = KSQN * (PHI(JB+1,JA) + PHI(JB+1,JA+1) - PHI(JB,JA) - PHI(JB,JA+1)) *GB &
                     - (PSI(JB,JA+1) + PSI(JB+1,JA+1) - PSI(JB,JA) - PSI(JB+1,JA)) *GA
                J_SCAT(2,JAB,JS,JP) = SIGT(JP) * ES_TMP
             END DO
          END DO
       END DO PLATE_LOOP

    END DO TX_LOOP

  END SUBROUTINE SCAT_CRNT

  SUBROUTINE SCAT_EM (JF,NFRQ,NPLT,PLYR,NTPL,IDPL,MXAB,MXB,NA,NB,DA,DB,PLAZM,PLDIP,PLUNJ,XCELL,  &
       YCELL,ZCELL,NMGP,XMG,YMG,ZMG,WMG,NLYR,THKD,DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX, &
       NRXTX,RXID,MXRS,NRS,XRS,YRS,ZRXTX,WTRS,EDCS,EDSN,NRMGT,RHOTRP,NZ1,ZV1,NZ3, &
       ZC3,MDRX,EDRX,J_SCAT,BFD_SCAT,QUIT)
    !---------------------------------------------------------------------------------------------
    !
    !***  Called by LEROI_3D
    !***  Calls MGT_BOSS, EGTRX_BOSS
    !
    !  Computes BFD_SCAT(JF,JR,JS.JC), the scattered electric and magnetic fields
    !  for frequency JF at receiver, JR of transmitter JS.
    !
    !  For magnetic dipole receivers, BFD_SCAT is B in Teslas for North, East &
    !  Vertical components corresponding to JC = 1,2,3
    !
    !  For closed loop receivers, BFD_SCAT(JC=1) is B the vertical magnetic field in Teslas
    !         BFD_SCAT(JC=2,3) is set to zero
    !
    !  For electric dipole receivers, BFD_SCAT(JC=1) is volts,; ie the E field
    !  integrated along receiver dipole
    !         BFD_SCAT(JC=2,3) is set to zero
    !
    !
    !        Input variables
    !        ---------------
    !
    !          JF - index of NFRQ frequencies
    !        NPLT - Number of plates
    !        NTPL - Number of plates above basement
    !        IDPL - Indices for plates above basement
    !        PLYR - layer containing plate
    !        MXAB - Number of cells in biggest plate
    !      NA, NB - number of cells along strike and down dip respectively
    !       PLAZM - strike angles for each plate
    !       PLDIP - dip anglefor each plate
    !       PLUNJ - plunge angles
    !        NLYR - number of layers including overburden.
    !       DPTHB - depth to basement (= 0 if NLYR = 1)
    !        RMUD - double precision relative magetic permeability
    !        SIGL - double precision complex xconductivity for all layers including Cole-Cole & dielectric
    !        KSQL - double precision iwu * SIGL for all layers (includes Cole-Cole)
    !         NTX - number of transmitters
    !       NRXTX - number of receivers per transmitter (max = MRXTX)
    !        RXID - identifies type of receiver: 1 = mag dipole;  2 = electric dipole
    !         NRS - number of subnet receivers per receiver (max = MXRS)
    !    XRS, YRS - North, East coordinates of receiver subnet
    !        WTRS - subnet receiver weights
    !  EDCS, EDSN - cosine & sine of angle from north made by grounded wire receiver
    !         MAG - magnetic field computation required if true
    !     SURFACE - magnetic field computation required on surface if true
    !       NRMGT - Dimension for MGT interpolations
    !      RHOTRP - horizontal interpolation array for MGT & EGTRX
    !    ZV1(NZ1) - vertical interpolatin array for basement
    !       NCPTS - number of integration points per dimension per cell.
    !       NRMGT - Dimension for receiver Green's FUNCTION interpolations

    IMPLICIT NONE
    INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80)
    COMPLEX, PARAMETER :: ZERO=(0.,0.)
    INTEGER JF,NFRQ,JP,NPLT,NTPL,SXLYR,MXAB,MXB,NAL,NBL,NLYR,NTX,MRXTX,NRXTX(NTX), &
         RXID(MRXTX,NTX),MXRS,NRS(MRXTX,NTX),NRMGT,NZ1,NZ3,NZ3L,NMGP,J1,JS,JR,JC,JCL
    INTEGER, DIMENSION (NPLT) :: NA,NB,IDPL,PLYR
    REAL RHOTRP(NRMGT),ZV1(NZ1),DAL,DBL,EDCS(MRXTX,NTX),EDSN(MRXTX,NTX),SCRATCH(MRXTX,NTX,3), &
         WTRS(MXRS,MRXTX,NTX),ZRXTX(MRXTX,NTX),ZC3(3*MXB,NTPL),ZC3L(3*MXB)
    REAL(KIND=QL) RMUD(0:NLYR),THKD(NLYR),DPTHL(NLYR)
    REAL, DIMENSION (NPLT) :: DA,DB,PLAZM,PLDIP,PLUNJ,WMG
    REAL, DIMENSION (MXAB,NPLT) :: XCELL,YCELL,ZCELL
    REAL, DIMENSION (MXRS,MRXTX,NTX) :: XRS,YRS
    REAL, DIMENSION (NMGP,NPLT) :: XMG,YMG,ZMG
    COMPLEX(KIND=QL), DIMENSION(NLYR) :: SIGL,KSQL
    COMPLEX HA(MXAB,3,MRXTX,NTX,NPLT),HB(MXAB,3,MRXTX,NTX,NPLT),J_SCAT(2,MXAB,NTX,NPLT),TMP(3), &
         BFD_SCAT(NFRQ,MRXTX,NTX,3)
    LOGICAL EDRX,MDRX,QUIT

    !  Compute the magnetic Green's tensor integrals for each plate and combine
    !  them with the scattering currents and sum.

    HA = ZERO;  HB = ZERO


    IF (MAXVAL (PLYR) == NLYR) THEN    ! basement plates


       IF (MDRX) CALL MGT_BOSS (NPLT,PLYR,MXAB,NA,NB,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL,NLYR,THKD, &
            DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS,ZRXTX,   &
            WTRS,NRMGT,RHOTRP,NZ1,ZV1,NMGP,XMG,YMG,ZMG,WMG,HA,HB)



       IF (EDRX) CALL EGTRX_BOSS (NPLT,PLYR,MXAB,NA,NB,PLAZM,PLDIP,PLUNJ,XCELL,YCELL,ZCELL,NLYR,THKD, &
            DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS,ZRXTX,   &
            WTRS,NRMGT,RHOTRP,NZ1,ZV1,NMGP,XMG,YMG,ZMG,WMG,HA,HB)
    END IF


    DO J1 = 1, NTPL          ! plates above basement
       JP = IDPL(J1)
       NAL = NA(JP)
       NBL = NB(JP)
       DAL = DA(JP)
       DBL = DB(JP)
       SXLYR = PLYR(JP)
       NZ3L = 3*NBL
       ZC3L(1:NZ3) = ZC3(1:NZ3,JP)

       IF (MDRX) &
            CALL MGT_BOSS_UL (JP,SXLYR,NPLT,MXAB,NAL,NBL,DAL,DBL,PLAZM,PLDIP,XCELL,YCELL,NLYR, &
            THKD,DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS, &
            ZRXTX,WTRS,NRMGT,RHOTRP,NZ3L,ZC3L,HA,HB)

       IF (EDRX) &
            CALL EGTRX_BOSS_UL (JP,SXLYR,NPLT,MXAB,NAL,NBL,DAL,DBL,PLAZM,PLDIP,XCELL,YCELL,NLYR, &
            THKD,DPTHL,RMUD,SIGL,KSQL,NTX,MRXTX,NRXTX,RXID,MXRS,NRS,XRS,YRS, &
            ZRXTX,WTRS,NRMGT,RHOTRP,NZ3L,ZC3L,HA,HB)
    END DO

    PLATE_LOOP: DO JP = 1,NPLT

       TX_LOOP: DO JS = 1,NTX

          !  Multiply the magnetic Green's tensor elements times the strike and
          !  downdip currents.  J1 = 1,2,3 represents the along strike, horizontal
          !  cross strike and vertical components respectively.  This has to be rotated
          !  so that J1 = 1,2,3 represent the East, North, and vertical component
          !  respectively. Strike angle is defined as positive, clockwise from North.
          !  Strike angle = dip azimuth - pi/2

          RX_LOOP: DO JR = 1,NRXTX(JS)
             TMP = ZERO
             DO JC = 1,3
                DO JCL = 1, NA(JP) * NB(JP)
                   TMP(JC) = TMP(JC) + J_SCAT(1,JCL,JS,JP) * HA(JCL,JC,JR,JS,JP) &
                        + J_SCAT(2,JCL,JS,JP) * HB(JCL,JC,JR,JS,JP)
                END DO
             END DO

             IF (RXID(JR,JS) == 2) THEN
                TMP(1) = TMP(1) * EDCS(JR,JS) + TMP(2) * EDSN(JR,JS)
                TMP(2:3) = ZERO
             END IF
             BFD_SCAT(JF,JR,JS,1:3) = BFD_SCAT(JF,JR,JS,1:3) + TMP(1:3)
          END DO RX_LOOP
       END DO TX_LOOP
    END DO PLATE_LOOP

    ! For coincident loop receivers, put the response into component 1

    DO JS = 1,NTX
       DO JR = 1,NRXTX(JS)
          SCRATCH(JR,JS,1:3) = ABS (BFD_SCAT(JF,JR,JS,1:3))
          IF (RXID(JR,JS) == 4) THEN
             BFD_SCAT(JF,JR,JS,1) = BFD_SCAT(JF,JR,JS,3)
             BFD_SCAT(JF,JR,JS,2:3) = ZERO
          END IF
       END DO
    END DO
    IF (MAXVAL (SCRATCH) < 1.E-30) QUIT = .TRUE.

  END SUBROUTINE SCAT_EM

  SUBROUTINE SET_MAX_INTRP (MXRHO,RHOTRP,MXAB,NPLT,NA,NB,DA,PLNGTH,XCELL,YCELL,NTX,MXVRTX, &
       NVRTX,SXN,SXE,MRXTX,NRXTX,MXRS,NRS,XRS,YRS,NRMGT,NRPRM,NREGT)
    !---------------------------------------------------------------------------------------------

    ! Sets the size for the horizontal interpolation arrays in PRM_BOSS, EGT_BOSS and MGT_BOSS

    !*** Called by LEROI_3D

    !                 INPUT
    !                 -----
    !
    !        RHOTRP - horizontal interpolation array of MXRHO points (15 points / decade)
    !          MXAB - maximum number of cells per plate
    !          NPLT - number of plates
    !        NA, NB - the number of cells along strike and down dip respectively for each plate
    !        DA, DB - cell dimensions along strike and down dip respectively for each plate
    !        PLNGTH - array of plate strike lengths
    !    XCELL(k,n) - X (north) coordinate of centre of cell k of plate n.
    !    YCELL(k,n) - Y (east) coordinate of centre of cell k of plate n.
    !           NTX - number of stations
    !        MXVRTX - maximum number of vertices for any transmitter
    !         NVRTX - number of vertices for any transmitter
    !         MRXTX - maximum number of receivers per transmitter
    !      SXN, SXE - arrays of transmitter (North, East) coordinates
    !         MRXTX - number of receivers for each transmitter position
    !         NRXTX - number of receivers for each transmitter
    !     MXRS, NRS - maximum and actual number of subnet receivers per receiver
    !           NRS - number of subnet receivers per receiver (max = MXRS)
    !      XRS, YRS - (North, East) coordinates of receiver subnet

    !      OUTPUT
    !      ------
    !
    !    NREGT - maximum dimension of RHOTRP for electric Green's FUNCTION s
    !    NRMGT - maximum dimension of RHOTRP for magnetic Green's FUNCTION s
    !    NRPRM - maximum dimension of RHOTRP for primary field at targets

    INTEGER MXRHO,MXAB,JP,NPLT,NAB2,NA(NPLT),NB(NPLT),NAB,NTX,MRXTX,MXVRTX,NVRTX(NTX),NRXTX(NTX), &
         MXRS,NRS(MRXTX,NTX),JS,JR,JAB,JP2,JAB2,JV,J1,NRMGT,NRPRM,NREGT
    REAL RHOTRP(MXRHO),PRMX,EGTMX,EGTSQ,MGTMX,R1,XCELL(MXAB,NPLT),YCELL(MXAB,NPLT), &
         PLNGTH(NPLT),DA(NPLT),SXN(MXVRTX,NTX),SXE(MXVRTX,NTX),BIGRHO,CELLRAD
    REAL, DIMENSION (MXRS,MRXTX,NTX) :: XRS,YRS


    PRMX = 0.                ! initialise maximum source - cell separation
    EGTMX = MAXVAL (PLNGTH)  ! initialise maximum inter-plate cell separation
    EGTSQ = EGTMX**2
    MGTMX = EGTSQ
    CELLRAD = 0.75 * MAXVAL(DA)

    DO JP = 1, NPLT      !  Sum over plates
       NAB = NA(JP) * NB(JP)
       DO JAB = 1, NAB
          DO JS = 1,NTX
             DO JV = 1,NVRTX(JS)
                R1 = SQRT( (SXN(JV,JS) - XCELL(JAB,JP))**2 + (SXE(JV,JS) - YCELL(JAB,JP))**2)
                PRMX = MAX (R1, PRMX)
             END DO

             DO JR = 1, NRXTX(JS)
                DO J1 = 1, NRS(JR,JS)
                   R1 = (XRS(J1,JR,JS) - XCELL(JAB,JP))**2 + (YRS(J1,JR,JS) - YCELL(JAB,JP))**2
                   MGTMX = MAX (R1, MGTMX)
                END DO
             END DO
          END DO

          IF ( NPLT > 1 .AND. JP < NPLT ) THEN
             DO JP2 = JP+1,NPLT
                NAB2 = NA(JP2) * NB(JP2)
                DO JAB2 = 1, NAB2
                   R1 = (XCELL(JAB,JP) - XCELL(JAB2,JP2))**2 + &
                        (YCELL(JAB,JP) - YCELL(JAB2,JP2))**2
                   EGTSQ = MAX (R1, EGTSQ)
                END DO
             END DO
          END IF
       END DO
    END DO
    MGTMX = SQRT (MGTMX) + CELLRAD
    EGTMX = SQRT (EGTSQ) + CELLRAD
    BIGRHO = MAX (PRMX,MGTMX,EGTMX)

    NRPRM = 1;  NRMGT = 1; NREGT = 1
    DO JR = 2, MXRHO
       IF (RHOTRP(JR) < MGTMX) NRMGT = JR + 1
       IF (RHOTRP(JR) < PRMX)  NRPRM = JR + 1
       IF (RHOTRP(JR) < EGTMX) NREGT = JR + 1
       IF (RHOTRP(JR) > BIGRHO) EXIT
    END DO

  END SUBROUTINE SET_MAX_INTRP

  SUBROUTINE SET_MGT (NPLT,NX,NMGP,DA,DB,PLAZM,PLDIP,PLUNJ,XMG,YMG,ZMG,WMG)
    !------------------------------------------------------------------------

    !  Sets up a 9 point / cell stencil, relative to the cell centre for integrating
    !  the magnetic Green's tensor elements.  For each plate, the 9 points are
    !  allocated to a flat cell and then rotated into the plane of the plate.  The
    !  integration coordicates are obtained by adding the these to the cell centres.
    !
    !***  Called by LEROI_3D
    !
    !           NPLT - number of plates
    !             NX - Number of points per dimension per cell for MGT integration
    !           NMGP - Number of points per cell for MGT integration = NX^2
    !         DA, DB -  cell dimensions along strike and down dip
    !          PLAZM - strike angles
    !          PLDIP - dip angle
    !          PLUNJ - plunge angles
    !      MXRS, NRS - maximum and actual number of subnet receivers per receiver
    !
    !                  OUTPUT
    !                  ------
    !            WMG - total integration weight for each point for plate JP
    !  XMG, YMG, ZMG - coordinates for integration down dip for each plate

    INTEGER NPLT,NX,NMGP,JP,JA,JB,JAB
    REAL X0,Y0,XS,X2(NMGP),Y2(NMGP),R32(3,2),CA,SA,CD,SD,CP,SP,DELX,DELY
    REAL, DIMENSION (NMGP,NPLT) :: XMG,YMG,ZMG
    REAL, DIMENSION(NPLT) :: WMG,DA,DB,PLAZM,PLDIP,PLUNJ

    XMG = 0.;  YMG = 0.;  ZMG = 0.; WMG = 0.

    ! Start with 9 point uniform rule on a flat cell

    DO JP = 1,NPLT
       IF (DB(JP) < 0.01) CYCLE
       CA = COS (PLAZM(JP))
       SA = SIN (PLAZM(JP))
       CD = COS (PLDIP(JP))
       SD = SIN (PLDIP(JP))
       CP = COS (PLUNJ(JP))
       SP = SIN (PLUNJ(JP))
       WMG(JP) = DA(JP) * DB(JP) / REAL (NMGP)
       CALL RPLT2XYZ (CA,SA,CD,SD,CP,SP,R32)

       DELX = DA(JP) / REAL(NX)
       DELY = DB(JP) / REAL(NX)
       X0 = -(DA(JP) + DELX) / 2.
       Y0 = -(DB(JP) + DELY) / 2.

       DO JA = 1,NX
          XS = X0 + JA * DELX
          DO JB = 1,NX
             JAB = JA + (JB-1) * NX
             X2(JAB) = XS
             Y2(JAB) = Y0 + JB * DELY
             XMG(JAB,JP) = R32(1,1) * X2(JAB) + R32(1,2) * Y2(JAB)
             YMG(JAB,JP) = R32(2,1) * X2(JAB) + R32(2,2) * Y2(JAB)
             ZMG(JAB,JP) = R32(3,1) * X2(JAB) + R32(3,2) * Y2(JAB)
          END DO
       END DO
    END DO
  END SUBROUTINE SET_MGT

  SUBROUTINE SET_RX_SUBNET (NTX,MRXTX,NRXTX,MXRS,NRS,MQVR,RXID,XRXTX,YRXTX,XRS,YRS,WTRS,EDCS,EDSN)
    !-----------------------------------------------------------------------------------------------

    ! Sets up virtual receivers for magnetic dipole, grounded wire and loop receivers.
    ! All receivers except magnetic dipoles must lie on the surface in this version.

    !*** Called by LEROI_3D

    ! INPUT PARAMETERS:
    ! ----------------
    !
    !           NTX - number of transmitters
    !         MRXTX - maximum number of receivers per transmitter
    !         NRXTX - number of receivers for each transmitter
    !           NRS - number of sub-net receivers per receiver
    !          MXRS = maximum value NRS
    !          MQVR = maximum number of vertices for all receivers (2 or 1)
    !          RXID - reciver type: 1 = mag dipole;  2 = grounded dipole
    !  XRXTX, YRXTX - north and east coordinates of receiver vertices
    !
    !  OUTPUT PARAMETERS:
    !  -----------------
    !
    !      XRS, YRS - north and east coordinates of receiver subnet
    !          WTRS - weights of receiver subnet
    !     EDCS,EDSN - cosine & sine of angle from north made by grounded wire receiver

    IMPLICIT NONE
    INTEGER NTX,MRXTX,MXRS,NRXTX(NTX),NRS(MRXTX,NTX),MQVR,RXID(MRXTX,NTX),JS,JR
    REAL DELX,DELY,DELR,DELR12
    REAL, DIMENSION (MRXTX,NTX) :: EDCS,EDSN
    REAL, DIMENSION (MRXTX,NTX,MQVR) :: XRXTX,YRXTX
    REAL, DIMENSION (MXRS,MRXTX,NTX) :: XRS,YRS,WTRS

    DO JS = 1,NTX
       DO JR = 1, NRXTX(JS)
          IF (RXID(JR,JS) == 2) THEN   !  electric dipole receiver
             NRS(JR,JS) = 5
             XRS(1,JR,JS) = XRXTX(JR,JS,1)
             YRS(1,JR,JS) = YRXTX(JR,JS,1)
             XRS(2,JR,JS) = XRXTX(JR,JS,2)
             YRS(2,JR,JS) = YRXTX(JR,JS,2)
             XRS(3,JR,JS) = 0.5 * (XRS(1,JR,JS) + XRS(2,JR,JS))
             YRS(3,JR,JS) = 0.5 * (YRS(1,JR,JS) + YRS(2,JR,JS))
             XRS(4,JR,JS) = 0.5 * (XRS(1,JR,JS) + XRS(3,JR,JS))
             YRS(4,JR,JS) = 0.5 * (YRS(1,JR,JS) + YRS(3,JR,JS))
             XRS(5,JR,JS) = 0.5 * (XRS(2,JR,JS) + XRS(3,JR,JS))
             YRS(5,JR,JS) = 0.5 * (YRS(2,JR,JS) + YRS(3,JR,JS))

             DELX = XRXTX(JR,JS,2) - XRXTX(JR,JS,1)
             DELY = YRXTX(JR,JS,2) - YRXTX(JR,JS,1)
             DELR = SQRT (DELX**2 + DELY**2)

             EDCS(JR,JS) = DELX / DELR
             EDSN(JR,JS) = DELY / DELR
             DELR12 =  DELR / 12.
             WTRS(1:2,JR,JS) = DELR12
             WTRS(3,JR,JS) = 2.* DELR12
             WTRS(4:5,JR,JS) = 4.* DELR12

          ELSE                              !  magnetic dipole or electric point receiver
             NRS(JR,JS) = 1
             XRS(1,JR,JS) = XRXTX(JR,JS,1)
             YRS(1,JR,JS) = YRXTX(JR,JS,1)
             WTRS(1,JR,JS) = 1.
          END IF
       END DO
    END DO

  END SUBROUTINE SET_RX_SUBNET

  SUBROUTINE SET_RX_SUBNET_CL (NTX,SXN,SXE,MXRS,NRS,XRS,YRS,WTRS)
    !---------------------------------------------------------------

    !*** Called by LEROI_3D
    !*** Calls SET_RX_SUBNET_QUAD

    ! Sets up virtual receivers for coincident loop sources.
    ! Four-sided loops are set up as a rectangular array using SET_RX_SUBNET_QUAD
    ! Uniform weights are used.


    ! INPUT PARAMETERS:
    ! ----------------
    !
    !              NTX - number of coincident loop transmitter positions
    !         SXN, SXE - north & east coordinates of loop vertices
    !            MXRS - maximum NRS
    !
    !  OUTPUT PARAMETERS:
    !  -----------------
    !        NRS(1,JS) - number of receivers for loop JS
    !      XRS(*,1,JS) - North coordinates of the NRS magnetic dipole points
    !      YRS(*,1,JS) - East coordinates of the NRS magnetic dipole points
    !
    !     WTRS(*,1,JS) - integration weights associated with magnetic dipole receiver net

    IMPLICIT NONE
    INTEGER, PARAMETER :: MXRS4=200
    INTEGER NTX,MXRS,NRS(1,NTX),NRS4,JS
    REAL SXN1(4),SXE1(4),WTRS1,XRS4(MXRS4),YRS4(MXRS4)
    REAL, DIMENSION (4,NTX) :: SXN,SXE
    REAL, DIMENSION (MXRS,1,NTX) :: XRS,YRS,WTRS

    DO JS = 1,NTX
       SXN1(1:4) = SXN(1:4,JS); SXE1(1:4) = SXE(1:4,JS)
       CALL SET_RX_SUBNET_QUAD (SXN1,SXE1,MXRS4,NRS4,XRS4,YRS4,WTRS1)
       NRS(1,JS) = NRS4; WTRS(1:NRS4,1,JS) = WTRS1
       XRS(1:NRS4,1,JS) = XRS4(1:NRS4); YRS(1:NRS4,1,JS) = YRS4(1:NRS4)
    END DO

  END SUBROUTINE SET_RX_SUBNET_CL

  SUBROUTINE SET_RX_SUBNET_QUAD (SXN1,SXE1,MXRS4,NRS4,XRS4,YRS4,WTRS4)
    !--------------------------------------------------------------------

    !  Sets up virtual receivers for four sided loops.  Initially based on 20 m intervals
    !  it sets a maximum of 10 dipoles in either direction

    !*** Called by SET_RX_SUBNET_CL
    !*** Calls DIST2D

    ! INPUT PARAMETERS:
    ! ----------------
    !
    !   SXN1, SXE1 - north & east coordinates of loop vertices
    !        MXRS4 - maximum number of receivers in rectangular subnet (100)
    !
    !  OUTPUT PARAMETERS:
    !  -----------------
    !
    !        NRS4 - number of receivers in rectangular subnet
    !        XRS4 - North coordinates of the NRS4 magnetic dipole points
    !        YRS4 - East coordinates of the NRS4 magnetic dipole points
    !       WTRS4 - integration weights associated with magnetic dipole receiver net

    IMPLICIT NONE
    INTEGER, PARAMETER :: MXD = 10  ! maximun number of equivalent dipoles per length
    INTEGER MXRS4,NRS4,J1,J2,ND(2),JR
    REAL SXN1(4),SXE1(4),XCNTR,YCNTR,TOTAL_AREA,AREA,A,B,C,S,SL(4),DELX,DELY, &
         X(MXD,2),Y(MXD,2),X0,Y0,SL_AVG,WTRS4,XRS4(MXRS4),YRS4(MXRS4)

    XCNTR = SUM (SXN1(1:4)) / 4.          ! Compute loop centre coordinates
    YCNTR = SUM (SXE1(1:4)) / 4.          ! Compute loop centre coordinates

    TOTAL_AREA = 0. ; X = 0.;  Y = 0
    DO J1 = 1, 4
       J2 = J1 + 1
       IF (J1 == 4) J2 = 1
       A = DIST2D (SXN1(J1),SXE1(J1), XCNTR, YCNTR )
       B = DIST2D (SXN1(J2),SXE1(J2), XCNTR, YCNTR)
       C = DIST2D (SXN1(J1),SXE1(J1), SXN1(J2),SXE1(J2) )
       SL(J1) = C
       S = (A + B + C) /2.
       AREA = SQRT (S* (S-A)* (S-B)* (S-C))     ! triangle area using Heron's formula
       TOTAL_AREA = TOTAL_AREA + AREA
    END DO

    DO J1 = 1,2
       SL_AVG = 0.5 * (SL(J1) + SL(J1+2))
       ND(J1) = NINT (SL_AVG / 20.)
       ND(J1) = MIN (ND(J1), MXD)
    END DO
    NRS4 = ND(1) * ND(2)
    WTRS4 = TOTAL_AREA / REAL (NRS4)

    DELX = (SXN1(2) - SXN1(1)) / REAL (ND(1))
    DELY = (SXE1(2) - SXE1(1)) / REAL (ND(1))
    X0 = SXN1(1) - 0.5*DELX
    Y0 = SXE1(1) - 0.5*DELY
    DO J1 = 1, ND(1)
       X(J1,1) = X0 + J1 * DELX
       Y(J1,1) = Y0 + J1 * DELY
    END DO

    DELX = (SXN1(3) - SXN1(4)) / REAL (ND(1))
    DELY = (SXE1(3) - SXE1(4)) / REAL (ND(1))
    X0 = SXN1(4) - 0.5*DELX
    Y0 = SXE1(4) - 0.5*DELY
    DO J1 = 1, ND(1)
       X(J1,2) = X0 + J1 * DELX
       Y(J1,2) = Y0 + J1 * DELY
    END DO

    JR = 0
    DO J1 = 1, ND(1)
       DELX = (X(J1,2) - X(J1,1)) / REAL (ND(2))
       DELY = (Y(J1,2) - Y(J1,1)) / REAL (ND(2))
       X0 = X(J1,1) - 0.5* DELX
       Y0 = Y(J1,1) - 0.5* DELY
       DO J2 = 1, ND(2)
          JR = JR + 1
          XRS4(JR) = X0 + J2 * DELX
          YRS4(JR) = Y0 + J2 * DELY
       END DO
    END DO

  END SUBROUTINE SET_RX_SUBNET_QUAD

end module franken_subroutines

module dump_franken_variables
contains
SUBROUTINE dump_franken_LEROI_3D_vars (IPR,NFRQ,FREQ,SOURCE_TYPE,NTX,MXVRTX,NVRTX,SXN,SXE,SXZ,SXDIP,SXAZM,NRXTX, &
     MRXTX,RXID,MQVR,MXRS,XRXTX,YRXTX,ZRXTX,NLYR,THKD,RES,RMUD,REPS,CHRG,CTAU, &
     CFREQ,NPLT,MXAB,CELLW,PLNGTH,PLWDTH,XCNTR,YCNTR,PLTOP,PLAZM,PLDIP,PLUNJ,  &
     INTRUDE,SIG_T,CHRGP,CTAUP,CFREQP,MXRHO,RHOTRP,INVERT,BFD_SCAT)
  !----------------------------------------------------------------------------------------------

  !***  Called by MAIN
  !***  Calls SET_MGT, SET_MAX_INTRP

  ! Main routine for 3D Leroi computation for the scattered field.
  ! For magnetic dipole and loop receivers, BFD_SCAT in Teslas per unit amp.
  !
  ! For magnetic dipole receivers, BFD_SCAT(JF,JR,JS,1:3) contains the
  ! 1: north, 2: east & 3:vertical components for frequency JF, transmitter JS, receiver JR.
  !
  ! The response for electric dipoles and loop receivers is contained in BFD_SCAT(JF,JR,JS,1),
  ! BFD_SCAT(JF,JR,JS,2:3) is set to zero.
  !
  !   NFRQ         - number of frequencies
  !   FREQ         - array of frequencies
  !   SOURCE_TYPE  = 1 => general loop
  !                = 2 => grounded wire
  !                = 3 => magnetic dipole
  !                = 4 => coincident loop
  !   NTX          - number of transmitter positions
  !   MXVRTX       - maximum number of vertices for any transmitter
  !   NVRTX(J)     - number of vertices for transmitter J
  !   SXE(K,J)     = local east coordinate of vertex K for loop position J
  !   SXN(K,J)     = local coordinate of vertex K for loop position J
  !   SXZ(J)       = depth of Tx J
  !   SXDIP(J)     = dip (in radians) of dipole J (eg; vertical = 0, horizontal = 90)
  !   SXAZM(J)     = azimuth (in radians) of dipole J (north = 0, east = 90)
  !   NRXTX(J)     - number of receivers for transmitter J
  !   MRXTX        - maximum number of receivers per transmitter
  !   RXID(I,J)    - RX_TYPE of receiver I for transmitter J. 1 => MD; 2 => ED; 4=> cdnt loop.
  !   MQVR         - maximum number of vertices for all receivers (= 1 if all sources are magnetic dipoles)
  !   XRXTX(I,J,K) - north coordinate of the Kth vertex of the Ith receiver of transmitter J
  !   YRXTX(I,J,K) - east coordinate of the Kth vertex of the Ith receiver of transmitter J
  !   ZRXTX(I,J)   - depth of the Ith receiver of transmitter J
  !                - K = 1 only for mag dipole Rx; 1 to 2 for electric dipole Rx; 1 to 4 for loop Rx
  !   NLYR         - number of layers
  !   RES          - layer conductivities
  !   RMUD         - mu(i) / mu(0)
  !   REPS         - array of relative dislectric constants
  !   THKD         - thicknesses of NLYR -1 layers above basement
  !   CHRG         - C-C chargeability
  !   CTAU         - array of layer relaxation times (sec).
  !   CFREQ        - array of layer frequency parameters.
  !   RHOTRP       - horizontal distance interpolation array (15 pts / decade) of dimension MXRHO
  !
  !           Parameters for NPLT plates
  !           --------------------------
  !
  !   MXAB   - Number of cells in biggest plate
  !   CELLW  - nominal cell dimension
  !   PLNGTH - strike length for each plate
  !   PLWDTH - dip width for each plate
  !   XCNTR  - north coordinates of plate reference & pivot point
  !   YCNTR  - east coordinates of plate reference & pivot point
  !   PLTOP  - depth to top from surface
  !   PLAZM  - strike angle (radians) = dip azimuth - pi/2
  !   PLDIP  - dip angle
  !   PLUNJ  - plunge rotation
  !   SIG_T  - conductivity thickness product
  !   CHRGP  - Cole Cole chargeability
  !   CTAUP  - Cole Cole time constant
  !   CFREQP - Cole Cole frequency constant
  !

  IMPLICIT NONE
  INTEGER, PARAMETER :: QL=SELECTED_REAL_KIND(12,80), NMG1=3, NQS=1000
  COMPLEX, PARAMETER :: ZERO=(0.,0.)
  INTEGER NLYR,NPLT,MXAB,IPR,NFRQ,SOURCE_TYPE,NTX, &
       MXVRTX,NVRTX(NTX),NRXTX(NTX),MRXTX,MXRS,MQVR,MXRHO,RXID(MRXTX,NTX)
  REAL FREQ(NFRQ),CELLW,RHOTRP(MXRHO)
  REAL, DIMENSION(NLYR) :: RES,REPS,CTAU,CFREQ,CHRG
  REAL, DIMENSION(NTX) :: SXDIP,SXAZM,SXZ
  REAL, DIMENSION(NPLT) :: SIG_T,CHRGP,CTAUP,CFREQP,XCNTR,YCNTR,PLTOP,PLWDTH, &
       PLNGTH,PLAZM,PLDIP,PLUNJ
  REAL, DIMENSION(MXVRTX,NTX) :: SXN,SXE
  REAL, DIMENSION(MRXTX,NTX) :: ZRXTX
  REAL, DIMENSION(MRXTX,NTX,MQVR) :: XRXTX,YRXTX
  COMPLEX BFD_SCAT(NFRQ,MRXTX,NTX,3)
  REAL(KIND=QL) RMUD(0:NLYR)
  REAL(KIND=QL), DIMENSION(NLYR) :: THKD
  LOGICAL INVERT,INTRUDE



  write(102,*) 'IPR',IPR
  write(102,*) 'NFRQ',NFRQ
  write(102,*) 'FREQ',FREQ
  write(102,*) 'SOURCE_TYPE',SOURCE_TYPE
  write(102,*) 'NTX',NTX
  write(102,*) 'MXVRTX',MXVRTX
  write(102,*) 'NVRTX',NVRTX
  write(102,*) 'SXN',SXN
  write(102,*) 'SXE',SXE
  write(102,*) 'SXZ',SXZ
  write(102,*) 'SXDIP',SXDIP
  write(102,*) 'SXZAM',SXAZM
  write(102,*) 'NRXTX',NRXTX
  write(102,*) 'MRXTX',MRXTX
  write(102,*) 'RXID',RXID
  write(102,*) 'MQVR',MQVR
  write(102,*) 'MXRS',MXRS
  write(102,*) 'XRXTX',XRXTX
  write(102,*) 'YRTXTX',YRXTX
  write(102,*) 'ZRXTX',ZRXTX
  write(102,*) 'NLYR',NLYR
  write(102,*) 'THKD',THKD
  write(102,*) 'RES',RES
  write(102,*)'RMUD',RMUD
  write(102,*) 'REPS',REPS
  write(102,*) 'CHRG',CHRG
  write(102,*) 'CTAU',CTAU
  write(102,*) 'CFREQ',CFREQ
  write(102,*) 'NPLT',NPLT
  write(102,*) 'MXAB',MXAB
  write(102,*) 'CELLW',CELLW
  write(102,*) 'PLNGTH',PLNGTH
  write(102,*) 'PLWDTH',PLWDTH
  write(102,*) 'XCNTR',XCNTR
  write(102,*) 'YCNTR',YCNTR
  write(102,*) 'PLTOP',PLTOP
  write(102,*) 'PLAZM',PLAZM
  write(102,*) 'PLDIP',PLDIP
  write(102,*) 'PLUNJ',PLUNJ
  write(102,*) 'INTRUDE',INTRUDE
  write(102,*) 'SIG_T',SIG_T
  write(102,*) 'CHRGP',CHRGP
  write(102,*) 'CTAUP',CTAUP
  write(102,*) 'CFREQP',CFREQP
  write(102,*) 'MXRHO',MXRHO
  write(102,*) 'RHOTRP',RHOTRP
  write(102,*) 'INVERT',INVERT
  write(102,*) 'BFD_SCAT',BFD_SCAT


end subroutine dump_franken_leroi_3d_vars

end module dump_franken_variables
